<!DOCTYPE html><!-- saved from url=(0080)https://leanprover.github.io/theorem_proving_in_lean4/dependent_type_theory.html -->

<html lang="en" class="js sidebar-visible light"><head><meta http-equiv="content-type" content="text/html; charset=UTF-8"><!-- Book generated using mdBook -->
        
        
        <title>의존 유형론 - 린4로 하는 정리 증명</title><!-- Custom HTML head --><!-- Fonts --><!-- Highlight.js Stylesheets --><!-- Custom theme stylesheets -->
        
        


        
        


        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="rgba(0, 0, 0, 0)">

        
        <link rel="icon" href="https://leanprover.github.io/theorem_proving_in_lean4/favicon.svg">
        
        
        <link rel="shortcut icon" href="https://leanprover.github.io/theorem_proving_in_lean4/favicon.png">
        
        <link rel="stylesheet" href="./Dependent Type Theory - Theorem Proving in Lean 4_files/variables.css">
        <link rel="stylesheet" href="./Dependent Type Theory - Theorem Proving in Lean 4_files/general.css">
        <link rel="stylesheet" href="./Dependent Type Theory - Theorem Proving in Lean 4_files/chrome.css">
        
        <link rel="stylesheet" href="./Dependent Type Theory - Theorem Proving in Lean 4_files/print.css" media="print">
        

        
        <link rel="stylesheet" href="./Dependent Type Theory - Theorem Proving in Lean 4_files/font-awesome.css">
        
        <link rel="stylesheet" href="./Dependent Type Theory - Theorem Proving in Lean 4_files/fonts.css">
        

        
        <link rel="stylesheet" href="./Dependent Type Theory - Theorem Proving in Lean 4_files/highlight.css">
        <link rel="stylesheet" href="./Dependent Type Theory - Theorem Proving in Lean 4_files/tomorrow-night.css" disabled="">
        <link rel="stylesheet" href="./Dependent Type Theory - Theorem Proving in Lean 4_files/ayu-highlight.css" disabled="">

        
        

        
    </head>
    <body><!-- Provide site root to javascript -->
        
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script><!-- Work around some values being stored in localStorage wrapped in quotes -->

        
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script><!-- Set the theme before any content is loaded, prevents flash -->

        
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script><!-- Hide / unhide sidebar before it is displayed -->

        
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents" aria-hidden="false">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="https://leanprover.github.io/theorem_proving_in_lean4/title_page.html" tabindex="0">린 4로 하는 정리 증명</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/introduction.html" tabindex="0"><strong aria-hidden="true">1.</strong> 소개(Introduction)</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/dependent_type_theory.html" class="active" tabindex="0"><strong aria-hidden="true">2.</strong> 의존 유형론(Dependent Type Theory)</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/propositions_and_proofs.html" tabindex="0"><strong aria-hidden="true">3.</strong> 명제와 증명(Propositions and Proofs)</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html" tabindex="0"><strong aria-hidden="true">4.</strong> 한정기호와 동등성(Quantifiers and Equality)</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/tactics.html" tabindex="0"><strong aria-hidden="true">5.</strong> 전략(Tactics)</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/interacting_with_lean.html" tabindex="0"><strong aria-hidden="true">6.</strong> 린과 상호작용하기(Interacting with Lean)</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/inductive_types.html" tabindex="0"><strong aria-hidden="true">7.</strong> 귀납형(Inductive Types)</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html" tabindex="0"><strong aria-hidden="true">8.</strong> 귀납과 재귀(Induction and Recursion)</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/structures_and_records.html" tabindex="0"><strong aria-hidden="true">9.</strong> 구조체와 레코드(Structures and Records)</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/type_classes.html" tabindex="0"><strong aria-hidden="true">10.</strong> 유형 계층(Type Classes)</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/conv.html" tabindex="0"><strong aria-hidden="true">11.</strong> 전략 모드로 전환(The Conversion Tactic Mode)</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/axioms_and_computation.html" tabindex="0"><strong aria-hidden="true">12.</strong> 공리계와 계산(Axioms and Computation)</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar" style="top: 0px;">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="목차 토글" aria-label="Toggle Table of Contents" aria-controls="sidebar" aria-expanded="true">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="테마 바꾸기" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">밝게(기본)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">녹슨 색</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">검은색</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">짙푸른색</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">짙은 검은색</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="탐색. (단축기: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">린 4로 하는 정리 증명</h1>

                    <div class="right-buttons">
                        
                        <a href="https://leanprover.github.io/theorem_proving_in_lean4/print.html" title="책 인쇄하기" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/leanprover/theorem_proving_in_lean4" title="깃 저장소" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" placeholder="이 책을 찾아보기 ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div><!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                

                
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/dependent_type_theory.html#dependent-type-theory" id="dependent-type-theory">의존 유형론</a></h1>
<p>Dependent type theory is a powerful and expressive language, allowing
you to express complex mathematical assertions, write complex hardware
and software specifications, and reason about both of these in a
natural and uniform way. Lean is based on a version of dependent type
theory known as the <em>Calculus of Constructions</em>, with a countable
hierarchy of non-cumulative universes and inductive types. By the end
of this chapter, you will understand much of what this means.</p>
<h2><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/dependent_type_theory.html#simple-type-theory" id="simple-type-theory">Simple Type Theory</a></h2>
<p>"Type theory" gets its name from the fact that every expression has an
associated <em>type</em>. For example, in a given context, <code class="hljs">x + 0</code> may
denote a natural number and <code class="hljs">f</code> may denote a function on the natural
numbers. For those who like precise definitions, a Lean natural number
is an arbitrary-precision unsigned integer.</p>
<p>Here are some examples of how you can declare objects in Lean and
check their types.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-comment">/- Define some constants. -/</span>

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span> <span class="hljs-symbol">:</span></span> Nat := <span class="hljs-number">1</span>       <span class="hljs-comment">-- m is a natural number</span>
<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">n</span> <span class="hljs-symbol">:</span></span> Nat := <span class="hljs-number">0</span>
<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">b1</span> <span class="hljs-symbol">:</span></span> Bool := <span class="hljs-literal">true</span>  <span class="hljs-comment">-- b1 is a Boolean</span>
<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">b2</span> <span class="hljs-symbol">:</span></span> Bool := <span class="hljs-literal">false</span>

<span class="hljs-comment">/- Check their types. -/</span>

<span class="hljs-keyword">#check</span> m            <span class="hljs-comment">-- output: Nat</span>
<span class="hljs-keyword">#check</span> n
<span class="hljs-keyword">#check</span> n + <span class="hljs-number">0</span>        <span class="hljs-comment">-- Nat</span>
<span class="hljs-keyword">#check</span> m * (n + <span class="hljs-number">0</span>)  <span class="hljs-comment">-- Nat</span>
<span class="hljs-keyword">#check</span> b1           <span class="hljs-comment">-- Bool</span>
<span class="hljs-keyword">#check</span> b1 &amp;&amp; b2     <span class="hljs-comment">-- "&amp;&amp;" is the Boolean and</span>
<span class="hljs-keyword">#check</span> b1 || b2     <span class="hljs-comment">-- Boolean or</span>
<span class="hljs-keyword">#check</span> <span class="hljs-literal">true</span>         <span class="hljs-comment">-- Boolean "true"</span>

<span class="hljs-comment">/- Evaluate -/</span>

<span class="hljs-keyword">#eval</span> <span class="hljs-number">5</span> * <span class="hljs-number">4</span>         <span class="hljs-comment">-- 20</span>
<span class="hljs-keyword">#eval</span> m + <span class="hljs-number">2</span>         <span class="hljs-comment">-- 3</span>
<span class="hljs-keyword">#eval</span> b1 &amp;&amp; b2      <span class="hljs-comment">-- false</span>
</code></pre>
<p>Any text between <code class="hljs">/-</code> and <code class="hljs">-/</code> constitutes a comment block that is
ignored by Lean. Similarly, two dashes <code class="hljs">--</code> indicate that the rest of
the line contains a comment that is also ignored. Comment blocks can
be nested, making it possible to "comment out" chunks of code, just as
in many programming languages.</p>
<p>The <code class="hljs">def</code> keyword declares new constant symbols into the
working environment. In the example above, <code class="hljs">def m : Nat := 1</code>
defines a new constant <code class="hljs">m</code> of type <code class="hljs">Nat</code> whose value is <code class="hljs">1</code>.
The <code class="hljs">#check</code> command asks Lean to report their
types; in Lean, auxiliary commands that query the system for
information typically begin with the hash (#) symbol.
The <code class="hljs">#eval</code> command asks Lean to evaluate the given expression.
You should try
declaring some constants and type checking some expressions on your
own. Declaring new objects in this manner is a good way to experiment
with the system.</p>
<p>What makes simple type theory powerful is that you can build new types
out of others. For example, if <code class="hljs">a</code> and <code class="hljs">b</code> are types, <code class="hljs">a -&gt; b</code>
denotes the type of functions from <code class="hljs">a</code> to <code class="hljs">b</code>, and <code class="hljs">a × b</code>
denotes the type of pairs consisting of an element of <code class="hljs">a</code> paired
with an element of <code class="hljs">b</code>, also known as the <em>Cartesian product</em>. Note
that <code class="hljs">×</code> is a Unicode symbol. The judicious use of Unicode improves
legibility, and all modern editors have great support for it. In the
Lean standard library, you often see Greek letters to denote types,
and the Unicode symbol <code class="hljs">→</code> as a more compact version of <code class="hljs">-&gt;</code>.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> Nat → Nat      <span class="hljs-comment">-- type the arrow as "\to" or "\r"</span>
<span class="hljs-keyword">#check</span> Nat -&gt; Nat     <span class="hljs-comment">-- alternative ASCII notation</span>

<span class="hljs-keyword">#check</span> Nat × Nat      <span class="hljs-comment">-- type the product as "\times"</span>
<span class="hljs-keyword">#check</span> Prod Nat Nat   <span class="hljs-comment">-- alternative notation</span>

<span class="hljs-keyword">#check</span> Nat → Nat → Nat
<span class="hljs-keyword">#check</span> Nat → (Nat → Nat)  <span class="hljs-comment">--  same type as above</span>

<span class="hljs-keyword">#check</span> Nat × Nat → Nat
<span class="hljs-keyword">#check</span> (Nat → Nat) → Nat <span class="hljs-comment">-- a "functional"</span>

<span class="hljs-keyword">#check</span> Nat.succ     <span class="hljs-comment">-- Nat → Nat</span>
<span class="hljs-keyword">#check</span> (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)       <span class="hljs-comment">-- Nat × Nat</span>
<span class="hljs-keyword">#check</span> Nat.add      <span class="hljs-comment">-- Nat → Nat → Nat</span>

<span class="hljs-keyword">#check</span> Nat.succ <span class="hljs-number">2</span>   <span class="hljs-comment">-- Nat</span>
<span class="hljs-keyword">#check</span> Nat.add <span class="hljs-number">3</span>    <span class="hljs-comment">-- Nat → Nat</span>
<span class="hljs-keyword">#check</span> Nat.add <span class="hljs-number">5</span> <span class="hljs-number">2</span>  <span class="hljs-comment">-- Nat</span>
<span class="hljs-keyword">#check</span> (<span class="hljs-number">5</span>, <span class="hljs-number">9</span>).<span class="hljs-number">1</span>     <span class="hljs-comment">-- Nat</span>
<span class="hljs-keyword">#check</span> (<span class="hljs-number">5</span>, <span class="hljs-number">9</span>).<span class="hljs-number">2</span>     <span class="hljs-comment">-- Nat</span>

<span class="hljs-keyword">#eval</span> Nat.succ <span class="hljs-number">2</span>   <span class="hljs-comment">-- 3</span>
<span class="hljs-keyword">#eval</span> Nat.add <span class="hljs-number">5</span> <span class="hljs-number">2</span>  <span class="hljs-comment">-- 7</span>
<span class="hljs-keyword">#eval</span> (<span class="hljs-number">5</span>, <span class="hljs-number">9</span>).<span class="hljs-number">1</span>     <span class="hljs-comment">-- 5</span>
<span class="hljs-keyword">#eval</span> (<span class="hljs-number">5</span>, <span class="hljs-number">9</span>).<span class="hljs-number">2</span>     <span class="hljs-comment">-- 9</span>
</code></pre>
<p>Once again, you should try some examples on your own.</p>
<p>Let's take a look at some basic syntax. You can enter the unicode
arrow <code class="hljs">→</code> by typing <code class="hljs">\to</code> or <code class="hljs">\r</code> or <code class="hljs">\-&gt;</code>. You can also use the
ASCII alternative <code class="hljs">-&gt;</code>, so the expressions <code class="hljs">Nat -&gt; Nat</code> and <code class="hljs">Nat → Nat</code> mean the same thing. Both expressions denote the type of
functions that take a natural number as input and return a natural
number as output. The unicode symbol <code class="hljs">×</code> for the Cartesian product
is entered as <code class="hljs">\times</code>. You will generally use lower-case Greek
letters like <code class="hljs">α</code>, <code class="hljs">β</code>, and <code class="hljs">γ</code> to range over types. You can
enter these particular ones with <code class="hljs">\a</code>, <code class="hljs">\b</code>, and <code class="hljs">\g</code>.</p>
<p>There are a few more things to notice here. First, the application of
a function <code class="hljs">f</code> to a value <code class="hljs">x</code> is denoted <code class="hljs">f x</code> (e.g., <code class="hljs">Nat.succ 2</code>).
Second, when writing type expressions, arrows associate to the <em>right</em>; for
example, the type of <code class="hljs">Nat.add</code> is <code class="hljs">Nat → Nat → Nat</code> which is equivalent
to <code class="hljs">Nat → (Nat → Nat)</code>. Thus you can
view <code class="hljs">Nat.add</code> as a function that takes a natural number and returns
another function that takes a natural number and returns a natural
number. In type theory, this is generally more convenient than
writing <code class="hljs">Nat.add</code> as a function that takes a pair of natural numbers as
input and returns a natural number as output. For example, it allows
you to "partially apply" the function <code class="hljs">Nat.add</code>.  The example above shows
that <code class="hljs">Nat.add 3</code> has type <code class="hljs">Nat → Nat</code>, that is, <code class="hljs">Nat.add 3</code> returns a
function that "waits" for a second argument, <code class="hljs">n</code>, which is then
equivalent to writing <code class="hljs">Nat.add 3 n</code>.</p><!-- Taking a function ``h`` of type ``Nat
× Nat → Nat`` and "redefining" it to look like ``g`` is a process
known as *currying*. -->

<p>You have seen that if you have <code class="hljs">m : Nat</code> and <code class="hljs">n : Nat</code>, then
<code class="hljs">(m, n)</code> denotes the ordered pair of <code class="hljs">m</code> and <code class="hljs">n</code> which is of
type <code class="hljs">Nat × Nat</code>. This gives you a way of creating pairs of natural
numbers. Conversely, if you have <code class="hljs">p : Nat × Nat</code>, then you can write
<code class="hljs">p.1 : Nat</code> and <code class="hljs">p.2 : Nat</code>. This gives you a way of extracting
its two components.</p>
<h2><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/dependent_type_theory.html#types-as-objects" id="types-as-objects">Types as objects</a></h2>
<p>One way in which Lean's dependent type theory extends simple type
theory is that types themselves --- entities like <code class="hljs">Nat</code> and <code class="hljs">Bool</code>
--- are first-class citizens, which is to say that they themselves are
objects. For that to be the case, each of them also has to have a
type.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> Nat               <span class="hljs-comment">-- Type</span>
<span class="hljs-keyword">#check</span> Bool              <span class="hljs-comment">-- Type</span>
<span class="hljs-keyword">#check</span> Nat → Bool        <span class="hljs-comment">-- Type</span>
<span class="hljs-keyword">#check</span> Nat × Bool        <span class="hljs-comment">-- Type</span>
<span class="hljs-keyword">#check</span> Nat → Nat         <span class="hljs-comment">-- ...</span>
<span class="hljs-keyword">#check</span> Nat × Nat → Nat
<span class="hljs-keyword">#check</span> Nat → Nat → Nat
<span class="hljs-keyword">#check</span> Nat → (Nat → Nat)
<span class="hljs-keyword">#check</span> Nat → Nat → Bool
<span class="hljs-keyword">#check</span> (Nat → Nat) → Nat
</code></pre>
<p>You can see that each one of the expressions above is an object of
type <code class="hljs">Type</code>. You can also declare new constants for types:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> α <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Type</span> := Nat
<span class="hljs-theorem"><span class="hljs-keyword">def</span> β <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Type</span> := Bool
<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">F</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Type</span> → <span class="hljs-built_in">Type</span> := List
<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">G</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Type</span> → <span class="hljs-built_in">Type</span> → <span class="hljs-built_in">Type</span> := Prod

<span class="hljs-keyword">#check</span> α        <span class="hljs-comment">-- Type</span>
<span class="hljs-keyword">#check</span> F α      <span class="hljs-comment">-- Type</span>
<span class="hljs-keyword">#check</span> F Nat    <span class="hljs-comment">-- Type</span>
<span class="hljs-keyword">#check</span> G α      <span class="hljs-comment">-- Type → Type</span>
<span class="hljs-keyword">#check</span> G α β    <span class="hljs-comment">-- Type</span>
<span class="hljs-keyword">#check</span> G α Nat  <span class="hljs-comment">-- Type</span>
</code></pre>
<p>As the example above suggests, you have already seen an example of a function of type
<code class="hljs">Type → Type → Type</code>, namely, the Cartesian product <code class="hljs">Prod</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> α <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Type</span> := Nat
<span class="hljs-theorem"><span class="hljs-keyword">def</span> β <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Type</span> := Bool

<span class="hljs-keyword">#check</span> Prod α β       <span class="hljs-comment">-- Type</span>
<span class="hljs-keyword">#check</span> α × β          <span class="hljs-comment">-- Type</span>

<span class="hljs-keyword">#check</span> Prod Nat Nat   <span class="hljs-comment">-- Type</span>
<span class="hljs-keyword">#check</span> Nat × Nat      <span class="hljs-comment">-- Type</span>
</code></pre>
<p>Here is another example: given any type <code class="hljs">α</code>, the type <code class="hljs">List α</code>
denotes the type of lists of elements of type <code class="hljs">α</code>.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> α <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Type</span> := Nat

<span class="hljs-keyword">#check</span> List α    <span class="hljs-comment">-- Type</span>
<span class="hljs-keyword">#check</span> List Nat  <span class="hljs-comment">-- Type</span>
</code></pre>
<p>Given that every expression in Lean has a type, it is natural to ask:
what type does <code class="hljs">Type</code> itself have?</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> <span class="hljs-built_in">Type</span>      <span class="hljs-comment">-- Type 1</span>
</code></pre>
<p>You have actually come up against one of the most subtle aspects of
Lean's typing system. Lean's underlying foundation has an infinite
hierarchy of types:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> <span class="hljs-built_in">Type</span>     <span class="hljs-comment">-- Type 1</span>
<span class="hljs-keyword">#check</span> <span class="hljs-built_in">Type</span> <span class="hljs-number">1</span>   <span class="hljs-comment">-- Type 2</span>
<span class="hljs-keyword">#check</span> <span class="hljs-built_in">Type</span> <span class="hljs-number">2</span>   <span class="hljs-comment">-- Type 3</span>
<span class="hljs-keyword">#check</span> <span class="hljs-built_in">Type</span> <span class="hljs-number">3</span>   <span class="hljs-comment">-- Type 4</span>
<span class="hljs-keyword">#check</span> <span class="hljs-built_in">Type</span> <span class="hljs-number">4</span>   <span class="hljs-comment">-- Type 5</span>
</code></pre>
<p>Think of <code class="hljs">Type 0</code> as a universe of "small" or "ordinary" types.
<code class="hljs">Type 1</code> is then a larger universe of types, which contains <code class="hljs">Type 0</code> as an element, and <code class="hljs">Type 2</code> is an even larger universe of types,
which contains <code class="hljs">Type 1</code> as an element. The list is indefinite, so
that there is a <code class="hljs">Type n</code> for every natural number <code class="hljs">n</code>. <code class="hljs">Type</code> is
an abbreviation for <code class="hljs">Type 0</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> <span class="hljs-built_in">Type</span>
<span class="hljs-keyword">#check</span> <span class="hljs-built_in">Type</span> <span class="hljs-number">0</span>
</code></pre>
<p>Some operations, however, need to be <em>polymorphic</em> over type
universes. For example, <code class="hljs">List α</code> should make sense for any type
<code class="hljs">α</code>, no matter which type universe <code class="hljs">α</code> lives in. This explains the
type annotation of the function <code class="hljs">List</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> List    <span class="hljs-comment">-- Type u_1 → Type u_1</span>
</code></pre>
<p>Here <code class="hljs">u_1</code> is a variable ranging over type levels. The output of the
<code class="hljs">#check</code> command means that whenever <code class="hljs">α</code> has type <code class="hljs">Type n</code>,
<code class="hljs">List α</code> also has type <code class="hljs">Type n</code>. The function <code class="hljs">Prod</code> is
similarly polymorphic:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> Prod    <span class="hljs-comment">-- Type u_1 → Type u_2 → Type (max u_1 u_2)</span>
</code></pre>
<p>To define polymorphic constants, Lean allows you to
declare universe variables explicitly using the <code class="hljs">universe</code> command:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">universe</span> u

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">F</span> <span class="hljs-params">(α : <span class="hljs-built_in">Type</span> u)</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Type</span> u := Prod α α

<span class="hljs-keyword">#check</span> F    <span class="hljs-comment">-- Type u → Type u</span>
</code></pre>
<p>You can avoid the universe command by providing the universe parameters when defining F.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">F</span>.<span class="hljs-params">{u}</span> <span class="hljs-params">(α : <span class="hljs-built_in">Type</span> u)</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Type</span> u := Prod α α

<span class="hljs-keyword">#check</span> F    <span class="hljs-comment">-- Type u → Type u</span>
</code></pre>
<h2><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/dependent_type_theory.html#function-abstraction-and-evaluation" id="function-abstraction-and-evaluation">Function Abstraction and Evaluation</a></h2>
<p>Lean provides a <code class="hljs">fun</code> (or <code class="hljs">λ</code>) keyword to create a function
from an expression as follows:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> <span class="hljs-keyword">fun</span> (x : Nat) =&gt; x + <span class="hljs-number">5</span>   <span class="hljs-comment">-- Nat → Nat</span>
<span class="hljs-keyword">#check</span> λ (x : Nat) =&gt; x + <span class="hljs-number">5</span>     <span class="hljs-comment">-- λ and fun mean the same thing</span>
<span class="hljs-keyword">#check</span> <span class="hljs-keyword">fun</span> x : Nat =&gt; x + <span class="hljs-number">5</span>     <span class="hljs-comment">-- Nat inferred</span>
<span class="hljs-keyword">#check</span> λ x : Nat =&gt; x + <span class="hljs-number">5</span>       <span class="hljs-comment">-- Nat inferred</span>
</code></pre>
<p>You can evaluate a lambda function by passing the required parameters:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> (λ x : Nat =&gt; x + <span class="hljs-number">5</span>) <span class="hljs-number">10</span>    <span class="hljs-comment">-- 15</span>
</code></pre>
<p>Creating a function from another expression is a process known as
<em>lambda abstraction</em>. Suppose you have the variable <code class="hljs">x : α</code> and you can
construct an expression <code class="hljs">t : β</code>, then the expression <code class="hljs">fun (x : α) =&gt; t</code>, or, equivalently, <code class="hljs">λ (x : α) =&gt; t</code>, is an object of type <code class="hljs">α → β</code>. Think of this as the function from <code class="hljs">α</code> to <code class="hljs">β</code> which maps
any value <code class="hljs">x</code> to the value <code class="hljs">t</code>.</p>
<p>Here are some more examples</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> <span class="hljs-keyword">fun</span> x : Nat =&gt; <span class="hljs-keyword">fun</span> y : Bool =&gt; <span class="hljs-keyword">if</span> not y <span class="hljs-keyword">then</span> x + <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> x + <span class="hljs-number">2</span>
<span class="hljs-keyword">#check</span> <span class="hljs-keyword">fun</span> (x : Nat) (y : Bool) =&gt; <span class="hljs-keyword">if</span> not y <span class="hljs-keyword">then</span> x + <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> x + <span class="hljs-number">2</span>
<span class="hljs-keyword">#check</span> <span class="hljs-keyword">fun</span> x y =&gt; <span class="hljs-keyword">if</span> not y <span class="hljs-keyword">then</span> x + <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> x + <span class="hljs-number">2</span>   <span class="hljs-comment">-- Nat → Bool → Nat</span>
</code></pre>
<p>Lean interprets the final three examples as the same expression; in
the last expression, Lean infers the type of <code class="hljs">x</code> and <code class="hljs">y</code> from the
expression <code class="hljs">if not y then x + 1 else x + 2</code>.</p>
<p>Some mathematically common examples of operations of functions can be
described in terms of lambda abstraction:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span> <span class="hljs-params">(n : Nat)</span> <span class="hljs-symbol">:</span></span> String := toString n
<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">g</span> <span class="hljs-params">(s : String)</span> <span class="hljs-symbol">:</span></span> Bool := s.length &gt; <span class="hljs-number">0</span>

<span class="hljs-keyword">#check</span> <span class="hljs-keyword">fun</span> x : Nat =&gt; x        <span class="hljs-comment">-- Nat → Nat</span>
<span class="hljs-keyword">#check</span> <span class="hljs-keyword">fun</span> x : Nat =&gt; <span class="hljs-literal">true</span>     <span class="hljs-comment">-- Nat → Bool</span>
<span class="hljs-keyword">#check</span> <span class="hljs-keyword">fun</span> x : Nat =&gt; g (f x)  <span class="hljs-comment">-- Nat → Bool</span>
<span class="hljs-keyword">#check</span> <span class="hljs-keyword">fun</span> x =&gt; g (f x)        <span class="hljs-comment">-- Nat → Bool</span>
</code></pre>
<p>Think about what these expressions mean. The expression
<code class="hljs">fun x : Nat =&gt; x</code> denotes the identity function on <code class="hljs">Nat</code>, the
expression <code class="hljs">fun x : Nat =&gt; true</code> denotes the constant function that
always returns <code class="hljs">true</code>, and <code class="hljs">fun x : Nat =&gt; g (f x)</code> denotes the
composition of <code class="hljs">f</code> and <code class="hljs">g</code>.  You can, in general, leave off the
type annotation and let Lean infer it for you.  So, for example, you
can write <code class="hljs">fun x =&gt; g (f x)</code> instead of <code class="hljs">fun x : Nat =&gt; g (f x)</code>.</p>
<p>You can pass functions as parameters and by giving them names <code class="hljs">f</code>
and <code class="hljs">g</code> you can then use those functions in the implementation:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> <span class="hljs-keyword">fun</span> (g : String → Bool) (f : Nat → String) (x : Nat) =&gt; g (f x)
<span class="hljs-comment">-- (String → Bool) → (Nat → String) → Nat → Bool</span>
</code></pre>
<p>You can also pass types as parameters:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> <span class="hljs-keyword">fun</span> (α β γ : <span class="hljs-built_in">Type</span>) (g : β → γ) (f : α → β) (x : α) =&gt; g (f x)
</code></pre>
<p>The last expression, for example, denotes the function that takes
three types, <code class="hljs">α</code>, <code class="hljs">β</code>, and <code class="hljs">γ</code>, and two functions, <code class="hljs">g : β → γ</code>
and <code class="hljs">f : α → β</code>, and returns the composition of <code class="hljs">g</code> and <code class="hljs">f</code>.
(Making sense of the type of this function requires an understanding
of dependent products, which will be explained below.)</p>
<p>The general form of a lambda expression is <code class="hljs">fun x : α =&gt; t</code>, where
the variable <code class="hljs">x</code> is a "bound variable": it is really a placeholder,
whose "scope" does not extend beyond the expression <code class="hljs">t</code>.  For
example, the variable <code class="hljs">b</code> in the expression <code class="hljs">fun (b : β) (x : α) =&gt; b</code>
has nothing to do with the constant <code class="hljs">b</code> declared earlier.  In fact,
the expression denotes the same function as <code class="hljs">fun (u : β) (z : α) =&gt; u</code>.</p>
<p>Formally, expressions that are the same up to a renaming of bound
variables are called <em>alpha equivalent</em>, and are considered "the
same." Lean recognizes this equivalence.</p>
<p>Notice that applying a term <code class="hljs">t : α → β</code> to a term <code class="hljs">s : α</code> yields
an expression <code class="hljs">t s : β</code>. Returning to the previous example and
renaming bound variables for clarity, notice the types of the
following expressions:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> (<span class="hljs-keyword">fun</span> x : Nat =&gt; x) <span class="hljs-number">1</span>     <span class="hljs-comment">-- Nat</span>
<span class="hljs-keyword">#check</span> (<span class="hljs-keyword">fun</span> x : Nat =&gt; <span class="hljs-literal">true</span>) <span class="hljs-number">1</span>  <span class="hljs-comment">-- Bool</span>

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span> <span class="hljs-params">(n : Nat)</span> <span class="hljs-symbol">:</span></span> String := toString n
<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">g</span> <span class="hljs-params">(s : String)</span> <span class="hljs-symbol">:</span></span> Bool := s.length &gt; <span class="hljs-number">0</span>

<span class="hljs-keyword">#check</span>
  (<span class="hljs-keyword">fun</span> (α β γ : <span class="hljs-built_in">Type</span>) (u : β → γ) (v : α → β) (x : α) =&gt; u (v x)) Nat String Bool g f <span class="hljs-number">0</span>
  <span class="hljs-comment">-- Bool</span>
</code></pre>
<p>As expected, the expression <code class="hljs">(fun x : Nat =&gt;  x) 1</code> has type <code class="hljs">Nat</code>.
In fact, more should be true: applying the expression <code class="hljs">(fun x : Nat =&gt; x)</code> to <code class="hljs">1</code> should "return" the value <code class="hljs">1</code>. And, indeed, it does:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> (<span class="hljs-keyword">fun</span> x : Nat =&gt; x) <span class="hljs-number">1</span>     <span class="hljs-comment">-- 1</span>
<span class="hljs-keyword">#eval</span> (<span class="hljs-keyword">fun</span> x : Nat =&gt; <span class="hljs-literal">true</span>) <span class="hljs-number">1</span>  <span class="hljs-comment">-- true</span>
</code></pre>
<p>You will see later how these terms are evaluated. For now, notice that
this is an important feature of dependent type theory: every term has
a computational behavior, and supports a notion of <em>normalization</em>. In
principle, two terms that reduce to the same value are called
<em>definitionally equal</em>. They are considered "the same" by Lean's type
checker, and Lean does its best to recognize and support these
identifications.</p>
<p>Lean is a complete programming language. It has a compiler that
generates a binary executable and an interactive interpreter. You can
use the command <code class="hljs">#eval</code> to execute expressions, and it is the
preferred way of testing your functions.</p><!--
Note that `#eval` and
`#reduce` are *not* equivalent. The command `#eval` first compiles
Lean expressions into an intermediate representation (IR) and then
uses an interpreter to execute the generated IR. Some builtin types
(e.g., `Nat`, `String`, `Array`) have a more efficient representation
in the IR. The IR has support for using foreign functions that are
opaque to Lean.

In contrast, the ``#reduce`` command relies on a reduction engine
similar to the one used in Lean's trusted kernel, the part of Lean
that is responsible for checking and verifying the correctness of
expressions and proofs. It is less efficient than ``#eval``, and
treats all foreign functions as opaque constants. You will learn later
that there are some other differences between the two commands.
-->

<h2><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/dependent_type_theory.html#definitions" id="definitions">Definitions</a></h2>
<p>Recall that the <code class="hljs">def</code> keyword provides one important way of declaring new named
objects.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span><span class="hljs-title">o</span><span class="hljs-title">u</span><span class="hljs-title">b</span><span class="hljs-title">l</span><span class="hljs-title">e</span> <span class="hljs-params">(x : Nat)</span> <span class="hljs-symbol">:</span></span> Nat :=
  x + x
</code></pre>
<p>This might look more familiar to you if you know how functions work in
other programming languages. The name <code class="hljs">double</code> is defined as a
function that takes an input parameter <code class="hljs">x</code> of type <code class="hljs">Nat</code>, where the
result of the call is <code class="hljs">x + x</code>, so it is returning type <code class="hljs">Nat</code>. You
can then invoke this function using:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="Show hidden lines" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="boring"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span><span class="hljs-title">o</span><span class="hljs-title">u</span><span class="hljs-title">b</span><span class="hljs-title">l</span><span class="hljs-title">e</span> <span class="hljs-params">(x : Nat)</span> <span class="hljs-symbol">:</span></span> Nat :=
</span><span class="boring"> x + x
</span><span class="hljs-keyword">#eval</span> double <span class="hljs-number">3</span>    <span class="hljs-comment">-- 6</span>
</code></pre>
<p>In this case you can think of <code class="hljs">def</code> as a kind of named <code class="hljs">lambda</code>.
The following yields the same result:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span><span class="hljs-title">o</span><span class="hljs-title">u</span><span class="hljs-title">b</span><span class="hljs-title">l</span><span class="hljs-title">e</span> <span class="hljs-symbol">:</span></span> Nat → Nat :=
  <span class="hljs-keyword">fun</span> x =&gt; x + x

<span class="hljs-keyword">#eval</span> double <span class="hljs-number">3</span>    <span class="hljs-comment">-- 6</span>
</code></pre>
<p>You can omit the type declarations when Lean has enough information to
infer it.  Type inference is an important part of Lean:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span><span class="hljs-title">o</span><span class="hljs-title">u</span><span class="hljs-title">b</span><span class="hljs-title">l</span><span class="hljs-title">e</span> <span class="hljs-symbol">:</span></span>=
  <span class="hljs-keyword">fun</span> (x : Nat) =&gt; x + x
</code></pre>
<p>The general form of a definition is <code class="hljs">def foo : α := bar</code> where
<code class="hljs">α</code> is the type returned from the expression <code class="hljs">bar</code>.  Lean can
usually infer the type <code class="hljs">α</code>, but it is often a good idea to write it
explicitly.  This clarifies your intention, and Lean will flag an
error if the right-hand side of the definition does not have a matching
type.</p>
<p>The right hand side <code class="hljs">bar</code> can be any expression, not just a lambda.
So <code class="hljs">def</code> can also be used to simply name a value like this:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">p</span><span class="hljs-title">i</span> <span class="hljs-symbol">:</span></span>= <span class="hljs-number">3.141592654</span>
</code></pre>
<p><code class="hljs">def</code> can take multiple input parameters.  Let's create one
that adds two natural numbers:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span><span class="hljs-title">d</span><span class="hljs-title">d</span> <span class="hljs-params">(x y : Nat)</span> <span class="hljs-symbol">:</span></span>=
  x + y

<span class="hljs-keyword">#eval</span> add <span class="hljs-number">3</span> <span class="hljs-number">2</span>               <span class="hljs-comment">-- 5</span>
</code></pre>
<p>The parameter list can be separated like this:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="Show hidden lines" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="boring"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span><span class="hljs-title">o</span><span class="hljs-title">u</span><span class="hljs-title">b</span><span class="hljs-title">l</span><span class="hljs-title">e</span> <span class="hljs-params">(x : Nat)</span> <span class="hljs-symbol">:</span></span> Nat :=
</span><span class="boring"> x + x
</span><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span><span class="hljs-title">d</span><span class="hljs-title">d</span> <span class="hljs-params">(x : Nat)</span> <span class="hljs-params">(y : Nat)</span> <span class="hljs-symbol">:</span></span>=
  x + y

<span class="hljs-keyword">#eval</span> add (double <span class="hljs-number">3</span>) (<span class="hljs-number">7</span> + <span class="hljs-number">9</span>)  <span class="hljs-comment">-- 22</span>
</code></pre>
<p>Notice here we called the <code class="hljs">double</code> function to create the first
parameter to <code class="hljs">add</code>.</p>
<p>You can use other more interesting expressions inside a <code class="hljs">def</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">g</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">a</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">r</span> <span class="hljs-params">(x y : Nat)</span> <span class="hljs-symbol">:</span></span>=
  <span class="hljs-keyword">if</span> x &gt; y <span class="hljs-keyword">then</span> x
  <span class="hljs-keyword">else</span> y
</code></pre>
<p>You can probably guess what this one will do.</p>
<p>You can also define a function that takes another function as input.
The following calls a given function twice passing the output of the
first invocation to the second:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="Show hidden lines" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="boring"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span><span class="hljs-title">o</span><span class="hljs-title">u</span><span class="hljs-title">b</span><span class="hljs-title">l</span><span class="hljs-title">e</span> <span class="hljs-params">(x : Nat)</span> <span class="hljs-symbol">:</span></span> Nat :=
</span><span class="boring"> x + x
</span><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span><span class="hljs-title">o</span><span class="hljs-title">Tw</span><span class="hljs-title">i</span><span class="hljs-title">c</span><span class="hljs-title">e</span> <span class="hljs-params">(f : Nat → Nat)</span> <span class="hljs-params">(x : Nat)</span> <span class="hljs-symbol">:</span></span> Nat :=
  f (f x)

<span class="hljs-keyword">#eval</span> doTwice double <span class="hljs-number">2</span>   <span class="hljs-comment">-- 8</span>
</code></pre>
<p>Now to get a bit more abstract, you can also specify arguments that
are like type parameters:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">c</span><span class="hljs-title">o</span><span class="hljs-title">m</span><span class="hljs-title">p</span><span class="hljs-title">o</span><span class="hljs-title">s</span><span class="hljs-title">e</span> <span class="hljs-params">(α β γ : <span class="hljs-built_in">Type</span>)</span> <span class="hljs-params">(g : β → γ)</span> <span class="hljs-params">(f : α → β)</span> <span class="hljs-params">(x : α)</span> <span class="hljs-symbol">:</span></span> γ :=
  g (f x)
</code></pre>
<p>This means <code class="hljs">compose</code> is a function that takes any two functions as input
arguments, so long as those functions each take only one input.
The type algebra <code class="hljs">β → γ</code> and <code class="hljs">α → β</code> means it is a requirement
that the type of the output of the second function must match the
type of the input to the first function - which makes sense, otherwise
the two functions would not be composable.</p>
<p><code class="hljs">compose</code> also takes a 3rd argument of type <code class="hljs">α</code> which
it uses to invoke the second function (locally named <code class="hljs">f</code>) and it
passes the result of that function (which is type <code class="hljs">β</code>) as input to the
first function (locally named <code class="hljs">g</code>).  The first function returns a type
<code class="hljs">γ</code> so that is also the return type of the <code class="hljs">compose</code> function.</p>
<p><code class="hljs">compose</code> is also very general in that it works over any type
<code class="hljs">α β γ</code>.  This means <code class="hljs">compose</code> can compose just about any 2 functions
so long as they each take one parameter, and so long as the type of
output of the second matches the input of the first.  For example:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="Show hidden lines" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="boring"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">c</span><span class="hljs-title">o</span><span class="hljs-title">m</span><span class="hljs-title">p</span><span class="hljs-title">o</span><span class="hljs-title">s</span><span class="hljs-title">e</span> <span class="hljs-params">(α β γ : <span class="hljs-built_in">Type</span>)</span> <span class="hljs-params">(g : β → γ)</span> <span class="hljs-params">(f : α → β)</span> <span class="hljs-params">(x : α)</span> <span class="hljs-symbol">:</span></span> γ :=
</span><span class="boring"> g (f x)
</span><span class="boring"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span><span class="hljs-title">o</span><span class="hljs-title">u</span><span class="hljs-title">b</span><span class="hljs-title">l</span><span class="hljs-title">e</span> <span class="hljs-params">(x : Nat)</span> <span class="hljs-symbol">:</span></span> Nat :=
</span><span class="boring"> x + x
</span><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">s</span><span class="hljs-title">q</span><span class="hljs-title">u</span><span class="hljs-title">a</span><span class="hljs-title">r</span><span class="hljs-title">e</span> <span class="hljs-params">(x : Nat)</span> <span class="hljs-symbol">:</span></span> Nat :=
  x * x

<span class="hljs-keyword">#eval</span> compose Nat Nat Nat double square <span class="hljs-number">3</span>  <span class="hljs-comment">-- 18</span>
</code></pre>
<h2><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/dependent_type_theory.html#local-definitions" id="local-definitions">Local Definitions</a></h2>
<p>Lean also allows you to introduce "local" definitions using the
<code class="hljs">let</code> keyword. The expression <code class="hljs">let a := t1; t2</code> is
definitionally equal to the result of replacing every occurrence of
<code class="hljs">a</code> in <code class="hljs">t2</code> by <code class="hljs">t1</code>.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> <span class="hljs-keyword">let</span> y := <span class="hljs-number">2</span> + <span class="hljs-number">2</span>; y * y   <span class="hljs-comment">-- Nat</span>
<span class="hljs-keyword">#eval</span>  <span class="hljs-keyword">let</span> y := <span class="hljs-number">2</span> + <span class="hljs-number">2</span>; y * y   <span class="hljs-comment">-- 16</span>

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">tw</span><span class="hljs-title">i</span><span class="hljs-title">c</span><span class="hljs-title">e</span><span class="hljs-title">_</span><span class="hljs-title">d</span><span class="hljs-title">o</span><span class="hljs-title">u</span><span class="hljs-title">b</span><span class="hljs-title">l</span><span class="hljs-title">e</span> <span class="hljs-params">(x : Nat)</span> <span class="hljs-symbol">:</span></span> Nat :=
  <span class="hljs-keyword">let</span> y := x + x; y * y

<span class="hljs-keyword">#eval</span> twice_double <span class="hljs-number">2</span>   <span class="hljs-comment">-- 16</span>
</code></pre>
<p>Here, <code class="hljs">twice_double x</code> is definitionally equal to the term <code class="hljs">(x + x) * (x + x)</code>.</p>
<p>You can combine multiple assignments by chaining <code class="hljs">let</code> statements:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> <span class="hljs-keyword">let</span> y := <span class="hljs-number">2</span> + <span class="hljs-number">2</span>; <span class="hljs-keyword">let</span> z := y + y; z * z   <span class="hljs-comment">-- Nat</span>
<span class="hljs-keyword">#eval</span>  <span class="hljs-keyword">let</span> y := <span class="hljs-number">2</span> + <span class="hljs-number">2</span>; <span class="hljs-keyword">let</span> z := y + y; z * z   <span class="hljs-comment">-- 64</span>
</code></pre>
<p>The <code class="hljs">;</code> can be omitted when a line break is used.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">t</span> <span class="hljs-params">(x : Nat)</span> <span class="hljs-symbol">:</span></span> Nat :=
  <span class="hljs-keyword">let</span> y := x + x
  y * y
</code></pre>
<p>Notice that the meaning of the expression <code class="hljs">let a := t1; t2</code> is very
similar to the meaning of <code class="hljs">(fun a =&gt; t2) t1</code>, but the two are not
the same. In the first expression, you should think of every instance
of <code class="hljs">a</code> in <code class="hljs">t2</code> as a syntactic abbreviation for <code class="hljs">t1</code>. In the
second expression, <code class="hljs">a</code> is a variable, and the expression
<code class="hljs">fun a =&gt; t2</code> has to make sense independently of the value of <code class="hljs">a</code>.
The <code class="hljs">let</code> construct is a stronger means of abbreviation, and there
are expressions of the form <code class="hljs">let a := t1; t2</code> that cannot be
expressed as <code class="hljs">(fun a =&gt; t2) t1</code>. As an exercise, try to understand
why the definition of <code class="hljs">foo</code> below type checks, but the definition of
<code class="hljs">bar</code> does not.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-title">o</span><span class="hljs-title">o</span> <span class="hljs-symbol">:</span></span>= <span class="hljs-keyword">let</span> a := Nat; <span class="hljs-keyword">fun</span> x : a =&gt; x + <span class="hljs-number">2</span>
<span class="hljs-comment">/-
  def bar := (fun a =&gt; fun x : a =&gt; x + 2) Nat
-/</span>
</code></pre>
<h1><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/dependent_type_theory.html#a-name_variables_and_sectionsavariables-and-sections" id="a-name_variables_and_sectionsavariables-and-sections"></a><a name="_variables_and_sections"></a>Variables and Sections</h1>
<p>Consider the following three function definitions:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">c</span><span class="hljs-title">o</span><span class="hljs-title">m</span><span class="hljs-title">p</span><span class="hljs-title">o</span><span class="hljs-title">s</span><span class="hljs-title">e</span> <span class="hljs-params">(α β γ : <span class="hljs-built_in">Type</span>)</span> <span class="hljs-params">(g : β → γ)</span> <span class="hljs-params">(f : α → β)</span> <span class="hljs-params">(x : α)</span> <span class="hljs-symbol">:</span></span> γ :=
  g (f x)

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span><span class="hljs-title">o</span><span class="hljs-title">Tw</span><span class="hljs-title">i</span><span class="hljs-title">c</span><span class="hljs-title">e</span> <span class="hljs-params">(α : <span class="hljs-built_in">Type</span>)</span> <span class="hljs-params">(h : α → α)</span> <span class="hljs-params">(x : α)</span> <span class="hljs-symbol">:</span></span> α :=
  h (h x)

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span><span class="hljs-title">o</span><span class="hljs-title">T</span><span class="hljs-title">h</span><span class="hljs-title">r</span><span class="hljs-title">i</span><span class="hljs-title">c</span><span class="hljs-title">e</span> <span class="hljs-params">(α : <span class="hljs-built_in">Type</span>)</span> <span class="hljs-params">(h : α → α)</span> <span class="hljs-params">(x : α)</span> <span class="hljs-symbol">:</span></span> α :=
  h (h (h x))
</code></pre>
<p>Lean provides you with the <code class="hljs">variable</code> command to make such
declarations look more compact:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">variable</span> (α β γ : <span class="hljs-built_in">Type</span>)

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">c</span><span class="hljs-title">o</span><span class="hljs-title">m</span><span class="hljs-title">p</span><span class="hljs-title">o</span><span class="hljs-title">s</span><span class="hljs-title">e</span> <span class="hljs-params">(g : β → γ)</span> <span class="hljs-params">(f : α → β)</span> <span class="hljs-params">(x : α)</span> <span class="hljs-symbol">:</span></span> γ :=
  g (f x)

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span><span class="hljs-title">o</span><span class="hljs-title">Tw</span><span class="hljs-title">i</span><span class="hljs-title">c</span><span class="hljs-title">e</span> <span class="hljs-params">(h : α → α)</span> <span class="hljs-params">(x : α)</span> <span class="hljs-symbol">:</span></span> α :=
  h (h x)

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span><span class="hljs-title">o</span><span class="hljs-title">T</span><span class="hljs-title">h</span><span class="hljs-title">r</span><span class="hljs-title">i</span><span class="hljs-title">c</span><span class="hljs-title">e</span> <span class="hljs-params">(h : α → α)</span> <span class="hljs-params">(x : α)</span> <span class="hljs-symbol">:</span></span> α :=
  h (h (h x))
</code></pre>
<p>You can declare variables of any type, not just <code class="hljs">Type</code> itself:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">variable</span> (α β γ : <span class="hljs-built_in">Type</span>)
<span class="hljs-keyword">variable</span> (g : β → γ) (f : α → β) (h : α → α)
<span class="hljs-keyword">variable</span> (x : α)

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">c</span><span class="hljs-title">o</span><span class="hljs-title">m</span><span class="hljs-title">p</span><span class="hljs-title">o</span><span class="hljs-title">s</span><span class="hljs-title">e</span> <span class="hljs-symbol">:</span></span>= g (f x)
<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span><span class="hljs-title">o</span><span class="hljs-title">Tw</span><span class="hljs-title">i</span><span class="hljs-title">c</span><span class="hljs-title">e</span> <span class="hljs-symbol">:</span></span>= h (h x)
<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span><span class="hljs-title">o</span><span class="hljs-title">T</span><span class="hljs-title">h</span><span class="hljs-title">r</span><span class="hljs-title">i</span><span class="hljs-title">c</span><span class="hljs-title">e</span> <span class="hljs-symbol">:</span></span>= h (h (h x))

<span class="hljs-keyword">#print</span> compose
<span class="hljs-keyword">#print</span> doTwice
<span class="hljs-keyword">#print</span> doThrice
</code></pre>
<p>Printing them out shows that all three groups of definitions have
exactly the same effect.</p>
<p>The <code class="hljs">variable</code> command instructs Lean to insert the declared
variables as bound variables in definitions that refer to them by
name. Lean is smart enough to figure out which variables are used
explicitly or implicitly in a definition. You can therefore proceed as
though <code class="hljs">α</code>, <code class="hljs">β</code>, <code class="hljs">γ</code>, <code class="hljs">g</code>, <code class="hljs">f</code>, <code class="hljs">h</code>, and <code class="hljs">x</code> are fixed
objects when you write your definitions, and let Lean abstract the
definitions for you automatically.</p>
<p>When declared in this way, a variable stays in scope until the end of
the file you are working on. Sometimes, however, it is useful to limit
the scope of a variable. For that purpose, Lean provides the notion of
a <code class="hljs">section</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">section</span> useful
  <span class="hljs-keyword">variable</span> (α β γ : <span class="hljs-built_in">Type</span>)
  <span class="hljs-keyword">variable</span> (g : β → γ) (f : α → β) (h : α → α)
  <span class="hljs-keyword">variable</span> (x : α)

  <span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">c</span><span class="hljs-title">o</span><span class="hljs-title">m</span><span class="hljs-title">p</span><span class="hljs-title">o</span><span class="hljs-title">s</span><span class="hljs-title">e</span> <span class="hljs-symbol">:</span></span>= g (f x)
  <span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span><span class="hljs-title">o</span><span class="hljs-title">Tw</span><span class="hljs-title">i</span><span class="hljs-title">c</span><span class="hljs-title">e</span> <span class="hljs-symbol">:</span></span>= h (h x)
  <span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span><span class="hljs-title">o</span><span class="hljs-title">T</span><span class="hljs-title">h</span><span class="hljs-title">r</span><span class="hljs-title">i</span><span class="hljs-title">c</span><span class="hljs-title">e</span> <span class="hljs-symbol">:</span></span>= h (h (h x))
<span class="hljs-keyword">end</span> useful
</code></pre>
<p>When the section is closed, the variables go out of scope, and become
nothing more than a distant memory.</p>
<p>You do not have to indent the lines within a section. Nor do you have
to name a section, which is to say, you can use an anonymous
<code class="hljs">section</code> / <code class="hljs">end</code> pair. If you do name a section, however, you
have to close it using the same name. Sections can also be nested,
which allows you to declare new variables incrementally.</p>
<h1><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/dependent_type_theory.html#a-name_namespacesanamespaces" id="a-name_namespacesanamespaces"></a><a name="_namespaces"></a>Namespaces</h1>
<p>Lean provides you with the ability to group definitions into nested,
hierarchical <em>namespaces</em>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">namespace</span> Foo
  <span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span> <span class="hljs-symbol">:</span></span> Nat := <span class="hljs-number">5</span>
  <span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span> <span class="hljs-params">(x : Nat)</span> <span class="hljs-symbol">:</span></span> Nat := x + <span class="hljs-number">7</span>

  <span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-title">a</span> <span class="hljs-symbol">:</span></span> Nat := f a
  <span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-title">f</span><span class="hljs-title">a</span> <span class="hljs-symbol">:</span></span> Nat := f (f a)

  <span class="hljs-keyword">#check</span> a
  <span class="hljs-keyword">#check</span> f
  <span class="hljs-keyword">#check</span> fa
  <span class="hljs-keyword">#check</span> ffa
  <span class="hljs-keyword">#check</span> Foo.fa
<span class="hljs-keyword">end</span> Foo

<span class="hljs-comment">-- #check a  -- error</span>
<span class="hljs-comment">-- #check f  -- error</span>
<span class="hljs-keyword">#check</span> Foo.a
<span class="hljs-keyword">#check</span> Foo.f
<span class="hljs-keyword">#check</span> Foo.fa
<span class="hljs-keyword">#check</span> Foo.ffa

<span class="hljs-keyword">open</span> Foo

<span class="hljs-keyword">#check</span> a
<span class="hljs-keyword">#check</span> f
<span class="hljs-keyword">#check</span> fa
<span class="hljs-keyword">#check</span> Foo.fa
</code></pre>
<p>When you declare that you are working in the namespace <code class="hljs">Foo</code>, every
identifier you declare has a full name with prefix "<code class="hljs">Foo.</code>". Within
the namespace, you can refer to identifiers by their shorter names,
but once you end the namespace, you have to use the longer names.
Unlike <code class="hljs">section</code>, namespaces require a name. There is only one
anonymous namespace at the root level.</p>
<p>The <code class="hljs">open</code> command brings the shorter names into the current
context. Often, when you import a module, you will want to open one or
more of the namespaces it contains, to have access to the short
identifiers. But sometimes you will want to leave this information
protected by a fully qualified name, for example, when they conflict
with identifiers in another namespace you want to use. Thus namespaces
give you a way to manage names in your working environment.</p>
<p>For example, Lean groups definitions and theorems involving lists into
a namespace <code class="hljs">List</code>.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> List.nil
<span class="hljs-keyword">#check</span> List.cons
<span class="hljs-keyword">#check</span> List.map
</code></pre>
<p>The command <code class="hljs">open List</code> allows you to use the shorter names:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">open</span> List

<span class="hljs-keyword">#check</span> nil
<span class="hljs-keyword">#check</span> cons
<span class="hljs-keyword">#check</span> map
</code></pre>
<p>Like sections, namespaces can be nested:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">namespace</span> Foo
  <span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span> <span class="hljs-symbol">:</span></span> Nat := <span class="hljs-number">5</span>
  <span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span> <span class="hljs-params">(x : Nat)</span> <span class="hljs-symbol">:</span></span> Nat := x + <span class="hljs-number">7</span>

  <span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-title">a</span> <span class="hljs-symbol">:</span></span> Nat := f a

  <span class="hljs-keyword">namespace</span> Bar
    <span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-title">f</span><span class="hljs-title">a</span> <span class="hljs-symbol">:</span></span> Nat := f (f a)

    <span class="hljs-keyword">#check</span> fa
    <span class="hljs-keyword">#check</span> ffa
  <span class="hljs-keyword">end</span> Bar

  <span class="hljs-keyword">#check</span> fa
  <span class="hljs-keyword">#check</span> Bar.ffa
<span class="hljs-keyword">end</span> Foo

<span class="hljs-keyword">#check</span> Foo.fa
<span class="hljs-keyword">#check</span> Foo.Bar.ffa

<span class="hljs-keyword">open</span> Foo

<span class="hljs-keyword">#check</span> fa
<span class="hljs-keyword">#check</span> Bar.ffa
</code></pre>
<p>Namespaces that have been closed can later be reopened, even in another file:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">namespace</span> Foo
  <span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span> <span class="hljs-symbol">:</span></span> Nat := <span class="hljs-number">5</span>
  <span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span> <span class="hljs-params">(x : Nat)</span> <span class="hljs-symbol">:</span></span> Nat := x + <span class="hljs-number">7</span>

  <span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-title">a</span> <span class="hljs-symbol">:</span></span> Nat := f a
<span class="hljs-keyword">end</span> Foo

<span class="hljs-keyword">#check</span> Foo.a
<span class="hljs-keyword">#check</span> Foo.f

<span class="hljs-keyword">namespace</span> Foo
  <span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-title">f</span><span class="hljs-title">a</span> <span class="hljs-symbol">:</span></span> Nat := f (f a)
<span class="hljs-keyword">end</span> Foo
</code></pre>
<p>Like sections, nested namespaces have to be closed in the order they
are opened. Namespaces and sections serve different purposes:
namespaces organize data and sections declare variables for insertion
in definitions. Sections are also useful for delimiting the scope of
commands such as <code class="hljs">set_option</code> and <code class="hljs">open</code>.</p>
<p>In many respects, however, a <code class="hljs">namespace ... end</code> block behaves the
same as a <code class="hljs">section ... end</code> block. In particular, if you use the
<code class="hljs">variable</code> command within a namespace, its scope is limited to the
namespace. Similarly, if you use an <code class="hljs">open</code> command within a
namespace, its effects disappear when the namespace is closed.</p>
<h2><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/dependent_type_theory.html#what-makes-dependent-type-theory-dependent" id="what-makes-dependent-type-theory-dependent">What makes dependent type theory dependent?</a></h2>
<p>The short explanation is that types can depend on parameters. You
have already seen a nice example of this: the type <code class="hljs">List α</code> depends
on the argument <code class="hljs">α</code>, and this dependence is what distinguishes
<code class="hljs">List Nat</code> and <code class="hljs">List Bool</code>. For another example, consider the
type <code class="hljs">Vector α n</code>, the type of vectors of elements of <code class="hljs">α</code> of
length <code class="hljs">n</code>.  This type depends on <em>two</em> parameters: the type of the
elements in the vector (<code class="hljs">α : Type</code>) and the length of the vector
<code class="hljs">n : Nat</code>.</p>
<p>Suppose you wish to write a function <code class="hljs">cons</code> which inserts a new
element at the head of a list. What type should <code class="hljs">cons</code> have? Such a
function is <em>polymorphic</em>: you expect the <code class="hljs">cons</code> function for
<code class="hljs">Nat</code>, <code class="hljs">Bool</code>, or an arbitrary type <code class="hljs">α</code> to behave the same way.
So it makes sense to take the type to be the first argument to
<code class="hljs">cons</code>, so that for any type, <code class="hljs">α</code>, <code class="hljs">cons α</code> is the insertion
function for lists of type <code class="hljs">α</code>. In other words, for every <code class="hljs">α</code>,
<code class="hljs">cons α</code> is the function that takes an element <code class="hljs">a : α</code> and a list
<code class="hljs">as : List α</code>, and returns a new list, so you have <code class="hljs">cons α a as : List α</code>.</p>
<p>It is clear that <code class="hljs">cons α</code> should have type <code class="hljs">α → List α → List α</code>.
But what type should <code class="hljs">cons</code> have?  A first guess might be
<code class="hljs">Type → α → list α → list α</code>, but, on reflection, this does not make
sense: the <code class="hljs">α</code> in this expression does not refer to anything,
whereas it should refer to the argument of type <code class="hljs">Type</code>.  In other
words, <em>assuming</em> <code class="hljs">α : Type</code> is the first argument to the function,
the type of the next two elements are <code class="hljs">α</code> and <code class="hljs">List α</code>. These
types vary depending on the first argument, <code class="hljs">α</code>.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">c</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">s</span> <span class="hljs-params">(α : <span class="hljs-built_in">Type</span>)</span> <span class="hljs-params">(a : α)</span> <span class="hljs-params">(as : List α)</span> <span class="hljs-symbol">:</span></span> List α :=
  List.cons a as

<span class="hljs-keyword">#check</span> cons Nat        <span class="hljs-comment">-- Nat → List Nat → List Nat</span>
<span class="hljs-keyword">#check</span> cons Bool       <span class="hljs-comment">-- Bool → List Bool → List Bool</span>
<span class="hljs-keyword">#check</span> cons            <span class="hljs-comment">-- (α : Type) → α → List α → List α</span>
</code></pre>
<p>This is an instance of a <em>dependent function type</em>, or <em>dependent
arrow type</em>. Given <code class="hljs">α : Type</code> and <code class="hljs">β : α → Type</code>, think of <code class="hljs">β</code>
as a family of types over <code class="hljs">α</code>, that is, a type <code class="hljs">β a</code> for each
<code class="hljs">a : α</code>. In that case, the type <code class="hljs">(a : α) → β a</code> denotes the type
of functions <code class="hljs">f</code> with the property that, for each <code class="hljs">a : α</code>, <code class="hljs">f a</code>
is an element of <code class="hljs">β a</code>. In other words, the type of the value
returned by <code class="hljs">f</code> depends on its input.</p>
<p>Notice that <code class="hljs">(a : α) → β</code> makes sense for any expression <code class="hljs">β : Type</code>. When the value of <code class="hljs">β</code> depends on <code class="hljs">a</code> (as does, for
example, the expression <code class="hljs">β a</code> in the previous paragraph),
<code class="hljs">(a : α) → β</code> denotes a dependent function type. When <code class="hljs">β</code> doesn't
depend on <code class="hljs">a</code>, <code class="hljs">(a : α) → β</code> is no different from the type
<code class="hljs">α → β</code>.  Indeed, in dependent type theory (and in Lean), <code class="hljs">α → β</code>
is just notation for <code class="hljs">(a : α) → β</code> when <code class="hljs">β</code> does not depend on <code class="hljs">a</code>.</p>
<p>Returning to the example of lists, you can use the command <code class="hljs">#check</code> to
inspect the type of the following <code class="hljs">List</code> functions.  The <code class="hljs">@</code> symbol
and the difference between the round and curly braces will be
explained momentarily.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> @List.cons    <span class="hljs-comment">-- {α : Type u_1} → α → List α → List α</span>
<span class="hljs-keyword">#check</span> @List.nil     <span class="hljs-comment">-- {α : Type u_1} → List α</span>
<span class="hljs-keyword">#check</span> @List.length  <span class="hljs-comment">-- {α : Type u_1} → List α → Nat</span>
<span class="hljs-keyword">#check</span> @List.append  <span class="hljs-comment">-- {α : Type u_1} → List α → List α → List α</span>
</code></pre>
<p>Just as dependent function types <code class="hljs">(a : α) → β a</code> generalize the
notion of a function type <code class="hljs">α → β</code> by allowing <code class="hljs">β</code> to depend on
<code class="hljs">α</code>, dependent Cartesian product types <code class="hljs">(a : α) × β a</code> generalize
the Cartesian product <code class="hljs">α × β</code> in the same way. Dependent products
are also called <em>sigma</em> types, and you can also write them as
<code class="hljs">Σ a : α, β a</code>. You can use <code class="hljs">⟨a, b⟩</code> or <code class="hljs">Sigma.mk a b</code> to create a
dependent pair.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">universe</span> u v

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span> <span class="hljs-params">(α : <span class="hljs-built_in">Type</span> u)</span> <span class="hljs-params">(β : α → <span class="hljs-built_in">Type</span> v)</span> <span class="hljs-params">(a : α)</span> <span class="hljs-params">(b : β a)</span> <span class="hljs-symbol">:</span></span> (a : α) × β a :=
  ⟨a, b⟩

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">g</span> <span class="hljs-params">(α : <span class="hljs-built_in">Type</span> u)</span> <span class="hljs-params">(β : α → <span class="hljs-built_in">Type</span> v)</span> <span class="hljs-params">(a : α)</span> <span class="hljs-params">(b : β a)</span> <span class="hljs-symbol">:</span></span> Σ a : α, β a :=
  Sigma.mk a b

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">h1</span> <span class="hljs-params">(x : Nat)</span> <span class="hljs-symbol">:</span></span> Nat :=
  (f <span class="hljs-built_in">Type</span> (<span class="hljs-keyword">fun</span> α =&gt; α) Nat x).<span class="hljs-number">2</span>

<span class="hljs-keyword">#eval</span> h1 <span class="hljs-number">5</span> <span class="hljs-comment">-- 5</span>

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">h2</span> <span class="hljs-params">(x : Nat)</span> <span class="hljs-symbol">:</span></span> Nat :=
  (g <span class="hljs-built_in">Type</span> (<span class="hljs-keyword">fun</span> α =&gt; α) Nat x).<span class="hljs-number">2</span>

<span class="hljs-keyword">#eval</span> h2 <span class="hljs-number">5</span> <span class="hljs-comment">-- 5</span>
</code></pre>
<p>The functions <code class="hljs">f</code> and <code class="hljs">g</code> above denote the same function.</p>
<h2><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/dependent_type_theory.html#a-name_implicit_argsaimplicit-arguments" id="a-name_implicit_argsaimplicit-arguments"></a><a name="_implicit_args"></a>Implicit Arguments</h2>
<p>Suppose we have an implementation of lists as:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="Show hidden lines" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="boring"><span class="hljs-keyword">universe</span> u
</span><span class="boring"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">L</span><span class="hljs-title">s</span><span class="hljs-title">t</span> <span class="hljs-params">(α : <span class="hljs-built_in">Type</span> u)</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Type</span> u := List α
</span><span class="boring"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">L</span><span class="hljs-title">s</span><span class="hljs-title">t</span>.<span class="hljs-title">c</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">s</span> <span class="hljs-params">(α : <span class="hljs-built_in">Type</span> u)</span> <span class="hljs-params">(a : α)</span> <span class="hljs-params">(as : Lst α)</span> <span class="hljs-symbol">:</span></span> Lst α := List.cons a as
</span><span class="boring"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">L</span><span class="hljs-title">s</span><span class="hljs-title">t</span>.<span class="hljs-title">n</span><span class="hljs-title">i</span><span class="hljs-title">l</span> <span class="hljs-params">(α : <span class="hljs-built_in">Type</span> u)</span> <span class="hljs-symbol">:</span></span> Lst α := List.nil
</span><span class="boring"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">L</span><span class="hljs-title">s</span><span class="hljs-title">t</span>.<span class="hljs-title">a</span><span class="hljs-title">p</span><span class="hljs-title">p</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">d</span> <span class="hljs-params">(α : <span class="hljs-built_in">Type</span> u)</span> <span class="hljs-params">(as bs : Lst α)</span> <span class="hljs-symbol">:</span></span> Lst α := List.append as bs
</span><span class="hljs-keyword">#check</span> Lst          <span class="hljs-comment">-- Type u_1 → Type u_1</span>
<span class="hljs-keyword">#check</span> Lst.cons     <span class="hljs-comment">-- (α : Type u_1) → α → Lst α → Lst α</span>
<span class="hljs-keyword">#check</span> Lst.nil      <span class="hljs-comment">-- (α : Type u_1) → Lst α</span>
<span class="hljs-keyword">#check</span> Lst.append   <span class="hljs-comment">-- (α : Type u_1) → Lst α → Lst α → Lst α</span>
</code></pre>
<p>Then, you can construct lists of <code class="hljs">Nat</code> as follows.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="Show hidden lines" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="boring"><span class="hljs-keyword">universe</span> u
</span><span class="boring"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">L</span><span class="hljs-title">s</span><span class="hljs-title">t</span> <span class="hljs-params">(α : <span class="hljs-built_in">Type</span> u)</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Type</span> u := List α
</span><span class="boring"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">L</span><span class="hljs-title">s</span><span class="hljs-title">t</span>.<span class="hljs-title">c</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">s</span> <span class="hljs-params">(α : <span class="hljs-built_in">Type</span> u)</span> <span class="hljs-params">(a : α)</span> <span class="hljs-params">(as : Lst α)</span> <span class="hljs-symbol">:</span></span> Lst α := List.cons a as
</span><span class="boring"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">L</span><span class="hljs-title">s</span><span class="hljs-title">t</span>.<span class="hljs-title">n</span><span class="hljs-title">i</span><span class="hljs-title">l</span> <span class="hljs-params">(α : <span class="hljs-built_in">Type</span> u)</span> <span class="hljs-symbol">:</span></span> Lst α := List.nil
</span><span class="boring"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">L</span><span class="hljs-title">s</span><span class="hljs-title">t</span>.<span class="hljs-title">a</span><span class="hljs-title">p</span><span class="hljs-title">p</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">d</span> <span class="hljs-params">(α : <span class="hljs-built_in">Type</span> u)</span> <span class="hljs-params">(as bs : Lst α)</span> <span class="hljs-symbol">:</span></span> Lst α := List.append as bs
</span><span class="boring"><span class="hljs-keyword">#check</span> Lst          <span class="hljs-comment">-- Type u_1 → Type u_1</span>
</span><span class="boring"><span class="hljs-keyword">#check</span> Lst.cons     <span class="hljs-comment">-- (α : Type u_1) → α → Lst α → Lst α</span>
</span><span class="boring"><span class="hljs-keyword">#check</span> Lst.nil      <span class="hljs-comment">-- (α : Type u_1) → Lst α</span>
</span><span class="boring"><span class="hljs-keyword">#check</span> Lst.append   <span class="hljs-comment">-- (α : Type u_1) → Lst α → Lst α → Lst α</span>
</span><span class="hljs-keyword">#check</span> Lst.cons Nat <span class="hljs-number">0</span> (Lst.nil Nat)

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span><span class="hljs-title">s</span> <span class="hljs-symbol">:</span></span> Lst Nat := Lst.nil Nat
<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">b</span><span class="hljs-title">s</span> <span class="hljs-symbol">:</span></span> Lst Nat := Lst.cons Nat <span class="hljs-number">5</span> (Lst.nil Nat)

<span class="hljs-keyword">#check</span> Lst.append Nat as bs
</code></pre>
<p>Because the constructors are polymorphic over types, we have to insert
the type <code class="hljs">Nat</code> as an argument repeatedly. But this information is
redundant: one can infer the argument <code class="hljs">α</code> in
<code class="hljs">Lst.cons Nat 5 (Lst.nil Nat)</code> from the fact that the second argument, <code class="hljs">5</code>, has
type <code class="hljs">Nat</code>. One can similarly infer the argument in <code class="hljs">Lst.nil Nat</code>, not
from anything else in that expression, but from the fact that it is
sent as an argument to the function <code class="hljs">Lst.cons</code>, which expects an element
of type <code class="hljs">Lst α</code> in that position.</p>
<p>This is a central feature of dependent type theory: terms carry a lot
of information, and often some of that information can be inferred
from the context. In Lean, one uses an underscore, <code class="hljs">_</code>, to specify
that the system should fill in the information automatically. This is
known as an "implicit argument."</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="Show hidden lines" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="boring"><span class="hljs-keyword">universe</span> u
</span><span class="boring"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">L</span><span class="hljs-title">s</span><span class="hljs-title">t</span> <span class="hljs-params">(α : <span class="hljs-built_in">Type</span> u)</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Type</span> u := List α
</span><span class="boring"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">L</span><span class="hljs-title">s</span><span class="hljs-title">t</span>.<span class="hljs-title">c</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">s</span> <span class="hljs-params">(α : <span class="hljs-built_in">Type</span> u)</span> <span class="hljs-params">(a : α)</span> <span class="hljs-params">(as : Lst α)</span> <span class="hljs-symbol">:</span></span> Lst α := List.cons a as
</span><span class="boring"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">L</span><span class="hljs-title">s</span><span class="hljs-title">t</span>.<span class="hljs-title">n</span><span class="hljs-title">i</span><span class="hljs-title">l</span> <span class="hljs-params">(α : <span class="hljs-built_in">Type</span> u)</span> <span class="hljs-symbol">:</span></span> Lst α := List.nil
</span><span class="boring"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">L</span><span class="hljs-title">s</span><span class="hljs-title">t</span>.<span class="hljs-title">a</span><span class="hljs-title">p</span><span class="hljs-title">p</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">d</span> <span class="hljs-params">(α : <span class="hljs-built_in">Type</span> u)</span> <span class="hljs-params">(as bs : Lst α)</span> <span class="hljs-symbol">:</span></span> Lst α := List.append as bs
</span><span class="boring"><span class="hljs-keyword">#check</span> Lst          <span class="hljs-comment">-- Type u_1 → Type u_1</span>
</span><span class="boring"><span class="hljs-keyword">#check</span> Lst.cons     <span class="hljs-comment">-- (α : Type u_1) → α → Lst α → Lst α</span>
</span><span class="boring"><span class="hljs-keyword">#check</span> Lst.nil      <span class="hljs-comment">-- (α : Type u_1) → Lst α</span>
</span><span class="boring"><span class="hljs-keyword">#check</span> Lst.append   <span class="hljs-comment">-- (α : Type u_1) → Lst α → Lst α → Lst α</span>
</span><span class="hljs-keyword">#check</span> Lst.cons _ <span class="hljs-number">0</span> (Lst.nil _)

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span><span class="hljs-title">s</span> <span class="hljs-symbol">:</span></span> Lst Nat := Lst.nil _
<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">b</span><span class="hljs-title">s</span> <span class="hljs-symbol">:</span></span> Lst Nat := Lst.cons _ <span class="hljs-number">5</span> (Lst.nil _)

<span class="hljs-keyword">#check</span> Lst.append _ as bs
</code></pre>
<p>It is still tedious, however, to type all these underscores. When a
function takes an argument that can generally be inferred from
context, Lean allows you to specify that this argument should, by
default, be left implicit. This is done by putting the arguments in
curly braces, as follows:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">universe</span> u
<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">L</span><span class="hljs-title">s</span><span class="hljs-title">t</span> <span class="hljs-params">(α : <span class="hljs-built_in">Type</span> u)</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Type</span> u := List α

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">L</span><span class="hljs-title">s</span><span class="hljs-title">t</span>.<span class="hljs-title">c</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">s</span> <span class="hljs-params">{α : <span class="hljs-built_in">Type</span> u}</span> <span class="hljs-params">(a : α)</span> <span class="hljs-params">(as : Lst α)</span> <span class="hljs-symbol">:</span></span> Lst α := List.cons a as
<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">L</span><span class="hljs-title">s</span><span class="hljs-title">t</span>.<span class="hljs-title">n</span><span class="hljs-title">i</span><span class="hljs-title">l</span> <span class="hljs-params">{α : <span class="hljs-built_in">Type</span> u}</span> <span class="hljs-symbol">:</span></span> Lst α := List.nil
<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">L</span><span class="hljs-title">s</span><span class="hljs-title">t</span>.<span class="hljs-title">a</span><span class="hljs-title">p</span><span class="hljs-title">p</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">d</span> <span class="hljs-params">{α : <span class="hljs-built_in">Type</span> u}</span> <span class="hljs-params">(as bs : Lst α)</span> <span class="hljs-symbol">:</span></span> Lst α := List.append as bs

<span class="hljs-keyword">#check</span> Lst.cons <span class="hljs-number">0</span> Lst.nil

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span><span class="hljs-title">s</span> <span class="hljs-symbol">:</span></span> Lst Nat := Lst.nil
<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">b</span><span class="hljs-title">s</span> <span class="hljs-symbol">:</span></span> Lst Nat := Lst.cons <span class="hljs-number">5</span> Lst.nil

<span class="hljs-keyword">#check</span> Lst.append as bs
</code></pre>
<p>All that has changed are the braces around <code class="hljs">α : Type u</code> in the
declaration of the variables. We can also use this device in function
definitions:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">universe</span> u
<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">i</span><span class="hljs-title">d</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">t</span> <span class="hljs-params">{α : <span class="hljs-built_in">Type</span> u}</span> <span class="hljs-params">(x : α)</span> <span class="hljs-symbol">:</span></span>= x

<span class="hljs-keyword">#check</span> ident         <span class="hljs-comment">-- ?m → ?m</span>
<span class="hljs-keyword">#check</span> ident <span class="hljs-number">1</span>       <span class="hljs-comment">-- Nat</span>
<span class="hljs-keyword">#check</span> ident <span class="hljs-string">"hello"</span> <span class="hljs-comment">-- String</span>
<span class="hljs-keyword">#check</span> @ident        <span class="hljs-comment">-- {α : Type u_1} → α → α</span>
</code></pre>
<p>This makes the first argument to <code class="hljs">ident</code> implicit. Notationally,
this hides the specification of the type, making it look as though
<code class="hljs">ident</code> simply takes an argument of any type. In fact, the function
<code class="hljs">id</code> is defined in the standard library in exactly this way. We have
chosen a nontraditional name here only to avoid a clash of names.</p>
<p>Variables can also be specified as implicit when they are declared with
the <code class="hljs">variable</code> command:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">universe</span> u

<span class="hljs-keyword">section</span>
  <span class="hljs-keyword">variable</span> {α : <span class="hljs-built_in">Type</span> u}
  <span class="hljs-keyword">variable</span> (x : α)
  <span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">i</span><span class="hljs-title">d</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">t</span> <span class="hljs-symbol">:</span></span>= x
<span class="hljs-keyword">end</span>

<span class="hljs-keyword">#check</span> ident
<span class="hljs-keyword">#check</span> ident <span class="hljs-number">4</span>
<span class="hljs-keyword">#check</span> ident <span class="hljs-string">"hello"</span>
</code></pre>
<p>This definition of <code class="hljs">ident</code> here has the same effect as the one
above.</p>
<p>Lean has very complex mechanisms for instantiating implicit arguments,
and we will see that they can be used to infer function types,
predicates, and even proofs. The process of instantiating these
"holes," or "placeholders," in a term is often known as
<em>elaboration</em>. The presence of implicit arguments means that at times
there may be insufficient information to fix the meaning of an
expression precisely. An expression like <code class="hljs">id</code> or <code class="hljs">List.nil</code> is
said to be <em>polymorphic</em>, because it can take on different meanings in
different contexts.</p>
<p>One can always specify the type <code class="hljs">T</code> of an expression <code class="hljs">e</code> by
writing <code class="hljs">(e : T)</code>. This instructs Lean's elaborator to use the value
<code class="hljs">T</code> as the type of <code class="hljs">e</code> when trying to resolve implicit
arguments. In the second pair of examples below, this mechanism is
used to specify the desired types of the expressions <code class="hljs">id</code> and
<code class="hljs">List.nil</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> List.nil               <span class="hljs-comment">-- List ?m</span>
<span class="hljs-keyword">#check</span> id                     <span class="hljs-comment">-- ?m → ?m</span>

<span class="hljs-keyword">#check</span> (List.nil : List Nat)  <span class="hljs-comment">-- List Nat</span>
<span class="hljs-keyword">#check</span> (id : Nat → Nat)       <span class="hljs-comment">-- Nat → Nat</span>
</code></pre>
<p>Numerals are overloaded in Lean, but when the type of a numeral cannot
be inferred, Lean assumes, by default, that it is a natural number. So
the expressions in the first two <code class="hljs">#check</code> commands below are
elaborated in the same way, whereas the third <code class="hljs">#check</code> command
interprets <code class="hljs">2</code> as an integer.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> <span class="hljs-number">2</span>            <span class="hljs-comment">-- Nat</span>
<span class="hljs-keyword">#check</span> (<span class="hljs-number">2</span> : Nat)    <span class="hljs-comment">-- Nat</span>
<span class="hljs-keyword">#check</span> (<span class="hljs-number">2</span> : Int)    <span class="hljs-comment">-- Int</span>
</code></pre>
<p>Sometimes, however, we may find ourselves in a situation where we have
declared an argument to a function to be implicit, but now want to
provide the argument explicitly. If <code class="hljs">foo</code> is such a function, the
notation <code class="hljs">@foo</code> denotes the same function with all the arguments
made explicit.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> @id        <span class="hljs-comment">-- {α : Type u_1} → α → α</span>
<span class="hljs-keyword">#check</span> @id Nat    <span class="hljs-comment">-- Nat → Nat</span>
<span class="hljs-keyword">#check</span> @id Bool   <span class="hljs-comment">-- Bool → Bool</span>

<span class="hljs-keyword">#check</span> @id Nat <span class="hljs-number">1</span>     <span class="hljs-comment">-- Nat</span>
<span class="hljs-keyword">#check</span> @id Bool <span class="hljs-literal">true</span> <span class="hljs-comment">-- Bool</span>
</code></pre>
<p>Notice that now the first <code class="hljs">#check</code> command gives the type of the
identifier, <code class="hljs">id</code>, without inserting any placeholders. Moreover, the
output indicates that the first argument is implicit.</p><!-- Mobile navigation buttons -->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        
                        
                            <a rel="prev" href="https://leanprover.github.io/theorem_proving_in_lean4/introduction.html" class="mobile-nav-chapters previous" title="이전 장" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="https://leanprover.github.io/theorem_proving_in_lean4/propositions_and_proofs.html" class="mobile-nav-chapters next" title="다음 장" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="https://leanprover.github.io/theorem_proving_in_lean4/introduction.html" class="nav-chapters previous" title="이전 장" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="https://leanprover.github.io/theorem_proving_in_lean4/propositions_and_proofs.html" class="nav-chapters next" title="다음 장" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="./Dependent Type Theory - Theorem Proving in Lean 4_files/elasticlunr.min.js.다운로드" type="text/javascript" charset="utf-8"></script>
        <script src="./Dependent Type Theory - Theorem Proving in Lean 4_files/mark.min.js.다운로드" type="text/javascript" charset="utf-8"></script>
        <script src="./Dependent Type Theory - Theorem Proving in Lean 4_files/searcher.js.다운로드" type="text/javascript" charset="utf-8"></script>
        

        <script src="./Dependent Type Theory - Theorem Proving in Lean 4_files/clipboard.min.js.다운로드" type="text/javascript" charset="utf-8"></script>
        <script src="./Dependent Type Theory - Theorem Proving in Lean 4_files/highlight.js.다운로드" type="text/javascript" charset="utf-8"></script>
        <script src="./Dependent Type Theory - Theorem Proving in Lean 4_files/book.js.다운로드" type="text/javascript" charset="utf-8"></script><!-- Custom JS scripts -->

        
        

        

    

</body></html>