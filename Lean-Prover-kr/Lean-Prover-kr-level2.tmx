<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tmx SYSTEM "tmx14.dtd">
<tmx version="1.4">
  <header creationtool="OmegaT" o-tmf="OmegaT TMX" adminlang="EN-US" datatype="plaintext" creationtoolversion="OmegaT-4.3.2" segtype="sentence" srclang="en-US"/>
  <body>
<!-- Default translations -->
    <tu>
      <tuv xml:lang="en-US">
        <seg>"Type theory" gets its name from the fact that every expression has an associated <bpt i="0" x="0">&lt;e0&gt;</bpt>type<ept i="0">&lt;/e0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T034602Z" creationid="tlqk3" creationdate="20220131T034602Z">
        <seg>'유형론'은 그것의 이름을 모든 표현은 연관된 <bpt i="0" x="0">&lt;e0&gt;</bpt>유형<ept i="0">&lt;/e0&gt;</ept>을 가지고 있다는 사실로부터 갖게 되었습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>(Making sense of the type of this function requires an understanding of dependent products, which will be explained below.)</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T054823Z" creationid="tlqk3" creationdate="20220131T054823Z">
        <seg>(이 함수의 유형들을 이해하는 것은 아래에서 설명할 의존 곱에 대한 이해가 필요합니다.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>(Shortkey: s)</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T073643Z" creationid="tlqk35" creationdate="20220130T073643Z">
        <seg>(단축기: s)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>(The symbol <bpt i="9" x="9">&lt;c9&gt;</bpt>¬<ept i="9">&lt;/c9&gt;</ept> is produced by typing <bpt i="10" x="10">&lt;c10&gt;</bpt>\not<ept i="10">&lt;/c10&gt;</ept> or <bpt i="11" x="11">&lt;c11&gt;</bpt>\neg<ept i="11">&lt;/c11&gt;</ept>.)</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T172953Z" creationid="tlqk3" creationdate="20220211T172953Z">
        <seg>(기호 <bpt i="9" x="9">&lt;c9&gt;</bpt>¬<ept i="9">&lt;/c9&gt;</ept>은 <bpt i="10" x="10">&lt;c10&gt;</bpt>\not<ept i="10">&lt;/c10&gt;</ept>이나  <bpt i="11" x="11">&lt;c11&gt;</bpt>\neg<ept i="11">&lt;/c11&gt;</ept>을 치는 것으로 만들어집니다.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>-/<it pos="end" x="0">&lt;/s0&gt;</it>

<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>def<ept i="2">&lt;/s2&gt;</ept> <bpt i="3" x="3">&lt;s3&gt;</bpt>m<ept i="3">&lt;/s3&gt;</ept> <bpt i="4" x="4">&lt;s4&gt;</bpt>:<ept i="4">&lt;/s4&gt;</ept><ept i="1">&lt;/s1&gt;</ept> Nat := <bpt i="5" x="5">&lt;s5&gt;</bpt>1<ept i="5">&lt;/s5&gt;</ept>       <bpt i="6" x="6">&lt;s6&gt;</bpt>-- m is a natural number<ept i="6">&lt;/s6&gt;</ept>
<bpt i="7" x="7">&lt;s7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>def<ept i="8">&lt;/s8&gt;</ept> <bpt i="9" x="9">&lt;s9&gt;</bpt>n<ept i="9">&lt;/s9&gt;</ept> <bpt i="10" x="10">&lt;s10&gt;</bpt>:<ept i="10">&lt;/s10&gt;</ept><ept i="7">&lt;/s7&gt;</ept> Nat := <bpt i="11" x="11">&lt;s11&gt;</bpt>0<ept i="11">&lt;/s11&gt;</ept>
<bpt i="12" x="12">&lt;s12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>def<ept i="13">&lt;/s13&gt;</ept> <bpt i="14" x="14">&lt;s14&gt;</bpt>b1<ept i="14">&lt;/s14&gt;</ept> <bpt i="15" x="15">&lt;s15&gt;</bpt>:<ept i="15">&lt;/s15&gt;</ept><ept i="12">&lt;/s12&gt;</ept> Bool := <bpt i="16" x="16">&lt;s16&gt;</bpt>true<ept i="16">&lt;/s16&gt;</ept>  <bpt i="17" x="17">&lt;s17&gt;</bpt>-- b1 is a Boolean<ept i="17">&lt;/s17&gt;</ept>
<bpt i="18" x="18">&lt;s18&gt;</bpt><bpt i="19" x="19">&lt;s19&gt;</bpt>def<ept i="19">&lt;/s19&gt;</ept> <bpt i="20" x="20">&lt;s20&gt;</bpt>b2<ept i="20">&lt;/s20&gt;</ept> <bpt i="21" x="21">&lt;s21&gt;</bpt>:<ept i="21">&lt;/s21&gt;</ept><ept i="18">&lt;/s18&gt;</ept> Bool := <bpt i="22" x="22">&lt;s22&gt;</bpt>false<ept i="22">&lt;/s22&gt;</ept>

<it pos="begin" x="23">&lt;s23&gt;</it>/- Check their types.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T034948Z" creationid="tlqk3" creationdate="20220131T034948Z">
        <seg>-/<it pos="end" x="0">&lt;/s0&gt;</it>

<bpt i="1" x="1">&lt;s1&gt;</bpt><bpt i="2" x="2">&lt;s2&gt;</bpt>def<ept i="2">&lt;/s2&gt;</ept> <bpt i="3" x="3">&lt;s3&gt;</bpt>m<ept i="3">&lt;/s3&gt;</ept> <bpt i="4" x="4">&lt;s4&gt;</bpt>:<ept i="4">&lt;/s4&gt;</ept><ept i="1">&lt;/s1&gt;</ept> Nat := <bpt i="5" x="5">&lt;s5&gt;</bpt>1<ept i="5">&lt;/s5&gt;</ept>       <bpt i="6" x="6">&lt;s6&gt;</bpt>-- m is a natural number<ept i="6">&lt;/s6&gt;</ept>
<bpt i="7" x="7">&lt;s7&gt;</bpt><bpt i="8" x="8">&lt;s8&gt;</bpt>def<ept i="8">&lt;/s8&gt;</ept> <bpt i="9" x="9">&lt;s9&gt;</bpt>n<ept i="9">&lt;/s9&gt;</ept> <bpt i="10" x="10">&lt;s10&gt;</bpt>:<ept i="10">&lt;/s10&gt;</ept><ept i="7">&lt;/s7&gt;</ept> Nat := <bpt i="11" x="11">&lt;s11&gt;</bpt>0<ept i="11">&lt;/s11&gt;</ept>
<bpt i="12" x="12">&lt;s12&gt;</bpt><bpt i="13" x="13">&lt;s13&gt;</bpt>def<ept i="13">&lt;/s13&gt;</ept> <bpt i="14" x="14">&lt;s14&gt;</bpt>b1<ept i="14">&lt;/s14&gt;</ept> <bpt i="15" x="15">&lt;s15&gt;</bpt>:<ept i="15">&lt;/s15&gt;</ept><ept i="12">&lt;/s12&gt;</ept> Bool := <bpt i="16" x="16">&lt;s16&gt;</bpt>true<ept i="16">&lt;/s16&gt;</ept>  <bpt i="17" x="17">&lt;s17&gt;</bpt>-- b1 is a Boolean<ept i="17">&lt;/s17&gt;</ept>
<bpt i="18" x="18">&lt;s18&gt;</bpt><bpt i="19" x="19">&lt;s19&gt;</bpt>def<ept i="19">&lt;/s19&gt;</ept> <bpt i="20" x="20">&lt;s20&gt;</bpt>b2<ept i="20">&lt;/s20&gt;</ept> <bpt i="21" x="21">&lt;s21&gt;</bpt>:<ept i="21">&lt;/s21&gt;</ept><ept i="18">&lt;/s18&gt;</ept> Bool := <bpt i="22" x="22">&lt;s22&gt;</bpt>false<ept i="22">&lt;/s22&gt;</ept>

<it pos="begin" x="23">&lt;s23&gt;</it>/- 그들의 유형을 확인합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>compose<ept i="0">&lt;/c0&gt;</ept> also takes a 3rd argument of type <bpt i="1" x="1">&lt;c1&gt;</bpt>α<ept i="1">&lt;/c1&gt;</ept> which it uses to invoke the second function (locally named <bpt i="2" x="2">&lt;c2&gt;</bpt>f<ept i="2">&lt;/c2&gt;</ept>) and it passes the result of that function (which is type <bpt i="3" x="3">&lt;c3&gt;</bpt>β<ept i="3">&lt;/c3&gt;</ept>) as input to the first function (locally named <bpt i="4" x="4">&lt;c4&gt;</bpt>g<ept i="4">&lt;/c4&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T065455Z" creationid="tlqk3" creationdate="20220131T065455Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>compose<ept i="0">&lt;/c0&gt;</ept>는 이는 두 번째 함수(지역적으로 <bpt i="2" x="2">&lt;c2&gt;</bpt>f<ept i="2">&lt;/c2&gt;</ept>라 하는)을 호출하는데 사용되기도 하는 유형 <bpt i="1" x="1">&lt;c1&gt;</bpt>α<ept i="1">&lt;/c1&gt;</ept> 를 세 번째 인수로 받습니다. 그리고 두 번째 합수는 그 함수의 결과(유형 <bpt i="3" x="3">&lt;c3&gt;</bpt>β<ept i="3">&lt;/c3&gt;</ept>의)를 첫 번째 함수(지역적으로 <bpt i="4" x="4">&lt;c4&gt;</bpt>g<ept i="4">&lt;/c4&gt;</ept>라 하는)의 입력으로 전달합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>compose<ept i="0">&lt;/c0&gt;</ept> is also very general in that it works over any type <bpt i="1" x="1">&lt;c1&gt;</bpt>α β γ<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T065610Z" creationid="tlqk3" creationdate="20220131T065610Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>compose<ept i="0">&lt;/c0&gt;</ept>는 또 아주 일반적이어서 임의의 유형 <bpt i="1" x="1">&lt;c1&gt;</bpt>α β γ<ept i="1">&lt;/c1&gt;</ept>에 대해서도 작동합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>def<ept i="0">&lt;/c0&gt;</ept> can take multiple input parameters.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T064913Z" creationid="tlqk3" creationdate="20220131T064913Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>def<ept i="0">&lt;/c0&gt;</ept>는 다수의 입력 매개변수를 받을 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>Type 1<ept i="1">&lt;/c1&gt;</ept> is then a larger universe of types, which contains <bpt i="2" x="2">&lt;c2&gt;</bpt>Type 0<ept i="2">&lt;/c2&gt;</ept> as an element, and <bpt i="3" x="3">&lt;c3&gt;</bpt>Type 2<ept i="3">&lt;/c3&gt;</ept> is an even larger universe of types, which contains <bpt i="4" x="4">&lt;c4&gt;</bpt>Type 1<ept i="4">&lt;/c4&gt;</ept> as an element.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T050342Z" creationid="tlqk3" creationdate="20220131T050342Z">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>Type 1<ept i="1">&lt;/c1&gt;</ept>는  <bpt i="2" x="2">&lt;c2&gt;</bpt>Type 0<ept i="2">&lt;/c2&gt;</ept>를 원소로 갖는 유형들의 더 큰 세계이고 <bpt i="3" x="3">&lt;c3&gt;</bpt>Type 2<ept i="3">&lt;/c3&gt;</ept>는 <bpt i="4" x="4">&lt;c4&gt;</bpt>Type 1<ept i="4">&lt;/c4&gt;</ept>을 원소로 하는 유형들의 더욱 큰 세계입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="6" x="6">&lt;c6&gt;</bpt>Prop<ept i="6">&lt;/c6&gt;</ept> has some special features, but like the other type universes, it is closed under the arrow constructor: if we have <bpt i="7" x="7">&lt;c7&gt;</bpt>p q : Prop<ept i="7">&lt;/c7&gt;</ept>, then <bpt i="8" x="8">&lt;c8&gt;</bpt>p → q : Prop<ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T141518Z" creationid="tlqk3" creationdate="20220211T140555Z">
        <seg><bpt i="6" x="6">&lt;c6&gt;</bpt>Prop<ept i="6">&lt;/c6&gt;</ept>은 특별한 특징이 있습니다. 하지만 다른 유형 세계처럼, 화살표 생성자로 달성됩니다. 우리가 <bpt i="7" x="7">&lt;c7&gt;</bpt>p q : Prop<ept i="7">&lt;/c7&gt;</ept>갖는다면  <bpt i="8" x="8">&lt;c8&gt;</bpt>p → q : Prop<ept i="8">&lt;/c8&gt;</ept>입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="7" x="7">&lt;c7&gt;</bpt>Type<ept i="7">&lt;/c7&gt;</ept> is an abbreviation for <bpt i="8" x="8">&lt;c8&gt;</bpt>Type 0<ept i="8">&lt;/c8&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T050535Z" creationid="tlqk3" creationdate="20220131T050535Z">
        <seg><bpt i="7" x="7">&lt;c7&gt;</bpt>Type<ept i="7">&lt;/c7&gt;</ept>는 <bpt i="8" x="8">&lt;c8&gt;</bpt>Type 0<ept i="8">&lt;/c8&gt;</ept>에 대한 약식 표현입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>Automated theorem proving<ept i="0">&lt;/e0&gt;</ept> focuses on the "finding" aspect.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T101733Z" creationid="tlqk35" creationdate="20220130T085537Z">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>자동화된 정리 증명<ept i="0">&lt;/e0&gt;</ept>은 '찾기'에 초점을 둡니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>Formal verification<ept i="0">&lt;/e0&gt;</ept> involves the use of logical and computational methods to establish claims that are expressed in precise mathematical terms.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T084315Z" creationid="tlqk35" creationdate="20220130T084315Z">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>형식 증명<ept i="0">&lt;/e0&gt;</ept>은 정밀한 수학적 항들로 표현된 주장을 세우는데 논리적이고 계산과학적 방법의 사용을 수반합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt>#check<ept i="0">&lt;/s0&gt;</ept> <bpt i="1" x="1">&lt;s1&gt;</bpt>fun<ept i="1">&lt;/s1&gt;</ept> (x : Nat) =&gt; x + <bpt i="2" x="2">&lt;s2&gt;</bpt>5<ept i="2">&lt;/s2&gt;</ept>   <bpt i="3" x="3">&lt;s3&gt;</bpt>-- Nat → Nat<ept i="3">&lt;/s3&gt;</ept>
<bpt i="4" x="4">&lt;s4&gt;</bpt>#check<ept i="4">&lt;/s4&gt;</ept> λ (x : Nat) =&gt; x + <bpt i="5" x="5">&lt;s5&gt;</bpt>5<ept i="5">&lt;/s5&gt;</ept>     <bpt i="6" x="6">&lt;s6&gt;</bpt>-- λ and fun mean the same thing<ept i="6">&lt;/s6&gt;</ept>
<bpt i="7" x="7">&lt;s7&gt;</bpt>#check<ept i="7">&lt;/s7&gt;</ept> <bpt i="8" x="8">&lt;s8&gt;</bpt>fun<ept i="8">&lt;/s8&gt;</ept> x : Nat =&gt; x + <bpt i="9" x="9">&lt;s9&gt;</bpt>5<ept i="9">&lt;/s9&gt;</ept>     <bpt i="10" x="10">&lt;s10&gt;</bpt>-- Nat inferred<ept i="10">&lt;/s10&gt;</ept>
<bpt i="11" x="11">&lt;s11&gt;</bpt>#check<ept i="11">&lt;/s11&gt;</ept> λ x : Nat =&gt; x + <bpt i="12" x="12">&lt;s12&gt;</bpt>5<ept i="12">&lt;/s12&gt;</ept>       <bpt i="13" x="13">&lt;s13&gt;</bpt>-- Nat inferred<ept i="13">&lt;/s13&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T052424Z" creationid="tlqk3" creationdate="20220131T052424Z">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt>#check<ept i="0">&lt;/s0&gt;</ept> <bpt i="1" x="1">&lt;s1&gt;</bpt>fun<ept i="1">&lt;/s1&gt;</ept> (x : Nat) =&gt; x + <bpt i="2" x="2">&lt;s2&gt;</bpt>5<ept i="2">&lt;/s2&gt;</ept>   <bpt i="3" x="3">&lt;s3&gt;</bpt>-- Nat → Nat<ept i="3">&lt;/s3&gt;</ept>
<bpt i="4" x="4">&lt;s4&gt;</bpt>#check<ept i="4">&lt;/s4&gt;</ept> λ (x : Nat) =&gt; x + <bpt i="5" x="5">&lt;s5&gt;</bpt>5<ept i="5">&lt;/s5&gt;</ept>     <bpt i="6" x="6">&lt;s6&gt;</bpt>-- λ 와 fun 같은 의미를 가집니다.<ept i="6">&lt;/s6&gt;</ept>
<bpt i="7" x="7">&lt;s7&gt;</bpt>#check<ept i="7">&lt;/s7&gt;</ept> <bpt i="8" x="8">&lt;s8&gt;</bpt>fun<ept i="8">&lt;/s8&gt;</ept> x : Nat =&gt; x + <bpt i="9" x="9">&lt;s9&gt;</bpt>5<ept i="9">&lt;/s9&gt;</ept>     <bpt i="10" x="10">&lt;s10&gt;</bpt>-- Nat으로 추론됩니다.<ept i="10">&lt;/s10&gt;</ept>
<bpt i="11" x="11">&lt;s11&gt;</bpt>#check<ept i="11">&lt;/s11&gt;</ept> λ x : Nat =&gt; x + <bpt i="12" x="12">&lt;s12&gt;</bpt>5<ept i="12">&lt;/s12&gt;</ept>       <bpt i="13" x="13">&lt;s13&gt;</bpt>-- Nat으로 추론됩니다.<ept i="13">&lt;/s13&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt>#check<ept i="0">&lt;/s0&gt;</ept> Nat → Nat      <bpt i="1" x="1">&lt;s1&gt;</bpt>-- type the arrow as "\to" or "\r"<ept i="1">&lt;/s1&gt;</ept>
<bpt i="2" x="2">&lt;s2&gt;</bpt>#check<ept i="2">&lt;/s2&gt;</ept> Nat -&gt; Nat     <bpt i="3" x="3">&lt;s3&gt;</bpt>-- alternative ASCII notation<ept i="3">&lt;/s3&gt;</ept>

<bpt i="4" x="4">&lt;s4&gt;</bpt>#check<ept i="4">&lt;/s4&gt;</ept> Nat × Nat      <bpt i="5" x="5">&lt;s5&gt;</bpt>-- type the product as "\times"<ept i="5">&lt;/s5&gt;</ept>
<bpt i="6" x="6">&lt;s6&gt;</bpt>#check<ept i="6">&lt;/s6&gt;</ept> Prod Nat Nat   <bpt i="7" x="7">&lt;s7&gt;</bpt>-- alternative notation<ept i="7">&lt;/s7&gt;</ept>

<bpt i="8" x="8">&lt;s8&gt;</bpt>#check<ept i="8">&lt;/s8&gt;</ept> Nat → Nat → Nat
<bpt i="9" x="9">&lt;s9&gt;</bpt>#check<ept i="9">&lt;/s9&gt;</ept> Nat → (Nat → Nat)  <bpt i="10" x="10">&lt;s10&gt;</bpt>--  same type as above<ept i="10">&lt;/s10&gt;</ept>

<bpt i="11" x="11">&lt;s11&gt;</bpt>#check<ept i="11">&lt;/s11&gt;</ept> Nat × Nat → Nat
<bpt i="12" x="12">&lt;s12&gt;</bpt>#check<ept i="12">&lt;/s12&gt;</ept> (Nat → Nat) → Nat <bpt i="13" x="13">&lt;s13&gt;</bpt>-- a "functional"<ept i="13">&lt;/s13&gt;</ept>

<bpt i="14" x="14">&lt;s14&gt;</bpt>#check<ept i="14">&lt;/s14&gt;</ept> Nat.succ     <bpt i="15" x="15">&lt;s15&gt;</bpt>-- Nat → Nat<ept i="15">&lt;/s15&gt;</ept>
<bpt i="16" x="16">&lt;s16&gt;</bpt>#check<ept i="16">&lt;/s16&gt;</ept> (<bpt i="17" x="17">&lt;s17&gt;</bpt>0<ept i="17">&lt;/s17&gt;</ept>, <bpt i="18" x="18">&lt;s18&gt;</bpt>1<ept i="18">&lt;/s18&gt;</ept>)       <bpt i="19" x="19">&lt;s19&gt;</bpt>-- Nat × Nat<ept i="19">&lt;/s19&gt;</ept>
<bpt i="20" x="20">&lt;s20&gt;</bpt>#check<ept i="20">&lt;/s20&gt;</ept> Nat.add      <bpt i="21" x="21">&lt;s21&gt;</bpt>-- Nat → Nat → Nat<ept i="21">&lt;/s21&gt;</ept>

<bpt i="22" x="22">&lt;s22&gt;</bpt>#check<ept i="22">&lt;/s22&gt;</ept> Nat.succ <bpt i="23" x="23">&lt;s23&gt;</bpt>2<ept i="23">&lt;/s23&gt;</ept>   <bpt i="24" x="24">&lt;s24&gt;</bpt>-- Nat<ept i="24">&lt;/s24&gt;</ept>
<bpt i="25" x="25">&lt;s25&gt;</bpt>#check<ept i="25">&lt;/s25&gt;</ept> Nat.add <bpt i="26" x="26">&lt;s26&gt;</bpt>3<ept i="26">&lt;/s26&gt;</ept>    <bpt i="27" x="27">&lt;s27&gt;</bpt>-- Nat → Nat<ept i="27">&lt;/s27&gt;</ept>
<bpt i="28" x="28">&lt;s28&gt;</bpt>#check<ept i="28">&lt;/s28&gt;</ept> Nat.add <bpt i="29" x="29">&lt;s29&gt;</bpt>5<ept i="29">&lt;/s29&gt;</ept> <bpt i="30" x="30">&lt;s30&gt;</bpt>2<ept i="30">&lt;/s30&gt;</ept>  <bpt i="31" x="31">&lt;s31&gt;</bpt>-- Nat<ept i="31">&lt;/s31&gt;</ept>
<bpt i="32" x="32">&lt;s32&gt;</bpt>#check<ept i="32">&lt;/s32&gt;</ept> (<bpt i="33" x="33">&lt;s33&gt;</bpt>5<ept i="33">&lt;/s33&gt;</ept>, <bpt i="34" x="34">&lt;s34&gt;</bpt>9<ept i="34">&lt;/s34&gt;</ept>).<bpt i="35" x="35">&lt;s35&gt;</bpt>1<ept i="35">&lt;/s35&gt;</ept>     <bpt i="36" x="36">&lt;s36&gt;</bpt>-- Nat<ept i="36">&lt;/s36&gt;</ept>
<bpt i="37" x="37">&lt;s37&gt;</bpt>#check<ept i="37">&lt;/s37&gt;</ept> (<bpt i="38" x="38">&lt;s38&gt;</bpt>5<ept i="38">&lt;/s38&gt;</ept>, <bpt i="39" x="39">&lt;s39&gt;</bpt>9<ept i="39">&lt;/s39&gt;</ept>).<bpt i="40" x="40">&lt;s40&gt;</bpt>2<ept i="40">&lt;/s40&gt;</ept>     <bpt i="41" x="41">&lt;s41&gt;</bpt>-- Nat<ept i="41">&lt;/s41&gt;</ept>

<bpt i="42" x="42">&lt;s42&gt;</bpt>#eval<ept i="42">&lt;/s42&gt;</ept> Nat.succ <bpt i="43" x="43">&lt;s43&gt;</bpt>2<ept i="43">&lt;/s43&gt;</ept>   <bpt i="44" x="44">&lt;s44&gt;</bpt>-- 3<ept i="44">&lt;/s44&gt;</ept>
<bpt i="45" x="45">&lt;s45&gt;</bpt>#eval<ept i="45">&lt;/s45&gt;</ept> Nat.add <bpt i="46" x="46">&lt;s46&gt;</bpt>5<ept i="46">&lt;/s46&gt;</ept> <bpt i="47" x="47">&lt;s47&gt;</bpt>2<ept i="47">&lt;/s47&gt;</ept>  <bpt i="48" x="48">&lt;s48&gt;</bpt>-- 7<ept i="48">&lt;/s48&gt;</ept>
<bpt i="49" x="49">&lt;s49&gt;</bpt>#eval<ept i="49">&lt;/s49&gt;</ept> (<bpt i="50" x="50">&lt;s50&gt;</bpt>5<ept i="50">&lt;/s50&gt;</ept>, <bpt i="51" x="51">&lt;s51&gt;</bpt>9<ept i="51">&lt;/s51&gt;</ept>).<bpt i="52" x="52">&lt;s52&gt;</bpt>1<ept i="52">&lt;/s52&gt;</ept>     <bpt i="53" x="53">&lt;s53&gt;</bpt>-- 5<ept i="53">&lt;/s53&gt;</ept>
<bpt i="54" x="54">&lt;s54&gt;</bpt>#eval<ept i="54">&lt;/s54&gt;</ept> (<bpt i="55" x="55">&lt;s55&gt;</bpt>5<ept i="55">&lt;/s55&gt;</ept>, <bpt i="56" x="56">&lt;s56&gt;</bpt>9<ept i="56">&lt;/s56&gt;</ept>).<bpt i="57" x="57">&lt;s57&gt;</bpt>2<ept i="57">&lt;/s57&gt;</ept>     <bpt i="58" x="58">&lt;s58&gt;</bpt>-- 9<ept i="58">&lt;/s58&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T041436Z" creationid="tlqk3" creationdate="20220131T041324Z">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt>#check<ept i="0">&lt;/s0&gt;</ept> Nat → Nat      <bpt i="1" x="1">&lt;s1&gt;</bpt>-- 화살표를 쓰기 위해서 "\to"나 "\r"를 치세요.<ept i="1">&lt;/s1&gt;</ept>
<bpt i="2" x="2">&lt;s2&gt;</bpt>#check<ept i="2">&lt;/s2&gt;</ept> Nat -&gt; Nat     <bpt i="3" x="3">&lt;s3&gt;</bpt>--  ASCII 표기의 대체표현입니다.<ept i="3">&lt;/s3&gt;</ept>

<bpt i="4" x="4">&lt;s4&gt;</bpt>#check<ept i="4">&lt;/s4&gt;</ept> Nat × Nat      <bpt i="5" x="5">&lt;s5&gt;</bpt>-- 곱하기를 쓰기 위해 "\times"를 치세요.<ept i="5">&lt;/s5&gt;</ept>
<bpt i="6" x="6">&lt;s6&gt;</bpt>#check<ept i="6">&lt;/s6&gt;</ept> Prod Nat Nat   <bpt i="7" x="7">&lt;s7&gt;</bpt>-- 대체 표현입니다.<ept i="7">&lt;/s7&gt;</ept>

<bpt i="8" x="8">&lt;s8&gt;</bpt>#check<ept i="8">&lt;/s8&gt;</ept> Nat → Nat → Nat
<bpt i="9" x="9">&lt;s9&gt;</bpt>#check<ept i="9">&lt;/s9&gt;</ept> Nat → (Nat → Nat)  <bpt i="10" x="10">&lt;s10&gt;</bpt>--  위와 같은 유형입니다.<ept i="10">&lt;/s10&gt;</ept>

<bpt i="11" x="11">&lt;s11&gt;</bpt>#check<ept i="11">&lt;/s11&gt;</ept> Nat × Nat → Nat
<bpt i="12" x="12">&lt;s12&gt;</bpt>#check<ept i="12">&lt;/s12&gt;</ept> (Nat → Nat) → Nat <bpt i="13" x="13">&lt;s13&gt;</bpt>-- "범함수"<ept i="13">&lt;/s13&gt;</ept>

<bpt i="14" x="14">&lt;s14&gt;</bpt>#check<ept i="14">&lt;/s14&gt;</ept> Nat.succ     <bpt i="15" x="15">&lt;s15&gt;</bpt>-- Nat → Nat<ept i="15">&lt;/s15&gt;</ept>
<bpt i="16" x="16">&lt;s16&gt;</bpt>#check<ept i="16">&lt;/s16&gt;</ept> (<bpt i="17" x="17">&lt;s17&gt;</bpt>0<ept i="17">&lt;/s17&gt;</ept>, <bpt i="18" x="18">&lt;s18&gt;</bpt>1<ept i="18">&lt;/s18&gt;</ept>)       <bpt i="19" x="19">&lt;s19&gt;</bpt>-- Nat × Nat<ept i="19">&lt;/s19&gt;</ept>
<bpt i="20" x="20">&lt;s20&gt;</bpt>#check<ept i="20">&lt;/s20&gt;</ept> Nat.add      <bpt i="21" x="21">&lt;s21&gt;</bpt>-- Nat → Nat → Nat<ept i="21">&lt;/s21&gt;</ept>

<bpt i="22" x="22">&lt;s22&gt;</bpt>#check<ept i="22">&lt;/s22&gt;</ept> Nat.succ <bpt i="23" x="23">&lt;s23&gt;</bpt>2<ept i="23">&lt;/s23&gt;</ept>   <bpt i="24" x="24">&lt;s24&gt;</bpt>-- Nat<ept i="24">&lt;/s24&gt;</ept>
<bpt i="25" x="25">&lt;s25&gt;</bpt>#check<ept i="25">&lt;/s25&gt;</ept> Nat.add <bpt i="26" x="26">&lt;s26&gt;</bpt>3<ept i="26">&lt;/s26&gt;</ept>    <bpt i="27" x="27">&lt;s27&gt;</bpt>-- Nat → Nat<ept i="27">&lt;/s27&gt;</ept>
<bpt i="28" x="28">&lt;s28&gt;</bpt>#check<ept i="28">&lt;/s28&gt;</ept> Nat.add <bpt i="29" x="29">&lt;s29&gt;</bpt>5<ept i="29">&lt;/s29&gt;</ept> <bpt i="30" x="30">&lt;s30&gt;</bpt>2<ept i="30">&lt;/s30&gt;</ept>  <bpt i="31" x="31">&lt;s31&gt;</bpt>-- Nat<ept i="31">&lt;/s31&gt;</ept>
<bpt i="32" x="32">&lt;s32&gt;</bpt>#check<ept i="32">&lt;/s32&gt;</ept> (<bpt i="33" x="33">&lt;s33&gt;</bpt>5<ept i="33">&lt;/s33&gt;</ept>, <bpt i="34" x="34">&lt;s34&gt;</bpt>9<ept i="34">&lt;/s34&gt;</ept>).<bpt i="35" x="35">&lt;s35&gt;</bpt>1<ept i="35">&lt;/s35&gt;</ept>     <bpt i="36" x="36">&lt;s36&gt;</bpt>-- Nat<ept i="36">&lt;/s36&gt;</ept>
<bpt i="37" x="37">&lt;s37&gt;</bpt>#check<ept i="37">&lt;/s37&gt;</ept> (<bpt i="38" x="38">&lt;s38&gt;</bpt>5<ept i="38">&lt;/s38&gt;</ept>, <bpt i="39" x="39">&lt;s39&gt;</bpt>9<ept i="39">&lt;/s39&gt;</ept>).<bpt i="40" x="40">&lt;s40&gt;</bpt>2<ept i="40">&lt;/s40&gt;</ept>     <bpt i="41" x="41">&lt;s41&gt;</bpt>-- Nat<ept i="41">&lt;/s41&gt;</ept>

<bpt i="42" x="42">&lt;s42&gt;</bpt>#eval<ept i="42">&lt;/s42&gt;</ept> Nat.succ <bpt i="43" x="43">&lt;s43&gt;</bpt>2<ept i="43">&lt;/s43&gt;</ept>   <bpt i="44" x="44">&lt;s44&gt;</bpt>-- 3<ept i="44">&lt;/s44&gt;</ept>
<bpt i="45" x="45">&lt;s45&gt;</bpt>#eval<ept i="45">&lt;/s45&gt;</ept> Nat.add <bpt i="46" x="46">&lt;s46&gt;</bpt>5<ept i="46">&lt;/s46&gt;</ept> <bpt i="47" x="47">&lt;s47&gt;</bpt>2<ept i="47">&lt;/s47&gt;</ept>  <bpt i="48" x="48">&lt;s48&gt;</bpt>-- 7<ept i="48">&lt;/s48&gt;</ept>
<bpt i="49" x="49">&lt;s49&gt;</bpt>#eval<ept i="49">&lt;/s49&gt;</ept> (<bpt i="50" x="50">&lt;s50&gt;</bpt>5<ept i="50">&lt;/s50&gt;</ept>, <bpt i="51" x="51">&lt;s51&gt;</bpt>9<ept i="51">&lt;/s51&gt;</ept>).<bpt i="52" x="52">&lt;s52&gt;</bpt>1<ept i="52">&lt;/s52&gt;</ept>     <bpt i="53" x="53">&lt;s53&gt;</bpt>-- 5<ept i="53">&lt;/s53&gt;</ept>
<bpt i="54" x="54">&lt;s54&gt;</bpt>#eval<ept i="54">&lt;/s54&gt;</ept> (<bpt i="55" x="55">&lt;s55&gt;</bpt>5<ept i="55">&lt;/s55&gt;</ept>, <bpt i="56" x="56">&lt;s56&gt;</bpt>9<ept i="56">&lt;/s56&gt;</ept>).<bpt i="57" x="57">&lt;s57&gt;</bpt>2<ept i="57">&lt;/s57&gt;</ept>     <bpt i="58" x="58">&lt;s58&gt;</bpt>-- 9<ept i="58">&lt;/s58&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><it pos="begin" x="0">&lt;s0&gt;</it>/- Define some constants.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T034912Z" creationid="tlqk3" creationdate="20220131T034912Z">
        <seg><it pos="begin" x="0">&lt;s0&gt;</it>/- 몇 가지 상수를 정의합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt>1.<ept i="0">&lt;/s0&gt;</ept> Introduction</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T075938Z" creationid="tlqk35" creationdate="20220130T072737Z">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt>1.<ept i="0">&lt;/s0&gt;</ept> 소개(Introduction)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt>10.<ept i="0">&lt;/s0&gt;</ept> Type Classes</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T073045Z" creationid="tlqk35" creationdate="20220130T073045Z">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt>10.<ept i="0">&lt;/s0&gt;</ept> 유형 계층(Type Classes)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt>11.<ept i="0">&lt;/s0&gt;</ept> The Conversion Tactic Mode</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T073122Z" creationid="tlqk35" creationdate="20220130T073122Z">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt>11.<ept i="0">&lt;/s0&gt;</ept> 전략 모드로 전환(The Conversion Tactic Mode)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt>12.<ept i="0">&lt;/s0&gt;</ept> Axioms and Computation</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T075822Z" creationid="tlqk35" creationdate="20220130T073221Z">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt>12.<ept i="0">&lt;/s0&gt;</ept> 공리계와 계산(Axioms and Computation)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt>2.<ept i="0">&lt;/s0&gt;</ept> Dependent Type Theory</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T072748Z" creationid="tlqk35" creationdate="20220130T072748Z">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt>2.<ept i="0">&lt;/s0&gt;</ept> 의존 유형론(Dependent Type Theory)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt>3.<ept i="0">&lt;/s0&gt;</ept> Propositions and Proofs</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T072757Z" creationid="tlqk35" creationdate="20220130T072757Z">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt>3.<ept i="0">&lt;/s0&gt;</ept> 명제와 증명(Propositions and Proofs)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt>4.<ept i="0">&lt;/s0&gt;</ept> Quantifiers and Equality</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T072922Z" creationid="tlqk35" creationdate="20220130T072922Z">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt>4.<ept i="0">&lt;/s0&gt;</ept> 한정기호와 동등성(Quantifiers and Equality)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt>5.<ept i="0">&lt;/s0&gt;</ept> Tactics</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T072931Z" creationid="tlqk35" creationdate="20220130T072931Z">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt>5.<ept i="0">&lt;/s0&gt;</ept> 전략(Tactics)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt>6.<ept i="0">&lt;/s0&gt;</ept> Interacting with Lean</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T072947Z" creationid="tlqk35" creationdate="20220130T072947Z">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt>6.<ept i="0">&lt;/s0&gt;</ept> 린과 상호작용하기(Interacting with Lean)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt>7.<ept i="0">&lt;/s0&gt;</ept> Inductive Types</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T072957Z" creationid="tlqk35" creationdate="20220130T072957Z">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt>7.<ept i="0">&lt;/s0&gt;</ept> 귀납형(Inductive Types)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt>8.<ept i="0">&lt;/s0&gt;</ept> Induction and Recursion</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T073007Z" creationid="tlqk35" creationdate="20220130T073007Z">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt>8.<ept i="0">&lt;/s0&gt;</ept> 귀납과 재귀(Induction and Recursion)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt>9.<ept i="0">&lt;/s0&gt;</ept> Structures and Records</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T073021Z" creationid="tlqk35" creationdate="20220130T073021Z">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt>9.<ept i="0">&lt;/s0&gt;</ept> 구조체와 레코드(Structures and Records)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt>open<ept i="0">&lt;/s0&gt;</ept> Classical

<bpt i="1" x="1">&lt;s1&gt;</bpt>-- distributivity<ept i="1">&lt;/s1&gt;</ept>
<bpt i="2" x="2">&lt;s2&gt;</bpt>example<ept i="2">&lt;/s2&gt;</ept> (p q r : <bpt i="3" x="3">&lt;s3&gt;</bpt>Prop<ept i="3">&lt;/s3&gt;</ept>) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) :=</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T152410Z" creationid="tlqk3" creationdate="20220211T152410Z">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt>open<ept i="0">&lt;/s0&gt;</ept> Classical

<bpt i="1" x="1">&lt;s1&gt;</bpt>-- 분배성<ept i="1">&lt;/s1&gt;</ept>
<bpt i="2" x="2">&lt;s2&gt;</bpt>example<ept i="2">&lt;/s2&gt;</ept> (p q r : <bpt i="3" x="3">&lt;s3&gt;</bpt>Prop<ept i="3">&lt;/s3&gt;</ept>) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) :=</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt>open<ept i="0">&lt;/s0&gt;</ept> Classical
<bpt i="1" x="1">&lt;s1&gt;</bpt>variable<ept i="1">&lt;/s1&gt;</ept> (p q : <bpt i="2" x="2">&lt;s2&gt;</bpt>Prop<ept i="2">&lt;/s2&gt;</ept>)

<bpt i="3" x="3">&lt;s3&gt;</bpt>-- BEGIN<ept i="3">&lt;/s3&gt;</ept>
<bpt i="4" x="4">&lt;s4&gt;</bpt>example<ept i="4">&lt;/s4&gt;</ept> (h : ¬(p ∧ q)) : ¬p ∨ ¬q :=</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T161616Z" creationid="tlqk3" creationdate="20220211T161616Z">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt>open<ept i="0">&lt;/s0&gt;</ept> Classical
<bpt i="1" x="1">&lt;s1&gt;</bpt>variable<ept i="1">&lt;/s1&gt;</ept> (p q : <bpt i="2" x="2">&lt;s2&gt;</bpt>Prop<ept i="2">&lt;/s2&gt;</ept>)

<bpt i="3" x="3">&lt;s3&gt;</bpt>-- 시작<ept i="3">&lt;/s3&gt;</ept>
<bpt i="4" x="4">&lt;s4&gt;</bpt>example<ept i="4">&lt;/s4&gt;</ept> (h : ¬(p ∧ q)) : ¬p ∨ ¬q :=</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt>variable<ept i="0">&lt;/s0&gt;</ept> (p q r : <bpt i="1" x="1">&lt;s1&gt;</bpt>Prop<ept i="1">&lt;/s1&gt;</ept>)

<bpt i="2" x="2">&lt;s2&gt;</bpt>-- commutativity of ∧ and ∨<ept i="2">&lt;/s2&gt;</ept>
<bpt i="3" x="3">&lt;s3&gt;</bpt>example<ept i="3">&lt;/s3&gt;</ept> : p ∧ q ↔ q ∧ p := <bpt i="4" x="4">&lt;s4&gt;</bpt>sorry<ept i="4">&lt;/s4&gt;</ept>
<bpt i="5" x="5">&lt;s5&gt;</bpt>example<ept i="5">&lt;/s5&gt;</ept> : p ∨ q ↔ q ∨ p := <bpt i="6" x="6">&lt;s6&gt;</bpt>sorry<ept i="6">&lt;/s6&gt;</ept>

<bpt i="7" x="7">&lt;s7&gt;</bpt>-- associativity of ∧ and ∨<ept i="7">&lt;/s7&gt;</ept>
<bpt i="8" x="8">&lt;s8&gt;</bpt>example<ept i="8">&lt;/s8&gt;</ept> : (p ∧ q) ∧ r ↔ p ∧ (q ∧ r) := <bpt i="9" x="9">&lt;s9&gt;</bpt>sorry<ept i="9">&lt;/s9&gt;</ept>
<bpt i="10" x="10">&lt;s10&gt;</bpt>example<ept i="10">&lt;/s10&gt;</ept> : (p ∨ q) ∨ r ↔ p ∨ (q ∨ r) := <bpt i="11" x="11">&lt;s11&gt;</bpt>sorry<ept i="11">&lt;/s11&gt;</ept>

<bpt i="12" x="12">&lt;s12&gt;</bpt>-- distributivity<ept i="12">&lt;/s12&gt;</ept>
<bpt i="13" x="13">&lt;s13&gt;</bpt>example<ept i="13">&lt;/s13&gt;</ept> : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) := <bpt i="14" x="14">&lt;s14&gt;</bpt>sorry<ept i="14">&lt;/s14&gt;</ept>
<bpt i="15" x="15">&lt;s15&gt;</bpt>example<ept i="15">&lt;/s15&gt;</ept> : p ∨ (q ∧ r) ↔ (p ∨ q) ∧ (p ∨ r) := <bpt i="16" x="16">&lt;s16&gt;</bpt>sorry<ept i="16">&lt;/s16&gt;</ept>

<bpt i="17" x="17">&lt;s17&gt;</bpt>-- other properties<ept i="17">&lt;/s17&gt;</ept>
<bpt i="18" x="18">&lt;s18&gt;</bpt>example<ept i="18">&lt;/s18&gt;</ept> : (p → (q → r)) ↔ (p ∧ q → r) := <bpt i="19" x="19">&lt;s19&gt;</bpt>sorry<ept i="19">&lt;/s19&gt;</ept>
<bpt i="20" x="20">&lt;s20&gt;</bpt>example<ept i="20">&lt;/s20&gt;</ept> : ((p ∨ q) → r) ↔ (p → r) ∧ (q → r) := <bpt i="21" x="21">&lt;s21&gt;</bpt>sorry<ept i="21">&lt;/s21&gt;</ept>
<bpt i="22" x="22">&lt;s22&gt;</bpt>example<ept i="22">&lt;/s22&gt;</ept> : ¬(p ∨ q) ↔ ¬p ∧ ¬q := <bpt i="23" x="23">&lt;s23&gt;</bpt>sorry<ept i="23">&lt;/s23&gt;</ept>
<bpt i="24" x="24">&lt;s24&gt;</bpt>example<ept i="24">&lt;/s24&gt;</ept> : ¬p ∨ ¬q → ¬(p ∧ q) := <bpt i="25" x="25">&lt;s25&gt;</bpt>sorry<ept i="25">&lt;/s25&gt;</ept>
<bpt i="26" x="26">&lt;s26&gt;</bpt>example<ept i="26">&lt;/s26&gt;</ept> : ¬(p ∧ ¬p) := <bpt i="27" x="27">&lt;s27&gt;</bpt>sorry<ept i="27">&lt;/s27&gt;</ept>
<bpt i="28" x="28">&lt;s28&gt;</bpt>example<ept i="28">&lt;/s28&gt;</ept> : p ∧ ¬q → ¬(p → q) := <bpt i="29" x="29">&lt;s29&gt;</bpt>sorry<ept i="29">&lt;/s29&gt;</ept>
<bpt i="30" x="30">&lt;s30&gt;</bpt>example<ept i="30">&lt;/s30&gt;</ept> : ¬p → (p → q) := <bpt i="31" x="31">&lt;s31&gt;</bpt>sorry<ept i="31">&lt;/s31&gt;</ept>
<bpt i="32" x="32">&lt;s32&gt;</bpt>example<ept i="32">&lt;/s32&gt;</ept> : (¬p ∨ q) → (p → q) := <bpt i="33" x="33">&lt;s33&gt;</bpt>sorry<ept i="33">&lt;/s33&gt;</ept>
<bpt i="34" x="34">&lt;s34&gt;</bpt>example<ept i="34">&lt;/s34&gt;</ept> : p ∨ False ↔ p := <bpt i="35" x="35">&lt;s35&gt;</bpt>sorry<ept i="35">&lt;/s35&gt;</ept>
<bpt i="36" x="36">&lt;s36&gt;</bpt>example<ept i="36">&lt;/s36&gt;</ept> : p ∧ False ↔ False := <bpt i="37" x="37">&lt;s37&gt;</bpt>sorry<ept i="37">&lt;/s37&gt;</ept>
<bpt i="38" x="38">&lt;s38&gt;</bpt>example<ept i="38">&lt;/s38&gt;</ept> : (p → q) → (¬q → ¬p) := <bpt i="39" x="39">&lt;s39&gt;</bpt>sorry<ept i="39">&lt;/s39&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T152254Z" creationid="tlqk3" creationdate="20220211T152254Z">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt>variable<ept i="0">&lt;/s0&gt;</ept> (p q r : <bpt i="1" x="1">&lt;s1&gt;</bpt>Prop<ept i="1">&lt;/s1&gt;</ept>)

<bpt i="2" x="2">&lt;s2&gt;</bpt>-- ∧ 과 ∨의 교환성<ept i="2">&lt;/s2&gt;</ept>
<bpt i="3" x="3">&lt;s3&gt;</bpt>example<ept i="3">&lt;/s3&gt;</ept> : p ∧ q ↔ q ∧ p := <bpt i="4" x="4">&lt;s4&gt;</bpt>sorry<ept i="4">&lt;/s4&gt;</ept>
<bpt i="5" x="5">&lt;s5&gt;</bpt>example<ept i="5">&lt;/s5&gt;</ept> : p ∨ q ↔ q ∨ p := <bpt i="6" x="6">&lt;s6&gt;</bpt>sorry<ept i="6">&lt;/s6&gt;</ept>

<bpt i="7" x="7">&lt;s7&gt;</bpt>-- ∧ 과 ∨의 결합성<ept i="7">&lt;/s7&gt;</ept>
<bpt i="8" x="8">&lt;s8&gt;</bpt>example<ept i="8">&lt;/s8&gt;</ept> : (p ∧ q) ∧ r ↔ p ∧ (q ∧ r) := <bpt i="9" x="9">&lt;s9&gt;</bpt>sorry<ept i="9">&lt;/s9&gt;</ept>
<bpt i="10" x="10">&lt;s10&gt;</bpt>example<ept i="10">&lt;/s10&gt;</ept> : (p ∨ q) ∨ r ↔ p ∨ (q ∨ r) := <bpt i="11" x="11">&lt;s11&gt;</bpt>sorry<ept i="11">&lt;/s11&gt;</ept>

<bpt i="12" x="12">&lt;s12&gt;</bpt>--분배성<ept i="12">&lt;/s12&gt;</ept>
<bpt i="13" x="13">&lt;s13&gt;</bpt>example<ept i="13">&lt;/s13&gt;</ept> : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) := <bpt i="14" x="14">&lt;s14&gt;</bpt>sorry<ept i="14">&lt;/s14&gt;</ept>
<bpt i="15" x="15">&lt;s15&gt;</bpt>example<ept i="15">&lt;/s15&gt;</ept> : p ∨ (q ∧ r) ↔ (p ∨ q) ∧ (p ∨ r) := <bpt i="16" x="16">&lt;s16&gt;</bpt>sorry<ept i="16">&lt;/s16&gt;</ept>

<bpt i="17" x="17">&lt;s17&gt;</bpt>-- 다른 특성<ept i="17">&lt;/s17&gt;</ept>
<bpt i="18" x="18">&lt;s18&gt;</bpt>example<ept i="18">&lt;/s18&gt;</ept> : (p → (q → r)) ↔ (p ∧ q → r) := <bpt i="19" x="19">&lt;s19&gt;</bpt>sorry<ept i="19">&lt;/s19&gt;</ept>
<bpt i="20" x="20">&lt;s20&gt;</bpt>example<ept i="20">&lt;/s20&gt;</ept> : ((p ∨ q) → r) ↔ (p → r) ∧ (q → r) := <bpt i="21" x="21">&lt;s21&gt;</bpt>sorry<ept i="21">&lt;/s21&gt;</ept>
<bpt i="22" x="22">&lt;s22&gt;</bpt>example<ept i="22">&lt;/s22&gt;</ept> : ¬(p ∨ q) ↔ ¬p ∧ ¬q := <bpt i="23" x="23">&lt;s23&gt;</bpt>sorry<ept i="23">&lt;/s23&gt;</ept>
<bpt i="24" x="24">&lt;s24&gt;</bpt>example<ept i="24">&lt;/s24&gt;</ept> : ¬p ∨ ¬q → ¬(p ∧ q) := <bpt i="25" x="25">&lt;s25&gt;</bpt>sorry<ept i="25">&lt;/s25&gt;</ept>
<bpt i="26" x="26">&lt;s26&gt;</bpt>example<ept i="26">&lt;/s26&gt;</ept> : ¬(p ∧ ¬p) := <bpt i="27" x="27">&lt;s27&gt;</bpt>sorry<ept i="27">&lt;/s27&gt;</ept>
<bpt i="28" x="28">&lt;s28&gt;</bpt>example<ept i="28">&lt;/s28&gt;</ept> : p ∧ ¬q → ¬(p → q) := <bpt i="29" x="29">&lt;s29&gt;</bpt>sorry<ept i="29">&lt;/s29&gt;</ept>
<bpt i="30" x="30">&lt;s30&gt;</bpt>example<ept i="30">&lt;/s30&gt;</ept> : ¬p → (p → q) := <bpt i="31" x="31">&lt;s31&gt;</bpt>sorry<ept i="31">&lt;/s31&gt;</ept>
<bpt i="32" x="32">&lt;s32&gt;</bpt>example<ept i="32">&lt;/s32&gt;</ept> : (¬p ∨ q) → (p → q) := <bpt i="33" x="33">&lt;s33&gt;</bpt>sorry<ept i="33">&lt;/s33&gt;</ept>
<bpt i="34" x="34">&lt;s34&gt;</bpt>example<ept i="34">&lt;/s34&gt;</ept> : p ∨ False ↔ p := <bpt i="35" x="35">&lt;s35&gt;</bpt>sorry<ept i="35">&lt;/s35&gt;</ept>
<bpt i="36" x="36">&lt;s36&gt;</bpt>example<ept i="36">&lt;/s36&gt;</ept> : p ∧ False ↔ False := <bpt i="37" x="37">&lt;s37&gt;</bpt>sorry<ept i="37">&lt;/s37&gt;</ept>
<bpt i="38" x="38">&lt;s38&gt;</bpt>example<ept i="38">&lt;/s38&gt;</ept> : (p → q) → (¬q → ¬p) := <bpt i="39" x="39">&lt;s39&gt;</bpt>sorry<ept i="39">&lt;/s39&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="22" x="22">&lt;s22&gt;</bpt>show<ept i="22">&lt;/s22&gt;</ept> p ∧ (q ∨ r) <bpt i="23" x="23">&lt;s23&gt;</bpt>from<ept i="23">&lt;/s23&gt;</ept> ⟨hp, Or.inr hr⟩))

<bpt i="24" x="24">&lt;s24&gt;</bpt>-- an example that requires classical reasoning<ept i="24">&lt;/s24&gt;</ept>
<bpt i="25" x="25">&lt;s25&gt;</bpt>example<ept i="25">&lt;/s25&gt;</ept> (p q : <bpt i="26" x="26">&lt;s26&gt;</bpt>Prop<ept i="26">&lt;/s26&gt;</ept>) : ¬(p ∧ ¬q) → (p → q) :=</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T152341Z" creationid="tlqk3" creationdate="20220211T152341Z">
        <seg><bpt i="22" x="22">&lt;s22&gt;</bpt>show<ept i="22">&lt;/s22&gt;</ept> p ∧ (q ∨ r) <bpt i="23" x="23">&lt;s23&gt;</bpt>from<ept i="23">&lt;/s23&gt;</ept> ⟨hp, Or.inr hr⟩))

<bpt i="24" x="24">&lt;s24&gt;</bpt>-- 고전 추론을 필요로 하는 예제<ept i="24">&lt;/s24&gt;</ept>
<bpt i="25" x="25">&lt;s25&gt;</bpt>example<ept i="25">&lt;/s25&gt;</ept> (p q : <bpt i="26" x="26">&lt;s26&gt;</bpt>Prop<ept i="26">&lt;/s26&gt;</ept>) : ¬(p ∧ ¬q) → (p → q) :=</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A calculation can be viewed as a proof as well, and these systems, too, help establish mathematical claims.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T101709Z" creationid="tlqk35" creationdate="20220130T090404Z">
        <seg>계산도 증명의 관점으로 볼 수 있으며 이런 시스템들도 수학적 진술을 세우는데 도움을 줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A disadvantage is that Lean does not have enough information to infer the types of the arguments in the expressions <bpt i="2" x="2">&lt;c2&gt;</bpt>trans_r<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>trans_r hab<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220222T145506Z" creationid="tlqk35" creationdate="20220222T145506Z">
        <seg>단점은 린이 표현식 <bpt i="2" x="2">&lt;c2&gt;</bpt>trans_r<ept i="2">&lt;/c2&gt;</ept>과 <bpt i="3" x="3">&lt;c3&gt;</bpt>trans_r hab<ept i="3">&lt;/c3&gt;</ept>에서 인자의 유형을 추론하기에 충분한 정보가 없다는 것 입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A first guess might be <bpt i="3" x="3">&lt;c3&gt;</bpt>Type → α → list α → list α<ept i="3">&lt;/c3&gt;</ept>, but, on reflection, this does not make sense: the <bpt i="4" x="4">&lt;c4&gt;</bpt>α<ept i="4">&lt;/c4&gt;</ept> in this expression does not refer to anything, whereas it should refer to the argument of type <bpt i="5" x="5">&lt;c5&gt;</bpt>Type<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T073153Z" creationid="tlqk3" creationdate="20220131T073153Z">
        <seg>첫 번째 추측은 <bpt i="3" x="3">&lt;c3&gt;</bpt>Type → α → list α → list α<ept i="3">&lt;/c3&gt;</ept>일지 모릅니다. 그러나 생각해보면 이는 말이 되지 않습니다. 이 식에서 <bpt i="4" x="4">&lt;c4&gt;</bpt>α<ept i="4">&lt;/c4&gt;</ept>는 어떤 것도 지칭하지 않으므로 <bpt i="5" x="5">&lt;c5&gt;</bpt>Type<ept i="5">&lt;/c5&gt;</ept> 유형을 인수로 지칭해야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A proof of <bpt i="1" x="1">&lt;c1&gt;</bpt>p<ept i="1">&lt;/c1&gt;</ept> is then simply an object <bpt i="2" x="2">&lt;c2&gt;</bpt>t : p<ept i="2">&lt;/c2&gt;</ept> of the right type.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T141539Z" creationid="tlqk3" creationdate="20220211T140957Z">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>p<ept i="1">&lt;/c1&gt;</ept>의 증명은 단순히 <bpt i="2" x="2">&lt;c2&gt;</bpt>t : p<ept i="2">&lt;/c2&gt;</ept> 오른쪽 유형의 객체입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>About Lean</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T092600Z" creationid="tlqk35" creationdate="20220130T092600Z">
        <seg>린에 대해서</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>About this Book</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T094450Z" creationid="tlqk35" creationdate="20220130T094450Z">
        <seg>이 책에 대하여</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Acknowledgments</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T100327Z" creationid="tlqk35" creationdate="20220130T100327Z">
        <seg>감사의 말</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Adding such extra information can improve the clarity of a proof and help detect errors when writing a proof.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T151809Z" creationid="tlqk3" creationdate="20220211T150959Z">
        <seg>그런 추가 정보를 더하는 것은 증명의 명확성을 개선하고 증명을 작성할 때 오류를 감지하도록 돕습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>All that has changed are the braces around <bpt i="0" x="0">&lt;c0&gt;</bpt>α : Type u<ept i="0">&lt;/c0&gt;</ept> in the declaration of the variables.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T075133Z" creationid="tlqk3" creationdate="20220131T075133Z">
        <seg>바뀐 것이라곤 변수 선언에서 <bpt i="0" x="0">&lt;c0&gt;</bpt>α : Type u<ept i="0">&lt;/c0&gt;</ept> 주위의 괄호뿐입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An "axiom" would be a constant of such a type.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T102512Z" creationid="tlqk3" creationdate="20220211T102512Z">
        <seg>"공리"는 그러한 유형의 상수입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An expression like <bpt i="1" x="1">&lt;c1&gt;</bpt>id<ept i="1">&lt;/c1&gt;</ept> or <bpt i="2" x="2">&lt;c2&gt;</bpt>List.nil<ept i="2">&lt;/c2&gt;</ept> is said to be <bpt i="3" x="3">&lt;e3&gt;</bpt>polymorphic<ept i="3">&lt;/e3&gt;</ept>, because it can take on different meanings in different contexts.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T075743Z" creationid="tlqk3" creationdate="20220131T075743Z">
        <seg>다른 맥락에서 다른 의미를 가질 수 있기 때문에 <bpt i="1" x="1">&lt;c1&gt;</bpt>id<ept i="1">&lt;/c1&gt;</ept> 나 <bpt i="2" x="2">&lt;c2&gt;</bpt>List.nil<ept i="2">&lt;/c2&gt;</ept> 같은 표현식을 <bpt i="3" x="3">&lt;e3&gt;</bpt>다형적<ept i="3">&lt;/e3&gt;</ept>이라 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>And</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T160036Z" creationid="tlqk3" creationdate="20220211T160036Z">
        <seg>논리곱</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>And, indeed, it does:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T060457Z" creationid="tlqk3" creationdate="20220131T060457Z">
        <seg>그리고 당연히 그럽니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Any text between <bpt i="0" x="0">&lt;c0&gt;</bpt>/-<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>-/<ept i="1">&lt;/c1&gt;</ept> constitutes a comment block that is ignored by Lean.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T035237Z" creationid="tlqk3" creationdate="20220131T035132Z">
        <seg> <bpt i="0" x="0">&lt;c0&gt;</bpt>/-<ept i="0">&lt;/c0&gt;</ept>과 <bpt i="1" x="1">&lt;c1&gt;</bpt>-/<ept i="1">&lt;/c1&gt;</ept> 사이의 모든 글은 린에게 무시하라고 가리키는 주석을 만듭니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Application can be viewed as an "elimination rule," showing how to "eliminate" or use an implication in a proof.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T163120Z" creationid="tlqk3" creationdate="20220211T163120Z">
        <seg>적용은 어떻게 "제거"하는지 증명에서 함의를 사용하는지를 보여주는 "제거 규칙"으로 볼 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Applying the theorem <bpt i="3" x="3">&lt;c3&gt;</bpt>t1 : p → q → p<ept i="3">&lt;/c3&gt;</ept> to the fact <bpt i="4" x="4">&lt;c4&gt;</bpt>hp : p<ept i="4">&lt;/c4&gt;</ept> that <bpt i="5" x="5">&lt;c5&gt;</bpt>p<ept i="5">&lt;/c5&gt;</ept> is true yields the theorem <bpt i="6" x="6">&lt;c6&gt;</bpt>t1 hp : q → p<ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T154425Z" creationid="tlqk3" creationdate="20220211T154300Z">
        <seg>정리<bpt i="3" x="3">&lt;c3&gt;</bpt>t1 : p → q → p<ept i="3">&lt;/c3&gt;</ept>를 사실 <bpt i="4" x="4">&lt;c4&gt;</bpt>hp : p<ept i="4">&lt;/c4&gt;</ept>에 적용하는 것은 <bpt i="5" x="5">&lt;c5&gt;</bpt>p<ept i="5">&lt;/c5&gt;</ept>가 참임을 정리<bpt i="6" x="6">&lt;c6&gt;</bpt>t1 hp : q → p<ept i="6">&lt;/c6&gt;</ept>을 얻습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Applying this to the "hypothesis" <bpt i="3" x="3">&lt;c3&gt;</bpt>hab : r a b<ept i="3">&lt;/c3&gt;</ept>, we get a proof of the implication <bpt i="4" x="4">&lt;c4&gt;</bpt>r b c → r a c<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220222T145033Z" creationid="tlqk35" creationdate="20220222T145033Z">
        <seg>이를 "가정"  <bpt i="3" x="3">&lt;c3&gt;</bpt>hab : r a b<ept i="3">&lt;/c3&gt;</ept>에 적용함으로써 우리는 함의 <bpt i="4" x="4">&lt;c4&gt;</bpt>r b c → r a c<ept i="4">&lt;/c4&gt;</ept>의 증명을 얻습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Architectures like SMT ("satisfiability modulo theories") combine domain-general search methods with domain-specific procedures.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T101720Z" creationid="tlqk35" creationdate="20220130T090232Z">
        <seg>SMT(Satisfiability Modulo Theories)같은 구조는 영역-일반 탐색법을 영역-특정 절차와 결합했습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As a notational convention, we give the universal quantifier the widest scope possible, so parentheses are needed to limit the quantifier over <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept> to the hypothesis in the example above.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220222T143850Z" creationid="tlqk35" creationdate="20220222T143850Z">
        <seg>기호 규약으로써 우리는 전칭 한정기호에게 가능한 가장 넓은 범위를 줍니다. 그래서 위의 예제에서 가정의 <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>에만 한정사를 제한하도록 괄호가 필요합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As a result, given <bpt i="0" x="0">&lt;c0&gt;</bpt>h : p ∧ q<ept i="0">&lt;/c0&gt;</ept>, we can write <bpt i="1" x="1">&lt;c1&gt;</bpt>h.left<ept i="1">&lt;/c1&gt;</ept> for <bpt i="2" x="2">&lt;c2&gt;</bpt>And.left h<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>h.right<ept i="3">&lt;/c3&gt;</ept> for <bpt i="4" x="4">&lt;c4&gt;</bpt>And.right h<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T170141Z" creationid="tlqk3" creationdate="20220211T170141Z">
        <seg>결과적으로 <bpt i="0" x="0">&lt;c0&gt;</bpt>h : p ∧ q<ept i="0">&lt;/c0&gt;</ept>라면 우리는 <bpt i="1" x="1">&lt;c1&gt;</bpt>h.left<ept i="1">&lt;/c1&gt;</ept>를 <bpt i="2" x="2">&lt;c2&gt;</bpt>And.left h<ept i="2">&lt;/c2&gt;</ept>을 나타내는데 그리고 <bpt i="3" x="3">&lt;c3&gt;</bpt>h.right<ept i="3">&lt;/c3&gt;</ept> 를 <bpt i="4" x="4">&lt;c4&gt;</bpt>And.right h<ept i="4">&lt;/c4&gt;</ept>을 나타내는데 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As a result, the introduction of the connective <bpt i="6" x="6">&lt;c6&gt;</bpt>Implies<ept i="6">&lt;/c6&gt;</ept> is entirely redundant: we can use the usual function space constructor <bpt i="7" x="7">&lt;c7&gt;</bpt>p → q<ept i="7">&lt;/c7&gt;</ept> from dependent type theory as our notion of implication.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T141426Z" creationid="tlqk3" creationdate="20220211T135551Z">
        <seg>결과적으로 연결사 <bpt i="6" x="6">&lt;c6&gt;</bpt>Implies<ept i="6">&lt;/c6&gt;</ept>의 도입은 완전히 중복됩니다. 그래서 우리는 의존 유형론의 함의에 대한 개념으로써 종종 함수 공간 생성자<bpt i="7" x="7">&lt;c7&gt;</bpt>p → q<ept i="7">&lt;/c7&gt;</ept>를 사용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As a theorem of propositional logic, what does <bpt i="0" x="0">&lt;c0&gt;</bpt>t2<ept i="0">&lt;/c0&gt;</ept> say?</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T155942Z" creationid="tlqk3" creationdate="20220211T155942Z">
        <seg>명제 논리의 정리로써 <bpt i="0" x="0">&lt;c0&gt;</bpt>t2<ept i="0">&lt;/c0&gt;</ept>가 말하는 것은 무엇인가요?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As an exercise, try to understand why the definition of <bpt i="11" x="11">&lt;c11&gt;</bpt>foo<ept i="11">&lt;/c11&gt;</ept> below type checks, but the definition of <bpt i="12" x="12">&lt;c12&gt;</bpt>bar<ept i="12">&lt;/c12&gt;</ept> does not.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T070358Z" creationid="tlqk3" creationdate="20220131T070358Z">
        <seg>연습으로 아래 유형 확인에서 <bpt i="11" x="11">&lt;c11&gt;</bpt>foo<ept i="11">&lt;/c11&gt;</ept>의 정의가 왜 그런지 그러나  <bpt i="12" x="12">&lt;c12&gt;</bpt>bar<ept i="12">&lt;/c12&gt;</ept>의 정의는 그렇지 않은지 이해하려고 해 보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As an exercise, you might try proving the converse, that is, showing that <bpt i="4" x="4">&lt;c4&gt;</bpt>em<ept i="4">&lt;/c4&gt;</ept> can be proved from <bpt i="5" x="5">&lt;c5&gt;</bpt>dne<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T162400Z" creationid="tlqk3" creationdate="20220211T162400Z">
        <seg>연습으로 여러분은 역을 증명해보세요, 즉 <bpt i="4" x="4">&lt;c4&gt;</bpt>em<ept i="4">&lt;/c4&gt;</ept>이 <bpt i="5" x="5">&lt;c5&gt;</bpt>dne<ept i="5">&lt;/c5&gt;</ept>로부터 증명될 수 있음을 보이세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As another example, here is how we can express the fact that a relation, <bpt i="0" x="0">&lt;c0&gt;</bpt>r<ept i="0">&lt;/c0&gt;</ept>, is transitive:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220222T144731Z" creationid="tlqk35" creationdate="20220222T144731Z">
        <seg>또 다른 예제처럼 여기서 관계 <bpt i="0" x="0">&lt;c0&gt;</bpt>r<ept i="0">&lt;/c0&gt;</ept>이 추이적이라는 사실을 어떻게 표현할지를 보여줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As another example, let us consider the composition function discussed in the last chapter, now with propositions instead of types.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T155915Z" creationid="tlqk3" creationdate="20220211T155915Z">
        <seg>또 다른 예로써 지금은 유형 대신 명제로 지난 장에서 논한 합성함수를 고려해봅시다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As expected, the expression <bpt i="0" x="0">&lt;c0&gt;</bpt>(fun x : Nat =&gt; x) 1<ept i="0">&lt;/c0&gt;</ept> has type <bpt i="1" x="1">&lt;c1&gt;</bpt>Nat<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T060313Z" creationid="tlqk3" creationdate="20220131T060313Z">
        <seg>예상했다시피 표현식<bpt i="0" x="0">&lt;c0&gt;</bpt>(fun x : Nat =&gt; x) 1<ept i="0">&lt;/c0&gt;</ept> 은 <bpt i="1" x="1">&lt;c1&gt;</bpt>Nat<ept i="1">&lt;/c1&gt;</ept> 유형을 갖습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As the example above suggests, you have already seen an example of a function of type <bpt i="0" x="0">&lt;c0&gt;</bpt>Type → Type → Type<ept i="0">&lt;/c0&gt;</ept>, namely, the Cartesian product <bpt i="1" x="1">&lt;c1&gt;</bpt>Prod<ept i="1">&lt;/c1&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T045528Z" creationid="tlqk3" creationdate="20220131T045528Z">
        <seg>위 예에서 제안한 것처럼 여러분은 이미 주로 카테시안 곱 <bpt i="1" x="1">&lt;c1&gt;</bpt>Prod<ept i="1">&lt;/c1&gt;</ept>에서 <bpt i="0" x="0">&lt;c0&gt;</bpt>Type → Type → Type<ept i="0">&lt;/c0&gt;</ept> 유형의 함수의 예를 보았습니다. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As was the case for implication, the propositions-as-types interpretation now comes into play.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220222T142229Z" creationid="tlqk35" creationdate="20220222T142229Z">
        <seg>함의의 경우 때와 같이 유형으로써 명제 해석은 이제 제 역할을 하기 시작했습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As with definitions, the <bpt i="0" x="0">&lt;c0&gt;</bpt>#print<ept i="0">&lt;/c0&gt;</ept> command will show you the proof of a theorem.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T150625Z" creationid="tlqk3" creationdate="20220211T150625Z">
        <seg>정의와 마찬가지로 <bpt i="0" x="0">&lt;c0&gt;</bpt>#print<ept i="0">&lt;/c0&gt;</ept>명령은 정리의 증명을 여러분에게 보여줄 것 입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As with ordinary definitions, we can move the lambda-abstracted variables to the left of the colon:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T151745Z" creationid="tlqk3" creationdate="20220211T151413Z">
        <seg>평범한 정의처럼 우리는 람다 추상화된 변수를 콜론의 왼쪽으로 옮길 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As with the propositional connectives, in systems of natural deduction, "forall" is governed by an introduction and elimination rule.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220222T141819Z" creationid="tlqk35" creationdate="20220222T141819Z">
        <seg>명제적 연결사와 마찬가지로 자연 연역에서 "모든"은  도입과 제거 규칙에 지배받습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Ascii</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T153952Z" creationid="tlqk3" creationdate="20220211T153952Z">
        <seg>Ascii(아스키)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Associativity:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T153657Z" creationid="tlqk3" creationdate="20220211T153657Z">
        <seg>결합성</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Automated reasoning systems strive for power and efficiency, often at the expense of guaranteed soundness.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T101703Z" creationid="tlqk35" creationdate="20220130T090457Z">
        <seg>자동화된 추론 시스템은 종종 건전성 보장을 희생해서라도 성능과 효율성을 끌어올리기 위해 애쓰고 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Ayu</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T073610Z" creationid="tlqk35" creationdate="20220130T073432Z">
        <seg>짙은 검은색</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Because <bpt i="0" x="0">&lt;c0&gt;</bpt>Or<ept i="0">&lt;/c0&gt;</ept> has two constructors, we cannot use anonymous constructor notation.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T172353Z" creationid="tlqk3" creationdate="20220211T172353Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Or<ept i="0">&lt;/c0&gt;</ept>은 두 개의 생성자가 있기 때문에 우리는 익명 생성자 표기를 사용할 수 없습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Because fully detailed axiomatic proofs are so complicated, the challenge of theorem proving is to have the computer fill in as many of the details as possible.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T101227Z" creationid="tlqk35" creationdate="20220130T095139Z">
        <seg>완전히 상세한 공리적 증명은 너무 복잡하기 때문에, 증명 보조기의 문제점은 컴퓨터에 가능한 많이 상세한 것들을 두어야 한다는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Because the constructors are polymorphic over types, we have to insert the type <bpt i="0" x="0">&lt;c0&gt;</bpt>Nat<ept i="0">&lt;/c0&gt;</ept> as an argument repeatedly.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T074549Z" creationid="tlqk3" creationdate="20220131T074549Z">
        <seg>생성자들이 유형에 대해 다형적이기 때문에, 우리는 유형 <bpt i="0" x="0">&lt;c0&gt;</bpt>Nat<ept i="0">&lt;/c0&gt;</ept>를 인수로써 반복적으로 삽입해야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Both expressions denote the type of functions that take a natural number as input and return a natural number as output.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T041847Z" creationid="tlqk3" creationdate="20220131T041847Z">
        <seg>두 표현식 모두 자연수를 입력으로 받아 자연수를 출력으로 반환하는 함수 유형을 가리킵니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>But for straightforward constructions like the one above, when the type of <bpt i="0" x="0">&lt;c0&gt;</bpt>h<ept i="0">&lt;/c0&gt;</ept> and the goal of the construction are salient, the notation is clean and effective.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T170655Z" creationid="tlqk3" creationdate="20220211T170655Z">
        <seg>위와 같은 간단한 구성의 경우 <bpt i="0" x="0">&lt;c0&gt;</bpt>h<ept i="0">&lt;/c0&gt;</ept>의 유형과 구성의 목표가 두드러질 때 이 표기법은 깨끗하고 효과적입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>But it is very useful for building long proofs incrementally.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T152650Z" creationid="tlqk3" creationdate="20220211T152650Z">
        <seg>하지만 이것은 긴 증명을 점진적으로 만들어 나갈 때 유용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>But sometimes you will want to leave this information protected by a fully qualified name, for example, when they conflict with identifiers in another namespace you want to use.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T071417Z" creationid="tlqk3" creationdate="20220131T071417Z">
        <seg>그러나 때로는 당신이 사용할 다른 이름공간과 식별자가 충돌할 때 여러분이 이 정보가 완전히 자격을 갖춘 이름으로 보호되길 원할 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>But there is no reason to multiply languages in this way: dependent type theory is flexible and expressive, and there is no reason we cannot represent assertions and proofs in the same general framework.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T102116Z" creationid="tlqk3" creationdate="20220211T102116Z">
        <seg>그러나 의존유형론은 유연하고 표현력 있어 이런 식으로 언어들을 늘릴 이유는 없습니다. 그리고 주장과 증명은 한 동일한 일반적 프레임워크에서 표현하지 못할 이유도 없습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>But this information is redundant: one can infer the argument <bpt i="1" x="1">&lt;c1&gt;</bpt>α<ept i="1">&lt;/c1&gt;</ept> in <bpt i="2" x="2">&lt;c2&gt;</bpt>Lst.cons Nat 5 (Lst.nil Nat)<ept i="2">&lt;/c2&gt;</ept> from the fact that the second argument, <bpt i="3" x="3">&lt;c3&gt;</bpt>5<ept i="3">&lt;/c3&gt;</ept>, has type <bpt i="4" x="4">&lt;c4&gt;</bpt>Nat<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T074647Z" creationid="tlqk3" creationdate="20220131T074647Z">
        <seg>그러나 이 정보는 중복적입니다. <bpt i="2" x="2">&lt;c2&gt;</bpt>Lst.cons Nat 5 (Lst.nil Nat)<ept i="2">&lt;/c2&gt;</ept>에서 두번째 인수 <bpt i="3" x="3">&lt;c3&gt;</bpt>5<ept i="3">&lt;/c3&gt;</ept>가 <bpt i="4" x="4">&lt;c4&gt;</bpt>Nat<ept i="4">&lt;/c4&gt;</ept> 유형을 가진다는 사실로부터 인수 <bpt i="1" x="1">&lt;c1&gt;</bpt>α<ept i="1">&lt;/c1&gt;</ept>를 추론할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>But using the type annotations in the longer version makes the proof more readable, and can help catch and debug errors.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T172321Z" creationid="tlqk3" creationdate="20220211T172321Z">
        <seg>하지만 더 긴 버전의 유형 주석을 사용하는 것은 증명을 더 가독성있게 하 에러를 잡고 고치는 걸 도와줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>But we can still write <bpt i="1" x="1">&lt;c1&gt;</bpt>h.elim<ept i="1">&lt;/c1&gt;</ept> instead of <bpt i="2" x="2">&lt;c2&gt;</bpt>Or.elim h<ept i="2">&lt;/c2&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T172457Z" creationid="tlqk3" creationdate="20220211T172457Z">
        <seg>그러나 우리는 여전히 <bpt i="2" x="2">&lt;c2&gt;</bpt>Or.elim h<ept i="2">&lt;/c2&gt;</ept>대신 <bpt i="1" x="1">&lt;c1&gt;</bpt>h.elim<ept i="1">&lt;/c1&gt;</ept>와 같이 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>But what type should <bpt i="2" x="2">&lt;c2&gt;</bpt>cons<ept i="2">&lt;/c2&gt;</ept> have?</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T072957Z" creationid="tlqk3" creationdate="20220131T072957Z">
        <seg>그러나  <bpt i="2" x="2">&lt;c2&gt;</bpt>cons<ept i="2">&lt;/c2&gt;</ept> 는 어떤 유형을 가져야 할까요?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>By now, you have seen some ways of defining objects and functions in Lean.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T101532Z" creationid="tlqk3" creationdate="20220211T101532Z">
        <seg>지금까지, 여러분들은 린에서 객체와 함수를 정의하는 몇가지 방법을 배웠습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>By the end of this chapter, you will understand much of what this means.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T034444Z" creationid="tlqk3" creationdate="20220131T034444Z">
        <seg>2장의 끝에서 여러분은 이것의 의미하는 바의 대부분을 이해하게 될 겁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Change theme</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T073253Z" creationid="tlqk35" creationdate="20220130T073253Z">
        <seg>테마 바꾸기</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Classical Logic</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T175557Z" creationid="tlqk3" creationdate="20220211T175557Z">
        <seg>고전 논리</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Coal</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T073604Z" creationid="tlqk35" creationdate="20220130T073327Z">
        <seg>검은색</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Comment blocks can be nested, making it possible to "comment out" chunks of code, just as in many programming languages.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T035511Z" creationid="tlqk3" creationdate="20220131T035511Z">
        <seg>주석 블록은 중첩될 수 있으며 대부분의 프로그래밍 언어처럼 코드 조각을 "주석 처리"할 수 있게 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Commutativity:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T153718Z" creationid="tlqk3" creationdate="20220211T153718Z">
        <seg>교환성</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Computer algebra systems and specialized mathematical software packages provide means of carrying out mathematical computations, establishing mathematical bounds, or finding mathematical objects.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T101717Z" creationid="tlqk35" creationdate="20220130T090333Z">
        <seg>컴퓨터 대수 시스템(CAS, Computer Algebra Systems)과 특정 수학 소프트웨어 패키지는 수학 계산을 수행하고 수학적 한계를 세우며, 수학적 대상을 찾는 수단을 줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Computers and Theorem Proving</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T084146Z" creationid="tlqk35" creationdate="20220130T084146Z">
        <seg>컴퓨터와 정리 증명</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conjunction</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T163534Z" creationid="tlqk3" creationdate="20220211T163534Z">
        <seg>연결사</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Consider the following three function definitions:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T070433Z" creationid="tlqk3" creationdate="20220131T070433Z">
        <seg>다음 세 함수 정의를 생각해보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Constructing such proofs typically requires much more input and interaction from users, but it allows you to obtain deeper and more complex proofs.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T101632Z" creationid="tlqk35" creationdate="20220130T091035Z">
        <seg>전형적으로 이런 증명을 작성하는 것은 사용자에게 훨씬 많은 입력과 상호작용을 요구합니다. 그러나 이것은 우리가 더 깊고 복잡한 증명을 얻을 수 있게 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conversely, if you have <bpt i="6" x="6">&lt;c6&gt;</bpt>p : Nat × Nat<ept i="6">&lt;/c6&gt;</ept>, then you can write <bpt i="7" x="7">&lt;c7&gt;</bpt>p.1 : Nat<ept i="7">&lt;/c7&gt;</ept> and <bpt i="8" x="8">&lt;c8&gt;</bpt>p.2 : Nat<ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T044036Z" creationid="tlqk3" creationdate="20220131T044036Z">
        <seg>바낻로 여러분이 <bpt i="6" x="6">&lt;c6&gt;</bpt>p : Nat × Nat<ept i="6">&lt;/c6&gt;</ept>을 갖고 있다면 <bpt i="7" x="7">&lt;c7&gt;</bpt>p.1 : Nat<ept i="7">&lt;/c7&gt;</ept>과 <bpt i="8" x="8">&lt;c8&gt;</bpt>p.2 : Nat<ept i="8">&lt;/c8&gt;</ept>처럼 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conversely, the proof of a mathematical theorem may require a lengthy computation, in which case verifying the truth of the theorem requires verifying that the computation does what it is supposed to do.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T085011Z" creationid="tlqk35" creationdate="20220130T085011Z">
        <seg>반대로 수학적 정리의 증명은 긴 계산이 필요하는데 이 경우 정리의 참을 증명하는 건 계산한 것을 증명하는 걸 필요로 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Copy to clipboard</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T095843Z" creationid="tlqk35" creationdate="20220130T095843Z">
        <seg>클립보드에 복사하기</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creating a function from another expression is a process known as <bpt i="0" x="0">&lt;e0&gt;</bpt>lambda abstraction<ept i="0">&lt;/e0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T052639Z" creationid="tlqk3" creationdate="20220131T052639Z">
        <seg>다른 표현식으로부터 함수를 만드는 것은 <bpt i="0" x="0">&lt;e0&gt;</bpt>람다 추상화(lambda abstraction)<ept i="0">&lt;/e0&gt;</ept>과정으로 알려져 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Declaring an "axiom" <bpt i="0" x="0">&lt;c0&gt;</bpt>hp : p<ept i="0">&lt;/c0&gt;</ept> is tantamount to declaring that <bpt i="1" x="1">&lt;c1&gt;</bpt>p<ept i="1">&lt;/c1&gt;</ept> is true, as witnessed by <bpt i="2" x="2">&lt;c2&gt;</bpt>hp<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T152013Z" creationid="tlqk3" creationdate="20220211T152013Z">
        <seg>"공리" <bpt i="0" x="0">&lt;c0&gt;</bpt>hp : p<ept i="0">&lt;/c0&gt;</ept>를 선언하는 것은 <bpt i="2" x="2">&lt;c2&gt;</bpt>hp<ept i="2">&lt;/c2&gt;</ept>에서 본 바와 같이 <bpt i="1" x="1">&lt;c1&gt;</bpt>p<ept i="1">&lt;/c1&gt;</ept>가 참이라고 선언하는 것과 마찬가지입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Declaring new objects in this manner is a good way to experiment with the system.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T040236Z" creationid="tlqk3" creationdate="20220131T040236Z">
        <seg>이처럼 새로운 대상을 선언하는 것은 시스템을 실험해보는 좋은 방식입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Definition</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T154013Z" creationid="tlqk3" creationdate="20220211T154013Z">
        <seg>Definition(정의)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Definitions</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T064057Z" creationid="tlqk3" creationdate="20220131T064057Z">
        <seg>정의(Definitions)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Dependent Type Theory</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T102054Z" creationid="tlqk35" creationdate="20220130T102054Z">
        <seg>의존 유형론</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Dependent Type Theory - Theorem Proving in Lean 4</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T102027Z" creationid="tlqk35" creationdate="20220130T102027Z">
        <seg>의존 유형론 - 린4로 하는 정리 증명</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Dependent products are also called <bpt i="6" x="6">&lt;e6&gt;</bpt>sigma<ept i="6">&lt;/e6&gt;</ept> types, and you can also write them as <bpt i="7" x="7">&lt;c7&gt;</bpt>Σ a : α, β a<ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T074305Z" creationid="tlqk3" creationdate="20220131T074305Z">
        <seg>의존적 곱은 <bpt i="6" x="6">&lt;e6&gt;</bpt>sigma<ept i="6">&lt;/e6&gt;</ept>유형이라고 불립니다. 그리고 여러분은 그것을 <bpt i="7" x="7">&lt;c7&gt;</bpt>Σ a : α, β a<ept i="7">&lt;/c7&gt;</ept>처럼 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Dependent type theory is a powerful and expressive language, allowing you to express complex mathematical assertions, write complex hardware and software specifications, and reason about both of these in a natural and uniform way.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T034014Z" creationid="tlqk3" creationdate="20220131T034014Z">
        <seg>의존 유형론은 여러분이 복잡한 수학적 진술을 표현할 수 있게 하고, 복잡한 하드웨어와 소프트웨어 명제를 작성할 수 있게 하며 이 둘에 대해 자연스럽고 일관성있게 추론할 수 있게 하는 강력하고 표현력 있는 언어입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Determining that an expression <bpt i="0" x="0">&lt;c0&gt;</bpt>t<ept i="0">&lt;/c0&gt;</ept> is a correct proof of assertion <bpt i="1" x="1">&lt;c1&gt;</bpt>p<ept i="1">&lt;/c1&gt;</ept> would then simply be a matter of checking that <bpt i="2" x="2">&lt;c2&gt;</bpt>t<ept i="2">&lt;/c2&gt;</ept> has type <bpt i="3" x="3">&lt;c3&gt;</bpt>Proof p<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T141350Z" creationid="tlqk3" creationdate="20220211T134438Z">
        <seg>표현식 <bpt i="0" x="0">&lt;c0&gt;</bpt>t<ept i="0">&lt;/c0&gt;</ept>는 주장 <bpt i="1" x="1">&lt;c1&gt;</bpt>p<ept i="1">&lt;/c1&gt;</ept>의 올바른 증명이다를 결정하는 것은 <bpt i="2" x="2">&lt;c2&gt;</bpt>t<ept i="2">&lt;/c2&gt;</ept>가 <bpt i="3" x="3">&lt;c3&gt;</bpt>Proof p<ept i="3">&lt;/c3&gt;</ept>형임을 확인하는 문제가 됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Disjunction</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T171055Z" creationid="tlqk3" creationdate="20220211T171055Z">
        <seg>분리자</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Distributivity:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T153639Z" creationid="tlqk3" creationdate="20220211T153639Z">
        <seg>분배성</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Double-negation elimination allows one to prove any proposition, <bpt i="0" x="0">&lt;c0&gt;</bpt>p<ept i="0">&lt;/c0&gt;</ept>, by assuming <bpt i="1" x="1">&lt;c1&gt;</bpt>¬p<ept i="1">&lt;/c1&gt;</ept> and deriving <bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>, because that amounts to proving <bpt i="3" x="3">&lt;c3&gt;</bpt>¬¬p<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T162218Z" creationid="tlqk3" creationdate="20220211T162218Z">
        <seg>이중 부정 제거는 여러분에게 어떤 명제  <bpt i="0" x="0">&lt;c0&gt;</bpt>p<ept i="0">&lt;/c0&gt;</ept>에 대해서 <bpt i="1" x="1">&lt;c1&gt;</bpt>¬p<ept i="1">&lt;/c1&gt;</ept>를 가정하면 <bpt i="3" x="3">&lt;c3&gt;</bpt>¬¬p<ept i="3">&lt;/c3&gt;</ept>의 증명을 고려하기 때문에 <bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>를 유도할 수 있게 허용해 줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Editor shortcut</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T154008Z" creationid="tlqk3" creationdate="20220211T154008Z">
        <seg>Editor shortcut(편집 단축기)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Equality</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220222T153744Z" creationid="tlqk35" creationdate="20220222T153744Z">
        <seg>동등성</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Essentially, it just checks that the given term has the indicated type.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T164150Z" creationid="tlqk3" creationdate="20220211T164009Z">
        <seg>본질적으로 어떤 항이 가리키는 유형을 갖는 것을 확인합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Examples of Propositional Validities</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T161351Z" creationid="tlqk3" creationdate="20220211T161351Z">
        <seg>명제 유효성 예제</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Exercises</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T152314Z" creationid="tlqk3" creationdate="20220211T152314Z">
        <seg>연습문제</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>False</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T160012Z" creationid="tlqk3" creationdate="20220211T160012Z">
        <seg>거짓</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Finally, applying it to the hypothesis <bpt i="5" x="5">&lt;c5&gt;</bpt>hbc<ept i="5">&lt;/c5&gt;</ept> yields a proof of the conclusion <bpt i="6" x="6">&lt;c6&gt;</bpt>r a c<ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220222T145141Z" creationid="tlqk35" creationdate="20220222T145141Z">
        <seg>마침내, 이것을 가정 <bpt i="5" x="5">&lt;c5&gt;</bpt>hbc<ept i="5">&lt;/c5&gt;</ept>에 적용하는 것으로 결론 <bpt i="6" x="6">&lt;c6&gt;</bpt>r a c<ept i="6">&lt;/c6&gt;</ept>의 증명을 거둡니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Finally, we have to show <bpt i="4" x="4">&lt;c4&gt;</bpt>q<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T175548Z" creationid="tlqk3" creationdate="20220211T175548Z">
        <seg>마지막으로 <bpt i="4" x="4">&lt;c4&gt;</bpt>q<ept i="4">&lt;/c4&gt;</ept>임을 보여야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Finally, you will learn about features that are specific to Lean, including the language you use to communicate with the system, and the mechanisms Lean offers for managing complex theories and data.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T101200Z" creationid="tlqk35" creationdate="20220130T095614Z">
        <seg>마지막으로 린에 여러분이 시스템과 소통하기 위해 사용하는 언어와 복잡한 이론과 자료를 관리하기 위해 린이 제공하는 메커니즘을 포함하는 구체적인 특징에 대해 배웁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>First, the application of a function <bpt i="0" x="0">&lt;c0&gt;</bpt>f<ept i="0">&lt;/c0&gt;</ept> to a value <bpt i="1" x="1">&lt;c1&gt;</bpt>x<ept i="1">&lt;/c1&gt;</ept> is denoted <bpt i="2" x="2">&lt;c2&gt;</bpt>f x<ept i="2">&lt;/c2&gt;</ept> (e.g., <bpt i="3" x="3">&lt;c3&gt;</bpt>Nat.succ 2<ept i="3">&lt;/c3&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T042554Z" creationid="tlqk3" creationdate="20220131T042554Z">
        <seg>우선 함수 <bpt i="0" x="0">&lt;c0&gt;</bpt>f<ept i="0">&lt;/c0&gt;</ept>에 값 <bpt i="1" x="1">&lt;c1&gt;</bpt>x<ept i="1">&lt;/c1&gt;</ept>의 활용은 <bpt i="2" x="2">&lt;c2&gt;</bpt>f x<ept i="2">&lt;/c2&gt;</ept> 를 지칭합니다. (예를 들어 <bpt i="3" x="3">&lt;c3&gt;</bpt>Nat.succ 2<ept i="3">&lt;/c3&gt;</ept>)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>First, we have to show that it indeed suffices to show <bpt i="1" x="1">&lt;c1&gt;</bpt>q<ept i="1">&lt;/c1&gt;</ept>, by proving the original goal of <bpt i="2" x="2">&lt;c2&gt;</bpt>q ∧ p<ept i="2">&lt;/c2&gt;</ept> with the additional hypothesis <bpt i="3" x="3">&lt;c3&gt;</bpt>hq : q<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T175530Z" creationid="tlqk3" creationdate="20220211T175530Z">
        <seg>첫 째, 우리는 원래 목표<bpt i="2" x="2">&lt;c2&gt;</bpt>q ∧ p<ept i="2">&lt;/c2&gt;</ept> 과 추가적인 가정 <bpt i="3" x="3">&lt;c3&gt;</bpt>hq : q<ept i="3">&lt;/c3&gt;</ept>으로 증명함으로써 <bpt i="1" x="1">&lt;c1&gt;</bpt>q<ept i="1">&lt;/c1&gt;</ept>임을 충분히 보일 수 있는 것을 보여야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For another example, consider the type <bpt i="4" x="4">&lt;c4&gt;</bpt>Vector α n<ept i="4">&lt;/c4&gt;</ept>, the type of vectors of elements of <bpt i="5" x="5">&lt;c5&gt;</bpt>α<ept i="5">&lt;/c5&gt;</ept> of length <bpt i="6" x="6">&lt;c6&gt;</bpt>n<ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T072259Z" creationid="tlqk3" creationdate="20220131T072259Z">
        <seg>또 다른 예시로 유형 <bpt i="4" x="4">&lt;c4&gt;</bpt>Vector α n<ept i="4">&lt;/c4&gt;</ept>을 고려해보세요. 이 벡터의 유형은 길이 <bpt i="6" x="6">&lt;c6&gt;</bpt>n<ept i="6">&lt;/c6&gt;</ept>인 <bpt i="5" x="5">&lt;c5&gt;</bpt>α<ept i="5">&lt;/c5&gt;</ept>를 원소로 하는 리스트입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For every <bpt i="3" x="3">&lt;c3&gt;</bpt>p q : Prop<ept i="3">&lt;/c3&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>p ∧ q<ept i="4">&lt;/c4&gt;</ept> is an example: the canonical way to construct an element is to apply <bpt i="5" x="5">&lt;c5&gt;</bpt>And.intro<ept i="5">&lt;/c5&gt;</ept> to suitable arguments <bpt i="6" x="6">&lt;c6&gt;</bpt>hp : p<ept i="6">&lt;/c6&gt;</ept> and <bpt i="7" x="7">&lt;c7&gt;</bpt>hq : q<ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T165448Z" creationid="tlqk3" creationdate="20220211T165448Z">
        <seg>모든 <bpt i="3" x="3">&lt;c3&gt;</bpt>p q : Prop<ept i="3">&lt;/c3&gt;</ept>에 대해 <bpt i="4" x="4">&lt;c4&gt;</bpt>p ∧ q<ept i="4">&lt;/c4&gt;</ept>가 예제입니다. 원소를 생성하는 정식 방법은 <bpt i="5" x="5">&lt;c5&gt;</bpt>And.intro<ept i="5">&lt;/c5&gt;</ept>를 적절한 인수 <bpt i="6" x="6">&lt;c6&gt;</bpt>hp : p<ept i="6">&lt;/c6&gt;</ept>과 <bpt i="7" x="7">&lt;c7&gt;</bpt>hq : q<ept i="7">&lt;/c7&gt;</ept>에 대해 적용하는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, <bpt i="1" x="1">&lt;c1&gt;</bpt>List α<ept i="1">&lt;/c1&gt;</ept> should make sense for any type <bpt i="2" x="2">&lt;c2&gt;</bpt>α<ept i="2">&lt;/c2&gt;</ept>, no matter which type universe <bpt i="3" x="3">&lt;c3&gt;</bpt>α<ept i="3">&lt;/c3&gt;</ept> lives in.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T051006Z" creationid="tlqk3" creationdate="20220131T051006Z">
        <seg>예를 들어 <bpt i="3" x="3">&lt;c3&gt;</bpt>α<ept i="3">&lt;/c3&gt;</ept>가 어떤 유형 세계에 있던간에 <bpt i="1" x="1">&lt;c1&gt;</bpt>List α<ept i="1">&lt;/c1&gt;</ept>는 임의의 유형 <bpt i="2" x="2">&lt;c2&gt;</bpt>α<ept i="2">&lt;/c2&gt;</ept>에 대해 의미가 있어야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, <bpt i="5" x="5">&lt;c5&gt;</bpt>a ∧ b → c ∨ d ∧ e<ept i="5">&lt;/c5&gt;</ept> means <bpt i="6" x="6">&lt;c6&gt;</bpt>(a ∧ b) → (c ∨ (d ∧ e))<ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T160558Z" creationid="tlqk3" creationdate="20220211T160558Z">
        <seg>예를 들어 <bpt i="5" x="5">&lt;c5&gt;</bpt>a ∧ b → c ∨ d ∧ e<ept i="5">&lt;/c5&gt;</ept>은 <bpt i="6" x="6">&lt;c6&gt;</bpt>(a ∧ b) → (c ∨ (d ∧ e))<ept i="6">&lt;/c6&gt;</ept>을 의미합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, Lean groups definitions and theorems involving lists into a namespace <bpt i="0" x="0">&lt;c0&gt;</bpt>List<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T071513Z" creationid="tlqk3" creationdate="20220131T071513Z">
        <seg>예를 들어 Lean은 이름공간 <bpt i="0" x="0">&lt;c0&gt;</bpt>List<ept i="0">&lt;/c0&gt;</ept> 속에 리스트를 포함한 정의와 정리를 묶습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, if <bpt i="0" x="0">&lt;c0&gt;</bpt>a<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>b<ept i="1">&lt;/c1&gt;</ept> are types, <bpt i="2" x="2">&lt;c2&gt;</bpt>a -&gt; b<ept i="2">&lt;/c2&gt;</ept> denotes the type of functions from <bpt i="3" x="3">&lt;c3&gt;</bpt>a<ept i="3">&lt;/c3&gt;</ept> to <bpt i="4" x="4">&lt;c4&gt;</bpt>b<ept i="4">&lt;/c4&gt;</ept>, and <bpt i="5" x="5">&lt;c5&gt;</bpt>a × b<ept i="5">&lt;/c5&gt;</ept> denotes the type of pairs consisting of an element of <bpt i="6" x="6">&lt;c6&gt;</bpt>a<ept i="6">&lt;/c6&gt;</ept> paired with an element of <bpt i="7" x="7">&lt;c7&gt;</bpt>b<ept i="7">&lt;/c7&gt;</ept>, also known as the <bpt i="8" x="8">&lt;e8&gt;</bpt>Cartesian product<ept i="8">&lt;/e8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T040748Z" creationid="tlqk3" creationdate="20220131T040748Z">
        <seg>예를 들어 <bpt i="0" x="0">&lt;c0&gt;</bpt>a<ept i="0">&lt;/c0&gt;</ept>와 <bpt i="1" x="1">&lt;c1&gt;</bpt>b<ept i="1">&lt;/c1&gt;</ept>가 유형이라면 <bpt i="2" x="2">&lt;c2&gt;</bpt>a -&gt; b<ept i="2">&lt;/c2&gt;</ept>는 <bpt i="3" x="3">&lt;c3&gt;</bpt>a<ept i="3">&lt;/c3&gt;</ept> 에서 <bpt i="4" x="4">&lt;c4&gt;</bpt>b<ept i="4">&lt;/c4&gt;</ept>로 가는 함수 유형을 나타냅니다. 그리고 <bpt i="5" x="5">&lt;c5&gt;</bpt>a × b<ept i="5">&lt;/c5&gt;</ept> 는 <bpt i="6" x="6">&lt;c6&gt;</bpt>a<ept i="6">&lt;/c6&gt;</ept>의 원소와 <bpt i="7" x="7">&lt;c7&gt;</bpt>b<ept i="7">&lt;/c7&gt;</ept>의 원소로 이뤄진 쌍을 원소로 갖는 유형을 나타냅니다. 이것을 <bpt i="8" x="8">&lt;e8&gt;</bpt>카테시안 곱<ept i="8">&lt;/e8&gt;</ept>이라 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, in a given context, <bpt i="1" x="1">&lt;c1&gt;</bpt>x + 0<ept i="1">&lt;/c1&gt;</ept> may denote a natural number and <bpt i="2" x="2">&lt;c2&gt;</bpt>f<ept i="2">&lt;/c2&gt;</ept> may denote a function on the natural numbers.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T034646Z" creationid="tlqk3" creationdate="20220131T034646Z">
        <seg>예를들어 어떤 맥락에서 <bpt i="1" x="1">&lt;c1&gt;</bpt>x + 0<ept i="1">&lt;/c1&gt;</ept>은 자연수를 가리키고  <bpt i="2" x="2">&lt;c2&gt;</bpt>f<ept i="2">&lt;/c2&gt;</ept>은 자연수에 대한 함수를 지칭합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, in many proof systems for propositional logic, we have the rule of modus ponens:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T102700Z" creationid="tlqk3" creationdate="20220211T102700Z">
        <seg>예를 들어 명제논리에 대한 많은 증명보조기들은 전건긍정(modus ponens)에 대한 규칙을 갖고 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, it allows you to "partially apply" the function <bpt i="10" x="10">&lt;c10&gt;</bpt>Nat.add<ept i="10">&lt;/c10&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T043314Z" creationid="tlqk3" creationdate="20220131T043314Z">
        <seg>예를 들어 이는 여러분에게 함수 <bpt i="10" x="10">&lt;c10&gt;</bpt>Nat.add<ept i="10">&lt;/c10&gt;</ept>의 "부분 적용"을 허용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, one can carry out a proof by cases:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T161733Z" creationid="tlqk3" creationdate="20220211T161733Z">
        <seg>예를 들어 누군가는 경우를 나눠 증명을 도출할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, term rewriting, and Lean's automated methods for simplifying terms and expressions automatically.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T101214Z" creationid="tlqk35" creationdate="20220130T095434Z">
        <seg>예를 들어, 항을 다시 쓰기(rewriting)와 Lean의 자동화된 항과 식의 단순화(simplifying) 기법</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, the following two expressions mean the same thing:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T170046Z" creationid="tlqk3" creationdate="20220211T170046Z">
        <seg>예를 들어 다음 두 표현식은 같은 것을 의미합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, the variable <bpt i="3" x="3">&lt;c3&gt;</bpt>b<ept i="3">&lt;/c3&gt;</ept> in the expression <bpt i="4" x="4">&lt;c4&gt;</bpt>fun (b : β) (x : α) =&gt; b<ept i="4">&lt;/c4&gt;</ept> has nothing to do with the constant <bpt i="5" x="5">&lt;c5&gt;</bpt>b<ept i="5">&lt;/c5&gt;</ept> declared earlier.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T055341Z" creationid="tlqk3" creationdate="20220131T055341Z">
        <seg>예를 들어 표현식 <bpt i="4" x="4">&lt;c4&gt;</bpt>fun (b : β) (x : α) =&gt; b<ept i="4">&lt;/c4&gt;</ept> 속 변수 <bpt i="3" x="3">&lt;c3&gt;</bpt>b<ept i="3">&lt;/c3&gt;</ept>는 앞서 선언된 상수 <bpt i="5" x="5">&lt;c5&gt;</bpt>b<ept i="5">&lt;/c5&gt;</ept>와는 아무런 연관이 없습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, we can use it to postulate the empty type <bpt i="1" x="1">&lt;c1&gt;</bpt>False<ept i="1">&lt;/c1&gt;</ept> has an element.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T151734Z" creationid="tlqk3" creationdate="20220211T151727Z">
        <seg>예를 들어 우리는 그것을 빈 유형 <bpt i="1" x="1">&lt;c1&gt;</bpt>False<ept i="1">&lt;/c1&gt;</ept>이 원소를 갖는다고 가정하는데 사용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, we could introduce a new type, <bpt i="0" x="0">&lt;c0&gt;</bpt>Prop<ept i="0">&lt;/c0&gt;</ept>, to represent propositions, and introduce constructors to build new propositions from others.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T102254Z" creationid="tlqk3" creationdate="20220211T102222Z">
        <seg>예를 들어, 우리는 새로운 유형 <bpt i="0" x="0">&lt;c0&gt;</bpt>Prop<ept i="0">&lt;/c0&gt;</ept>을 명제를 나타내기 위해 도입할 수 있습니다. 그리고 다른 유형으로부터 새로운 명제를 만드는 생성자를 도입할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T065645Z" creationid="tlqk3" creationdate="20220131T065645Z">
        <seg>예를 들어</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For now, notice that this is an important feature of dependent type theory: every term has a computational behavior, and supports a notion of <bpt i="0" x="0">&lt;e0&gt;</bpt>normalization<ept i="0">&lt;/e0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T060738Z" creationid="tlqk3" creationdate="20220131T060738Z">
        <seg>현재로써는 이게 의존 유형론의 중요한 특징인 것만 알아 두세요. 모든 항은 전산적 거동을 하고 <bpt i="0" x="0">&lt;e0&gt;</bpt>정규화(normalization)<ept i="0">&lt;/e0&gt;</ept>의 개념을 지원합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For reference, here are two sample proofs of validities taken from the list above.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T153442Z" creationid="tlqk3" creationdate="20220211T153442Z">
        <seg>참고로 여기 위쪽의 리스트에서 가져온 유효성의 증명 예시가 두 개 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For that purpose, Lean provides the notion of a <bpt i="0" x="0">&lt;c0&gt;</bpt>section<ept i="0">&lt;/c0&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T070806Z" creationid="tlqk3" creationdate="20220131T070806Z">
        <seg>이를 위해 Lean은  <bpt i="0" x="0">&lt;c0&gt;</bpt>section<ept i="0">&lt;/c0&gt;</ept>의 개념을 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For that reason, it is common to make these arguments implicit:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220222T145330Z" creationid="tlqk35" creationdate="20220222T145330Z">
        <seg>이런 이유로 이런 인자를 암시적으로 만드는 것은 흔합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For that to be the case, each of them also has to have a type.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T045050Z" creationid="tlqk3" creationdate="20220131T045050Z">
        <seg>이렇게 하는 경우에 대해 그들 각각은 유형을 가져야만 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For those who like precise definitions, a Lean natural number is an arbitrary-precision unsigned integer.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T034737Z" creationid="tlqk3" creationdate="20220131T034737Z">
        <seg>엄밀한 정의를 좋아하는 이들에게 린의 자연수는 부호없는 임의 정밀도의 정수입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Formally, expressions that are the same up to a renaming of bound variables are called <bpt i="0" x="0">&lt;e0&gt;</bpt>alpha equivalent<ept i="0">&lt;/e0&gt;</ept>, and are considered "the same." Lean recognizes this equivalence.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T055756Z" creationid="tlqk3" creationdate="20220131T055756Z">
        <seg>공식적으로 구속 변수의 이름이 바뀌기까지 같은 표현식은 <bpt i="0" x="0">&lt;e0&gt;</bpt>알파 등가(alpha equivalent)<ept i="0">&lt;/e0&gt;</ept>라 하고 "같은" 것으로 생각합니다. 린도 이를 등가로 인식합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>From a proof of <bpt i="0" x="0">&lt;c0&gt;</bpt>Implies p q<ept i="0">&lt;/c0&gt;</ept> and a proof of <bpt i="1" x="1">&lt;c1&gt;</bpt>p<ept i="1">&lt;/c1&gt;</ept>, we obtain a proof of <bpt i="2" x="2">&lt;c2&gt;</bpt>q<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T102750Z" creationid="tlqk3" creationdate="20220211T102750Z">
        <seg>증명 <bpt i="0" x="0">&lt;c0&gt;</bpt>Implies p q<ept i="0">&lt;/c0&gt;</ept>과 증명<bpt i="1" x="1">&lt;c1&gt;</bpt>p<ept i="1">&lt;/c1&gt;</ept>으로부터 우리는 증명 <bpt i="2" x="2">&lt;c2&gt;</bpt>q<ept i="2">&lt;/c2&gt;</ept>을 얻을 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>From the constructive point of view, proofs are abstract mathematical objects that are <bpt i="0" x="0">&lt;e0&gt;</bpt>denoted<ept i="0">&lt;/e0&gt;</ept> by suitable expressions in dependent type theory.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T143131Z" creationid="tlqk3" creationdate="20220211T143131Z">
        <seg>직관주의자의 관점에서 증명은 의존 유형론의 적절한 표현식으로 <bpt i="0" x="0">&lt;e0&gt;</bpt>표기된<ept i="0">&lt;/e0&gt;</ept>추상적인 수학적 대상입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Function Abstraction and Evaluation</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T052259Z" creationid="tlqk3" creationdate="20220131T052259Z">
        <seg>함수 추상화와 함수값의 평가</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Git repository</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T073706Z" creationid="tlqk35" creationdate="20220130T073706Z">
        <seg>깃 저장소</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Given <bpt i="2" x="2">&lt;c2&gt;</bpt>α : Type<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>β : α → Type<ept i="3">&lt;/c3&gt;</ept>, think of <bpt i="4" x="4">&lt;c4&gt;</bpt>β<ept i="4">&lt;/c4&gt;</ept> as a family of types over <bpt i="5" x="5">&lt;c5&gt;</bpt>α<ept i="5">&lt;/c5&gt;</ept>, that is, a type <bpt i="6" x="6">&lt;c6&gt;</bpt>β a<ept i="6">&lt;/c6&gt;</ept> for each <bpt i="7" x="7">&lt;c7&gt;</bpt>a : α<ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T073557Z" creationid="tlqk3" creationdate="20220131T073557Z">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>α : Type<ept i="2">&lt;/c2&gt;</ept>과<bpt i="3" x="3">&lt;c3&gt;</bpt>β : α → Type<ept i="3">&lt;/c3&gt;</ept>이라면, <bpt i="4" x="4">&lt;c4&gt;</bpt>β<ept i="4">&lt;/c4&gt;</ept>를 <bpt i="5" x="5">&lt;c5&gt;</bpt>α<ept i="5">&lt;/c5&gt;</ept>에 대한 유형 족(family)으로 생각할 수 있습니다. 즉, 각각의 <bpt i="7" x="7">&lt;c7&gt;</bpt>a : α<ept i="7">&lt;/c7&gt;</ept>에 대해 <bpt i="6" x="6">&lt;c6&gt;</bpt>β a<ept i="6">&lt;/c6&gt;</ept>유형입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Given a proof <bpt i="0" x="0">&lt;c0&gt;</bpt>∀ x : α, p x<ept i="0">&lt;/c0&gt;</ept> and any term <bpt i="1" x="1">&lt;c1&gt;</bpt>t : α<ept i="1">&lt;/c1&gt;</ept>, we obtain a proof of <bpt i="2" x="2">&lt;c2&gt;</bpt>p t<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220222T142132Z" creationid="tlqk35" creationdate="20220222T142125Z">
        <seg>증명 <bpt i="0" x="0">&lt;c0&gt;</bpt>∀ x : α, p x<ept i="0">&lt;/c0&gt;</ept>과 임의의 항 <bpt i="1" x="1">&lt;c1&gt;</bpt>t : α<ept i="1">&lt;/c1&gt;</ept>이 있다고 하자, 그러면 우리는 <bpt i="2" x="2">&lt;c2&gt;</bpt>p t<ept i="2">&lt;/c2&gt;</ept>의 증명을 얻는다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Given a proof of <bpt i="0" x="0">&lt;c0&gt;</bpt>p x<ept i="0">&lt;/c0&gt;</ept>, in a context where <bpt i="1" x="1">&lt;c1&gt;</bpt>x : α<ept i="1">&lt;/c1&gt;</ept> is arbitrary, we obtain a proof <bpt i="2" x="2">&lt;c2&gt;</bpt>∀ x : α, p x<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220222T141957Z" creationid="tlqk35" creationdate="20220222T141957Z">
        <seg>임의의 <bpt i="1" x="1">&lt;c1&gt;</bpt>x : α<ept i="1">&lt;/c1&gt;</ept>의 상황에서 <bpt i="0" x="0">&lt;c0&gt;</bpt>p x<ept i="0">&lt;/c0&gt;</ept>의 증명이 주여졌다고 하자, 그러면 우리는 증명 <bpt i="2" x="2">&lt;c2&gt;</bpt>∀ x : α, p x<ept i="2">&lt;/c2&gt;</ept>을 얻는다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Given a term <bpt i="0" x="0">&lt;c0&gt;</bpt>s : (x : α) → β x<ept i="0">&lt;/c0&gt;</ept> and any term <bpt i="1" x="1">&lt;c1&gt;</bpt>t : α<ept i="1">&lt;/c1&gt;</ept>, we have <bpt i="2" x="2">&lt;c2&gt;</bpt>s t : β t<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220222T142458Z" creationid="tlqk35" creationdate="20220222T142458Z">
        <seg>항 <bpt i="0" x="0">&lt;c0&gt;</bpt>s : (x : α) → β x<ept i="0">&lt;/c0&gt;</ept>과 임의의 항 <bpt i="1" x="1">&lt;c1&gt;</bpt>t : α<ept i="1">&lt;/c1&gt;</ept>이 주어졌다고 해봅시다. 그러면 우리는 <bpt i="2" x="2">&lt;c2&gt;</bpt>s t : β t<ept i="2">&lt;/c2&gt;</ept>을 가집니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Given a term <bpt i="0" x="0">&lt;c0&gt;</bpt>t<ept i="0">&lt;/c0&gt;</ept> of type <bpt i="1" x="1">&lt;c1&gt;</bpt>β x<ept i="1">&lt;/c1&gt;</ept>, in a context where <bpt i="2" x="2">&lt;c2&gt;</bpt>x : α<ept i="2">&lt;/c2&gt;</ept> is arbitrary, we have <bpt i="3" x="3">&lt;c3&gt;</bpt>(fun x : α =&gt; t) : (x : α) → β x<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220222T142350Z" creationid="tlqk35" creationdate="20220222T142350Z">
        <seg> <bpt i="1" x="1">&lt;c1&gt;</bpt>β x<ept i="1">&lt;/c1&gt;</ept>형의 항 <bpt i="0" x="0">&lt;c0&gt;</bpt>t<ept i="0">&lt;/c0&gt;</ept> 임의의 <bpt i="2" x="2">&lt;c2&gt;</bpt>x : α<ept i="2">&lt;/c2&gt;</ept>에 대해서 주어졌다고 해봅시다. 그러면 우리는 c3&gt;(fun x : α =&gt; t) : (x : α) → β x<it pos="end" x="3">&lt;/c3&gt;</it>을 갖습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Given an expression <bpt i="0" x="0">&lt;c0&gt;</bpt>e<ept i="0">&lt;/c0&gt;</ept> of an inductive type <bpt i="1" x="1">&lt;c1&gt;</bpt>Foo<ept i="1">&lt;/c1&gt;</ept> (possibly applied to some arguments), the notation <bpt i="2" x="2">&lt;c2&gt;</bpt>e.bar<ept i="2">&lt;/c2&gt;</ept> is shorthand for <bpt i="3" x="3">&lt;c3&gt;</bpt>Foo.bar e<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T170004Z" creationid="tlqk3" creationdate="20220211T170004Z">
        <seg>(아마 몇 가지 인수를 적용한) 유도형이 <bpt i="1" x="1">&lt;c1&gt;</bpt>Foo<ept i="1">&lt;/c1&gt;</ept>인 표현식 <bpt i="0" x="0">&lt;c0&gt;</bpt>e<ept i="0">&lt;/c0&gt;</ept>에 대해 <bpt i="2" x="2">&lt;c2&gt;</bpt>e.bar<ept i="2">&lt;/c2&gt;</ept>과 같은 표기는 <bpt i="3" x="3">&lt;c3&gt;</bpt>Foo.bar e<ept i="3">&lt;/c3&gt;</ept>의 약식 표현입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Given that every expression in Lean has a type, it is natural to ask: what type does <bpt i="0" x="0">&lt;c0&gt;</bpt>Type<ept i="0">&lt;/c0&gt;</ept> itself have?</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T045833Z" creationid="tlqk3" creationdate="20220131T045833Z">
        <seg>린의 모든 표현식이 유형을 가진다면 <bpt i="0" x="0">&lt;c0&gt;</bpt>Type<ept i="0">&lt;/c0&gt;</ept> 그 자체는 어떤 유형을 가져야 하는지 궁금한게 당연합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here <bpt i="0" x="0">&lt;c0&gt;</bpt>u_1<ept i="0">&lt;/c0&gt;</ept> is a variable ranging over type levels.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T051618Z" creationid="tlqk3" creationdate="20220131T051236Z">
        <seg>여기서 <bpt i="0" x="0">&lt;c0&gt;</bpt>u_1<ept i="0">&lt;/c0&gt;</ept>는 어떤 유형 세계에 대한 변수입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here are some examples of how you can declare objects in Lean and check their types.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T034842Z" creationid="tlqk3" creationdate="20220131T034842Z">
        <seg>린에서 여러분이 객체를 어떻게 선언하고 그들의 유형을 확인할 수 있는지 몇 가지 예제가 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here are some more examples</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T053125Z" creationid="tlqk3" creationdate="20220131T053125Z">
        <seg>여기 추가 예제가 더 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here is a proof of <bpt i="10" x="10">&lt;c10&gt;</bpt>p ∧ q ↔ q ∧ p<ept i="10">&lt;/c10&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T174129Z" creationid="tlqk3" creationdate="20220211T174129Z">
        <seg>여기 <bpt i="10" x="10">&lt;c10&gt;</bpt>p ∧ q ↔ q ∧ p<ept i="10">&lt;/c10&gt;</ept>의 증명이 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here is a small example, adapted from the last section:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T175209Z" creationid="tlqk3" creationdate="20220211T174612Z">
        <seg>여기 이전 장에서 가져온 작은 예제가 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here is an example of how the propositions-as-types correspondence gets put into practice.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220222T143704Z" creationid="tlqk35" creationdate="20220222T143704Z">
        <seg>여기에 유형으로써 명제 대응이 현장에서 어떻게 놓이는지에 대한 예제가 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here is an example of how we can carry out elementary reasoning with an equivalence relation:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220222T145705Z" creationid="tlqk35" creationdate="20220222T145705Z">
        <seg>이곳은 우리가 어떻게 동등 관계로 초등적인 추론을 하는지 예시를 보여줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here is another example: given any type <bpt i="0" x="0">&lt;c0&gt;</bpt>α<ept i="0">&lt;/c0&gt;</ept>, the type <bpt i="1" x="1">&lt;c1&gt;</bpt>List α<ept i="1">&lt;/c1&gt;</ept> denotes the type of lists of elements of type <bpt i="2" x="2">&lt;c2&gt;</bpt>α<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T045724Z" creationid="tlqk3" creationdate="20220131T045724Z">
        <seg>또 다른 예제가 있습니다. <bpt i="0" x="0">&lt;c0&gt;</bpt>α<ept i="0">&lt;/c0&gt;</ept>라 하는 임의의 타입에 대해 <bpt i="1" x="1">&lt;c1&gt;</bpt>List α<ept i="1">&lt;/c1&gt;</ept>의 유형은 <bpt i="2" x="2">&lt;c2&gt;</bpt>α<ept i="2">&lt;/c2&gt;</ept> 유형을 원소로 하는 리스트 유형을 가리킵니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here is another useful trick.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T152937Z" creationid="tlqk3" creationdate="20220211T152937Z">
        <seg>여기 또 유용한 트릭이 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here, <bpt i="0" x="0">&lt;c0&gt;</bpt>twice_double x<ept i="0">&lt;/c0&gt;</ept> is definitionally equal to the term <bpt i="1" x="1">&lt;c1&gt;</bpt>(x + x) * (x + x)<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T065932Z" creationid="tlqk3" creationdate="20220131T065932Z">
        <seg>여기서<bpt i="0" x="0">&lt;c0&gt;</bpt>twice_double x<ept i="0">&lt;/c0&gt;</ept>도 항  <bpt i="1" x="1">&lt;c1&gt;</bpt>(x + x) * (x + x)<ept i="1">&lt;/c1&gt;</ept>과 정의상으로 같습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here, for example, is a proof of <bpt i="0" x="0">&lt;c0&gt;</bpt>¬p → q → (q → p) → r<ept i="0">&lt;/c0&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T173646Z" creationid="tlqk3" creationdate="20220211T173646Z">
        <seg>여기 <bpt i="0" x="0">&lt;c0&gt;</bpt>¬p → q → (q → p) → r<ept i="0">&lt;/c0&gt;</ept>의 증명에 대한 예제가 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here, the <bpt i="0" x="0">&lt;c0&gt;</bpt>axiom<ept i="0">&lt;/c0&gt;</ept> declaration postulates the existence of an element of the given type and may compromise logical consistency.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T151645Z" creationid="tlqk3" creationdate="20220211T151645Z">
        <seg>여기서 <bpt i="0" x="0">&lt;c0&gt;</bpt>axiom<ept i="0">&lt;/c0&gt;</ept> 선언은 주어진 유형의 원소의 존재성을 가정하고 논리적 일관성을 타협할지도 모릅니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>foo<ept i="0">&lt;/c0&gt;</ept> is such a function, the notation <bpt i="1" x="1">&lt;c1&gt;</bpt>@foo<ept i="1">&lt;/c1&gt;</ept> denotes the same function with all the arguments made explicit.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T080250Z" creationid="tlqk3" creationdate="20220131T080250Z">
        <seg>만약 <bpt i="0" x="0">&lt;c0&gt;</bpt>foo<ept i="0">&lt;/c0&gt;</ept>가 그런 함수라면 <bpt i="1" x="1">&lt;c1&gt;</bpt>@foo<ept i="1">&lt;/c1&gt;</ept> 표기는 모든 인수가 명시적으로 된 같은 함수를 지칭합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>j<ept i="0">&lt;/c0&gt;</ept> is not <bpt i="1" x="1">&lt;c1&gt;</bpt>0<ept i="1">&lt;/c1&gt;</ept>, then <bpt i="2" x="2">&lt;c2&gt;</bpt>(x : α) → β<ept i="2">&lt;/c2&gt;</ept> is an element of <bpt i="3" x="3">&lt;c3&gt;</bpt>Sort (max i j)<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220222T150439Z" creationid="tlqk35" creationdate="20220222T150439Z">
        <seg>만약 <bpt i="0" x="0">&lt;c0&gt;</bpt>j<ept i="0">&lt;/c0&gt;</ept>가 <bpt i="1" x="1">&lt;c1&gt;</bpt>0<ept i="1">&lt;/c1&gt;</ept>이 아니라면 <bpt i="2" x="2">&lt;c2&gt;</bpt>(x : α) → β<ept i="2">&lt;/c2&gt;</ept>는 <bpt i="3" x="3">&lt;c3&gt;</bpt>Sort (max i j)<ept i="3">&lt;/c3&gt;</ept>의 원소이다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>p<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>q<ept i="1">&lt;/c1&gt;</ept> have been declared as variables, Lean will generalize them for us automatically:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T154743Z" creationid="tlqk3" creationdate="20220211T154743Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>p<ept i="0">&lt;/c0&gt;</ept>와 <bpt i="1" x="1">&lt;c1&gt;</bpt>q<ept i="1">&lt;/c1&gt;</ept>가 변수로 선언되었다면 린은 우리를 위해 자동적으로 일반화시킬 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>p<ept i="0">&lt;/c0&gt;</ept> is any expression, <bpt i="1" x="1">&lt;c1&gt;</bpt>∀ x : α, p<ept i="1">&lt;/c1&gt;</ept> is nothing more than alternative notation for <bpt i="2" x="2">&lt;c2&gt;</bpt>(x : α) → p<ept i="2">&lt;/c2&gt;</ept>, with the idea that the former is more natural than the latter in cases where <bpt i="3" x="3">&lt;c3&gt;</bpt>p<ept i="3">&lt;/c3&gt;</ept> is a proposition.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220222T142948Z" creationid="tlqk35" creationdate="20220222T142948Z">
        <seg>만약 <bpt i="0" x="0">&lt;c0&gt;</bpt>p<ept i="0">&lt;/c0&gt;</ept>가 임의의 표현식이면, <bpt i="1" x="1">&lt;c1&gt;</bpt>∀ x : α, p<ept i="1">&lt;/c1&gt;</ept>은 그저 <bpt i="2" x="2">&lt;c2&gt;</bpt>(x : α) → p<ept i="2">&lt;/c2&gt;</ept>에 대한 대체 표현일 뿐입니다. 전자의 생각은  <bpt i="3" x="3">&lt;c3&gt;</bpt>p<ept i="3">&lt;/c3&gt;</ept>가 명제인 후자의 경우보다 자연스럽습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="1" x="1">&lt;c1&gt;</bpt>RH<ept i="1">&lt;/c1&gt;</ept> represents the Riemann hypothesis, a classical mathematician is willing to assert <bpt i="2" x="2">&lt;c2&gt;</bpt>RH ∨ ¬RH<ept i="2">&lt;/c2&gt;</ept>, even though we cannot yet assert either disjunct.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T180154Z" creationid="tlqk3" creationdate="20220211T180154Z">
        <seg>만약 <bpt i="1" x="1">&lt;c1&gt;</bpt>RH<ept i="1">&lt;/c1&gt;</ept>가 리만 가설을 나타낸다면 우리가 아직 어느쪽에 분리자를 주장하지 않았더라도 고전 수학자는 <bpt i="2" x="2">&lt;c2&gt;</bpt>RH ∨ ¬RH<ept i="2">&lt;/c2&gt;</ept>라고 기꺼이 주장할 겁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If Lean tries to do so and fails, it returns with an error message "don't know how to synthesize placeholder," followed by the type of the term it is expecting, and all the objects and hypothesis available in the context.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T153251Z" creationid="tlqk3" creationdate="20220211T153251Z">
        <seg>만약 린이 그렇게 하려고 했는데 실패한다면 다음에 오는 항의 유형을 기대했다면서 "어떻게 자리 차지자를 동기화 해야할 지 모르겠다"는 오류 메시지를 반환합니다. 그리고 모든 객체와 가정들은 맥락에서 이용가능합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you are not used to thinking constructively, it may take some time for you to get a sense of where classical reasoning is used.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T161827Z" creationid="tlqk3" creationdate="20220211T161827Z">
        <seg>여러분이 직관적으로 생각하는데 익숙치 않다면 고전 추론이 사용되는 곳을 이해하는데 약간의 시간이 소요될지도 모릅니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you are reading the book online, you will see a button that reads "try it!" Pressing the button opens up a tab with a Lean editor, and copies the example with enough surrounding context to make the code compile correctly.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T101138Z" creationid="tlqk35" creationdate="20220130T100113Z">
        <seg>여러분이 온라인으로 책을 읽는다면 "실행해보기"라 적힌 버튼을 볼 것입니다. 버튼을 누르면 린 편집기 탭이 열리면서 코드가 올바르게 컴파일되도록 주변 맥락을 포함해 예제를 복사합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you do name a section, however, you have to close it using the same name.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T071030Z" creationid="tlqk3" creationdate="20220131T071030Z">
        <seg>그러나 여러분이 섹션에 이름을 붙이고자 한다면 같은 이름을 사용해 이를 닫아야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Iff</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T160109Z" creationid="tlqk3" creationdate="20220211T160109Z">
        <seg>쌍조건문</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Implicit Arguments</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T074455Z" creationid="tlqk3" creationdate="20220131T074455Z">
        <seg>암시적 인자(Implicit Arguments)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In Lean, one uses an underscore, <bpt i="0" x="0">&lt;c0&gt;</bpt>_<ept i="0">&lt;/c0&gt;</ept>, to specify that the system should fill in the information automatically.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T074946Z" creationid="tlqk3" creationdate="20220131T074946Z">
        <seg>Lean에서 누군가는 시스템이 자동적으로 정보를 채워넣도록 명시하기 위해 밑줄문자(<bpt i="0" x="0">&lt;c0&gt;</bpt>_<ept i="0">&lt;/c0&gt;</ept>)를 사용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In Lean, the <bpt i="1" x="1">&lt;c1&gt;</bpt>theorem<ept i="1">&lt;/c1&gt;</ept> command introduces a new theorem:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T180405Z" creationid="tlqk3" creationdate="20220211T144726Z">
        <seg>린에서 <bpt i="1" x="1">&lt;c1&gt;</bpt>theorem<ept i="1">&lt;/c1&gt;</ept> 명령은 새로운 정리를 도입합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In addition to axioms, however, we would also need rules to build new proofs from old ones.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T102610Z" creationid="tlqk3" creationdate="20220211T102610Z">
        <seg>하지만 공리에 더해 우리는 이전 증명으로부터 새로운 증명을 만드는데 사용할 규칙도 필요합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In all cases, the command <bpt i="2" x="2">&lt;c2&gt;</bpt>#print t1<ept i="2">&lt;/c2&gt;</ept> still yields <bpt i="3" x="3">&lt;c3&gt;</bpt>∀ p q : Prop, p → q → p<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T155055Z" creationid="tlqk3" creationdate="20220211T155055Z">
        <seg>모든 경우에 명령 <bpt i="2" x="2">&lt;c2&gt;</bpt>#print t1<ept i="2">&lt;/c2&gt;</ept>은 여전히 <bpt i="3" x="3">&lt;c3&gt;</bpt>∀ p q : Prop, p → q → p<ept i="3">&lt;/c3&gt;</ept>을 출력합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In any case, all that really matters is the bottom line.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T144148Z" creationid="tlqk3" creationdate="20220211T144148Z">
        <seg>어떤 경우에는 가장 중요한 것은 아래의 문장입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In contrast, <bpt i="0" x="0">&lt;e0&gt;</bpt>interactive theorem proving<ept i="0">&lt;/e0&gt;</ept> focuses on the "verification" aspect of theorem proving, requiring that every claim is supported by a proof in a suitable axiomatic foundation.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T101655Z" creationid="tlqk35" creationdate="20220130T090705Z">
        <seg>반대로 <bpt i="0" x="0">&lt;e0&gt;</bpt>상호작용 증명기<ept i="0">&lt;/e0&gt;</ept>는 모든 진술은 적절한 공리적 기초에 의한 증명으로 지지될 것을 요구하면서 정리 증명의 "식별" 측면에 초점을 둡니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In contrast, if we think in terms of the coding trick described above, then the expressions themselves do not denote anything interesting.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T143325Z" creationid="tlqk3" creationdate="20220211T143135Z">
        <seg>반대로 위에서 설명한 코딩 트릭으로 생각한다면 표현식 그 자체는 어떤 흥미로운 것도 나타내지 않습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In fact, Lean is generally able to process and check proofs in parallel, since assessing the correctness of one proof does not require knowing the details of another.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T150543Z" creationid="tlqk3" creationdate="20220211T150543Z">
        <seg>사실, 어떤 증명의 옳음에 접근하는 것은 다른 것의 상세를 알 필요가 없기 때문에 린은 일반적으로 증명의 검증과 처리를 병렬적으로 할 수 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In fact, by the propositions-as-types correspondence, we can declare the assumption <bpt i="0" x="0">&lt;c0&gt;</bpt>hp<ept i="0">&lt;/c0&gt;</ept> that <bpt i="1" x="1">&lt;c1&gt;</bpt>p<ept i="1">&lt;/c1&gt;</ept> holds, as another variable:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T154841Z" creationid="tlqk3" creationdate="20220211T154841Z">
        <seg>사실 유형으로써 명제 대응에 의해 우리는 <bpt i="1" x="1">&lt;c1&gt;</bpt>p<ept i="1">&lt;/c1&gt;</ept>를 가진 가정 <bpt i="0" x="0">&lt;c0&gt;</bpt>hp<ept i="0">&lt;/c0&gt;</ept>를을 또다른 변수로 선언할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In fact, more should be true: applying the expression <bpt i="2" x="2">&lt;c2&gt;</bpt>(fun x : Nat =&gt; x)<ept i="2">&lt;/c2&gt;</ept> to <bpt i="3" x="3">&lt;c3&gt;</bpt>1<ept i="3">&lt;/c3&gt;</ept> should "return" the value <bpt i="4" x="4">&lt;c4&gt;</bpt>1<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T060428Z" creationid="tlqk3" creationdate="20220131T060428Z">
        <seg>사실, 더 중요한건 표현식<bpt i="2" x="2">&lt;c2&gt;</bpt>(fun x : Nat =&gt; x)<ept i="2">&lt;/c2&gt;</ept>을 <bpt i="3" x="3">&lt;c3&gt;</bpt>1<ept i="3">&lt;/c3&gt;</ept>에 적용하는 것은 값 <bpt i="4" x="4">&lt;c4&gt;</bpt>1<ept i="4">&lt;/c4&gt;</ept>을 "반환"하는 겁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In fact, most such systems provide fully elaborated "proof objects" that can be communicated to other systems and checked independently.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T101639Z" creationid="tlqk35" creationdate="20220130T090932Z">
        <seg>사실, 그런 시스템의 대부분은 증명 대상과의 완전한 협력을 제공합니다. 이 대상은 다른 시스템과 상호작용될 수 있고 독립적으로 검증될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In fact, the expression denotes the same function as <bpt i="6" x="6">&lt;c6&gt;</bpt>fun (u : β) (z : α) =&gt; u<ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T055539Z" creationid="tlqk3" creationdate="20220131T055539Z">
        <seg>사실 표현식은  <bpt i="6" x="6">&lt;c6&gt;</bpt>fun (u : β) (z : α) =&gt; u<ept i="6">&lt;/c6&gt;</ept>처럼 같은 함수를 가리킵니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In fact, the function <bpt i="2" x="2">&lt;c2&gt;</bpt>id<ept i="2">&lt;/c2&gt;</ept> is defined in the standard library in exactly this way.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T075402Z" creationid="tlqk3" creationdate="20220131T075349Z">
        <seg>사실 함수 <bpt i="2" x="2">&lt;c2&gt;</bpt>id<ept i="2">&lt;/c2&gt;</ept>는 표준 라이브러리에서도 이와 정확히 동일한 방식으로 정의되어 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In fact, the type <bpt i="2" x="2">&lt;c2&gt;</bpt>Prop<ept i="2">&lt;/c2&gt;</ept> is syntactic sugar for <bpt i="3" x="3">&lt;c3&gt;</bpt>Sort 0<ept i="3">&lt;/c3&gt;</ept>, the very bottom of the type hierarchy described in the last chapter.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T141457Z" creationid="tlqk3" creationdate="20220211T140243Z">
        <seg>사실 <bpt i="2" x="2">&lt;c2&gt;</bpt>Prop<ept i="2">&lt;/c2&gt;</ept>형은 <bpt i="3" x="3">&lt;c3&gt;</bpt>Sort 0<ept i="3">&lt;/c3&gt;</ept>에 대한 문법적 설탕입니다. 유형 계층의 최하층은 마지막 장에서 설명합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In light of that fact, Lean tags proofs as <bpt i="0" x="0">&lt;e0&gt;</bpt>irreducible<ept i="0">&lt;/e0&gt;</ept>, which serves as a hint to the parser (more precisely, the <bpt i="1" x="1">&lt;e1&gt;</bpt>elaborator<ept i="1">&lt;/e1&gt;</ept>) that there is generally no need to unfold it when processing a file.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T150337Z" creationid="tlqk3" creationdate="20220211T150337Z">
        <seg>그 사실에 비춰보면 린의 증명을 <bpt i="0" x="0">&lt;e0&gt;</bpt>줄일 수 없는<ept i="0">&lt;/e0&gt;</ept> 것으로 태그한다. 그리고 그것은 파서(더 정확히는  <bpt i="1" x="1">&lt;e1&gt;</bpt>협력기<ept i="1">&lt;/e1&gt;</ept>)에게 파일을 처리할 때 증명을 펼칠 필요가 없다는 힌트를 주는 역할을 한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In many respects, however, a <bpt i="0" x="0">&lt;c0&gt;</bpt>namespace ... end<ept i="0">&lt;/c0&gt;</ept> block behaves the same as a <bpt i="1" x="1">&lt;c1&gt;</bpt>section ... end<ept i="1">&lt;/c1&gt;</ept> block.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T071815Z" creationid="tlqk3" creationdate="20220131T071815Z">
        <seg>하지만 여러 관점에서 <bpt i="0" x="0">&lt;c0&gt;</bpt>namespace ... end<ept i="0">&lt;/c0&gt;</ept>블록은 <bpt i="1" x="1">&lt;c1&gt;</bpt>section ... end<ept i="1">&lt;/c1&gt;</ept>블록과 동일하게 동작합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In most cases, the first argument of <bpt i="0" x="0">&lt;c0&gt;</bpt>Or.intro_right<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>Or.intro_left<ept i="1">&lt;/c1&gt;</ept> can be inferred automatically by Lean.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T171831Z" creationid="tlqk3" creationdate="20220211T171831Z">
        <seg>대게의 경우  <bpt i="0" x="0">&lt;c0&gt;</bpt>Or.intro_right<ept i="0">&lt;/c0&gt;</ept>와 <bpt i="1" x="1">&lt;c1&gt;</bpt>Or.intro_left<ept i="1">&lt;/c1&gt;</ept>의 첫번째 인수는 린에 의해 자동적으로 추론될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In normal circumstances, it is never necessary to unfold the "definition" of a theorem; by proof irrelevance, any two proofs of that theorem are definitionally equal.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T150056Z" creationid="tlqk3" creationdate="20220211T145948Z">
        <seg>평범한 상황에서 증명 무연관에 의해 정리의 "정의"를 펼칠 필요는 절대 없습니다. 그리고 그 정리의 임의의 두 증명도 정의상으로 동등합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In other words, <bpt i="2" x="2">&lt;c2&gt;</bpt>s<ept i="2">&lt;/c2&gt;</ept> is a proof of <bpt i="3" x="3">&lt;c3&gt;</bpt>p<ept i="3">&lt;/c3&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>t<ept i="4">&lt;/c4&gt;</ept> is a proof of the desired conclusion assuming <bpt i="5" x="5">&lt;c5&gt;</bpt>h : p<ept i="5">&lt;/c5&gt;</ept>, and the two are combined by a lambda abstraction and application.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T175133Z" creationid="tlqk3" creationdate="20220211T174823Z">
        <seg>다시 말하자면 <bpt i="2" x="2">&lt;c2&gt;</bpt>s<ept i="2">&lt;/c2&gt;</ept>는 <bpt i="3" x="3">&lt;c3&gt;</bpt>p<ept i="3">&lt;/c3&gt;</ept>의 증명입니다. <bpt i="5" x="5">&lt;c5&gt;</bpt>h : p<ept i="5">&lt;/c5&gt;</ept>를 가정한 <bpt i="4" x="4">&lt;c4&gt;</bpt>t<ept i="4">&lt;/c4&gt;</ept>는 원하는 결론의 증명입니다. 그리고 이 둘은 람다 추상화와 적용으로 결합되어 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In other words, <bpt i="3" x="3">&lt;c3&gt;</bpt>True<ept i="3">&lt;/c3&gt;</ept> is simply true, and has a canonical proof, <bpt i="4" x="4">&lt;c4&gt;</bpt>True.intro<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T173823Z" creationid="tlqk3" creationdate="20220211T173823Z">
        <seg>다시 말하자면 <bpt i="3" x="3">&lt;c3&gt;</bpt>True<ept i="3">&lt;/c3&gt;</ept>는 단순히 참이고, 정식 증명 <bpt i="4" x="4">&lt;c4&gt;</bpt>True.intro<ept i="4">&lt;/c4&gt;</ept>를 가집니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In other words, <bpt i="6" x="6">&lt;e6&gt;</bpt>assuming<ept i="6">&lt;/e6&gt;</ept> <bpt i="7" x="7">&lt;c7&gt;</bpt>α : Type<ept i="7">&lt;/c7&gt;</ept> is the first argument to the function, the type of the next two elements are <bpt i="8" x="8">&lt;c8&gt;</bpt>α<ept i="8">&lt;/c8&gt;</ept> and <bpt i="9" x="9">&lt;c9&gt;</bpt>List α<ept i="9">&lt;/c9&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T073304Z" creationid="tlqk3" creationdate="20220131T073304Z">
        <seg>다시 말하면 함수의 첫 번째 인수로  <bpt i="7" x="7">&lt;c7&gt;</bpt>α : Type<ept i="7">&lt;/c7&gt;</ept>으로  <bpt i="6" x="6">&lt;e6&gt;</bpt>가정<ept i="6">&lt;/e6&gt;</ept>하면 다음 두 원소의 유형은  <bpt i="8" x="8">&lt;c8&gt;</bpt>α<ept i="8">&lt;/c8&gt;</ept>와 <bpt i="9" x="9">&lt;c9&gt;</bpt>List α<ept i="9">&lt;/c9&gt;</ept>가 됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In other words, double-negation elimination allows one to carry out a proof by contradiction, something which is not generally possible in constructive logic.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T162319Z" creationid="tlqk3" creationdate="20220211T162319Z">
        <seg>다시 말하자면 이중 부정 제거는 직관주의적 논리에서 일반적으로 불가능한 귀류법을 사용한 증명을 허용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In other words, for each unresolved placeholder, Lean reports the subgoal that needs to be filled at that point.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T153328Z" creationid="tlqk3" creationdate="20220211T153328Z">
        <seg>다시 말하자면 각 해결되지 않은 자리 차지자에 대해 린은 그 지점에서 채워져야 할 작은 목표를 보고합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In other words, for every <bpt i="11" x="11">&lt;c11&gt;</bpt>α<ept i="11">&lt;/c11&gt;</ept>, <bpt i="12" x="12">&lt;c12&gt;</bpt>cons α<ept i="12">&lt;/c12&gt;</ept> is the function that takes an element <bpt i="13" x="13">&lt;c13&gt;</bpt>a : α<ept i="13">&lt;/c13&gt;</ept> and a list <bpt i="14" x="14">&lt;c14&gt;</bpt>as : List α<ept i="14">&lt;/c14&gt;</ept>, and returns a new list, so you have <bpt i="15" x="15">&lt;c15&gt;</bpt>cons α a as : List α<ept i="15">&lt;/c15&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T072858Z" creationid="tlqk3" creationdate="20220131T072858Z">
        <seg>다시 말하면 모든 <bpt i="11" x="11">&lt;c11&gt;</bpt>α<ept i="11">&lt;/c11&gt;</ept>에 대해  <bpt i="12" x="12">&lt;c12&gt;</bpt>cons α<ept i="12">&lt;/c12&gt;</ept>는 원소 <bpt i="13" x="13">&lt;c13&gt;</bpt>a : α<ept i="13">&lt;/c13&gt;</ept>와 리스트 <bpt i="14" x="14">&lt;c14&gt;</bpt>as : List α<ept i="14">&lt;/c14&gt;</ept>를 받는 함수입니다.  그리고 새로운 리스트를 반환합니다. 그래서 여러분은  <bpt i="15" x="15">&lt;c15&gt;</bpt>cons α a as : List α<ept i="15">&lt;/c15&gt;</ept>를 갖습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In other words, if <bpt i="14" x="14">&lt;c14&gt;</bpt>β<ept i="14">&lt;/c14&gt;</ept> is a proposition depending on <bpt i="15" x="15">&lt;c15&gt;</bpt>α<ept i="15">&lt;/c15&gt;</ept>, then <bpt i="16" x="16">&lt;c16&gt;</bpt>∀ x : α, β<ept i="16">&lt;/c16&gt;</ept> is again a proposition.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220222T150957Z" creationid="tlqk35" creationdate="20220222T150957Z">
        <seg>다시 말해서, 만약 <bpt i="14" x="14">&lt;c14&gt;</bpt>β<ept i="14">&lt;/c14&gt;</ept>가 <bpt i="15" x="15">&lt;c15&gt;</bpt>α<ept i="15">&lt;/c15&gt;</ept>에 의존하는 명제라면 <bpt i="16" x="16">&lt;c16&gt;</bpt>∀ x : α, β<ept i="16">&lt;/c16&gt;</ept>도 다시 명제인 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In other words, implication between propositions <bpt i="2" x="2">&lt;c2&gt;</bpt>p<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>q<ept i="3">&lt;/c3&gt;</ept> corresponds to having a function that takes any element of <bpt i="4" x="4">&lt;c4&gt;</bpt>p<ept i="4">&lt;/c4&gt;</ept> to an element of <bpt i="5" x="5">&lt;c5&gt;</bpt>q<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T141418Z" creationid="tlqk3" creationdate="20220211T135320Z">
        <seg>다시 말하면, 명제  <bpt i="2" x="2">&lt;c2&gt;</bpt>p<ept i="2">&lt;/c2&gt;</ept>과 <bpt i="3" x="3">&lt;c3&gt;</bpt>q<ept i="3">&lt;/c3&gt;</ept>사이의 함의는  <bpt i="4" x="4">&lt;c4&gt;</bpt>p<ept i="4">&lt;/c4&gt;</ept>의 원소에서 <bpt i="5" x="5">&lt;c5&gt;</bpt>q<ept i="5">&lt;/c5&gt;</ept>의 원소로 가는 함수를 갖는 것에 대응된니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In other words, it is a proof by cases.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T171559Z" creationid="tlqk3" creationdate="20220211T171559Z">
        <seg>다시 말하자면 경우에 따라 증명한 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In other words, the expressions <bpt i="1" x="1">&lt;e1&gt;</bpt>themselves<ept i="1">&lt;/e1&gt;</ept> are the proofs.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T143516Z" creationid="tlqk3" creationdate="20220211T143516Z">
        <seg>다시 말하자면 표현식 <bpt i="1" x="1">&lt;e1&gt;</bpt>그들 자체는<ept i="1">&lt;/e1&gt;</ept> 증명입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In other words, the type of dependent functions from <bpt i="4" x="4">&lt;c4&gt;</bpt>α<ept i="4">&lt;/c4&gt;</ept> to <bpt i="5" x="5">&lt;c5&gt;</bpt>β<ept i="5">&lt;/c5&gt;</ept> "lives" in the universe whose index is the maximum of <bpt i="6" x="6">&lt;c6&gt;</bpt>i<ept i="6">&lt;/c6&gt;</ept> and <bpt i="7" x="7">&lt;c7&gt;</bpt>j<ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220222T150645Z" creationid="tlqk35" creationdate="20220222T150614Z">
        <seg>다시 말하면, <bpt i="4" x="4">&lt;c4&gt;</bpt>α<ept i="4">&lt;/c4&gt;</ept>에서 <bpt i="5" x="5">&lt;c5&gt;</bpt>β<ept i="5">&lt;/c5&gt;</ept>로의 의존 함수 유형이 그것의 첨자가 <bpt i="6" x="6">&lt;c6&gt;</bpt>i<ept i="6">&lt;/c6&gt;</ept>와 <bpt i="7" x="7">&lt;c7&gt;</bpt>j<ept i="7">&lt;/c7&gt;</ept> 사이의 최대값인 유형세계에 "산다"입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In other words, the type of the value returned by <bpt i="13" x="13">&lt;c13&gt;</bpt>f<ept i="13">&lt;/c13&gt;</ept> depends on its input.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T073717Z" creationid="tlqk3" creationdate="20220131T073717Z">
        <seg>다시 말하자면 <bpt i="13" x="13">&lt;c13&gt;</bpt>f<ept i="13">&lt;/c13&gt;</ept>에 의해 반환되는 값의 유형은 그것의 입력에 의존합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In other words, whenever we have <bpt i="3" x="3">&lt;c3&gt;</bpt>p : Prop<ept i="3">&lt;/c3&gt;</ept>, we can interpret <bpt i="4" x="4">&lt;c4&gt;</bpt>p<ept i="4">&lt;/c4&gt;</ept> as a type, namely, the type of its proofs.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T141406Z" creationid="tlqk3" creationdate="20220211T134930Z">
        <seg>다시 말하자면, <bpt i="3" x="3">&lt;c3&gt;</bpt>p : Prop<ept i="3">&lt;/c3&gt;</ept>를 갖는한 우리는p를 유형으로써 p가 그 증명에 대한 유형으로  해석할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In particular, if you use the <bpt i="2" x="2">&lt;c2&gt;</bpt>variable<ept i="2">&lt;/c2&gt;</ept> command within a namespace, its scope is limited to the namespace.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T071844Z" creationid="tlqk3" creationdate="20220131T071844Z">
        <seg>특히, 이름공간 안에서 <bpt i="2" x="2">&lt;c2&gt;</bpt>variable<ept i="2">&lt;/c2&gt;</ept> 명령을 사용한다면 그것의 범위는 이름공간으로 제한될 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In particular, we can define predicates on <bpt i="5" x="5">&lt;c5&gt;</bpt>α<ept i="5">&lt;/c5&gt;</ept> by quantifying over all predicates on <bpt i="6" x="6">&lt;c6&gt;</bpt>α<ept i="6">&lt;/c6&gt;</ept>, which is exactly the type of circularity that was once considered problematic.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220222T153736Z" creationid="tlqk35" creationdate="20220222T153659Z">
        <seg>특히, 우리는 <bpt i="5" x="5">&lt;c5&gt;</bpt>α<ept i="5">&lt;/c5&gt;</ept>에 대한 술어를 <bpt i="6" x="6">&lt;c6&gt;</bpt>α<ept i="6">&lt;/c6&gt;</ept>에 대한 모든 술어를 한정함으로써 정의할 수 있습니다. 그리고 이게 한때 문제라고 여겼던 순환 유형입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In particular, we can often write <bpt i="10" x="10">&lt;c10&gt;</bpt>⟨hp, hq⟩<ept i="10">&lt;/c10&gt;</ept> instead of <bpt i="11" x="11">&lt;c11&gt;</bpt>And.intro hp hq<ept i="11">&lt;/c11&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T165717Z" creationid="tlqk3" creationdate="20220211T165717Z">
        <seg>특히 <bpt i="11" x="11">&lt;c11&gt;</bpt>And.intro hp hq<ept i="11">&lt;/c11&gt;</ept>대신  <bpt i="10" x="10">&lt;c10&gt;</bpt>⟨hp, hq⟩<ept i="10">&lt;/c10&gt;</ept>와 같이 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In practice, there is not a sharp distinction between verifying a piece of mathematics and verifying the correctness of a system: formal verification requires describing hardware and software systems in mathematical terms, at which point establishing claims as to their correctness becomes a form of theorem proving.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T084747Z" creationid="tlqk35" creationdate="20220130T084747Z">
        <seg>실제로 수학의 일부를 식별하는 것과 시스템의 명확성을 식별하는 것 사이에 명확한 구분이 없습니다. 형식 증명은 하드웨어와 소프트웨어 시스템을 수학적 항으로 묘사하기를 요구합니다. 그리고 그때 그들의 올바름에 대한 주장을 세우는 것은 정리 증명의 형태가 됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In principle, two terms that reduce to the same value are called <bpt i="1" x="1">&lt;e1&gt;</bpt>definitionally equal<ept i="1">&lt;/e1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T060822Z" creationid="tlqk3" creationdate="20220131T060822Z">
        <seg>원리적으로 같은 값으로 축약되는 두 항은 <bpt i="1" x="1">&lt;e1&gt;</bpt>정의상으로 동등(definitionally equal)<ept i="1">&lt;/e1&gt;</ept>하다고 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In situations like this, it can be tedious to supply the arguments <bpt i="0" x="0">&lt;c0&gt;</bpt>a b c<ept i="0">&lt;/c0&gt;</ept>, when they can be inferred from <bpt i="1" x="1">&lt;c1&gt;</bpt>hab hbc<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220222T145311Z" creationid="tlqk35" creationdate="20220222T145311Z">
        <seg>이와 같은 상황에서 인자 <bpt i="0" x="0">&lt;c0&gt;</bpt>a b c<ept i="0">&lt;/c0&gt;</ept>를 제공하는 것은 번거로울 수 있습니다.  그들이 <bpt i="1" x="1">&lt;c1&gt;</bpt>hab hbc<ept i="1">&lt;/c1&gt;</ept>으로부터 추론될 수 있을 때,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In that case, <bpt i="11" x="11">&lt;c11&gt;</bpt>(x : α) → β<ept i="11">&lt;/c11&gt;</ept> is an element of <bpt i="12" x="12">&lt;c12&gt;</bpt>Sort 0<ept i="12">&lt;/c12&gt;</ept> as well, no matter which type universe <bpt i="13" x="13">&lt;c13&gt;</bpt>α<ept i="13">&lt;/c13&gt;</ept> lives in.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220222T150830Z" creationid="tlqk35" creationdate="20220222T150830Z">
        <seg>그 경우 <bpt i="13" x="13">&lt;c13&gt;</bpt>α<ept i="13">&lt;/c13&gt;</ept>가 어느 유형세계에 속하였든 상관없이 <bpt i="11" x="11">&lt;c11&gt;</bpt>(x : α) → β<ept i="11">&lt;/c11&gt;</ept>도 <bpt i="12" x="12">&lt;c12&gt;</bpt>Sort 0<ept i="12">&lt;/c12&gt;</ept>의 원소입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <note>여기서 hold는 갖는다가 아니라 어떤 명제가 참이다, 성립한다를 나타내는 말로 쓰임.</note>
      <tuv xml:lang="en-US">
        <seg>In that case, given <bpt i="4" x="4">&lt;c4&gt;</bpt>x : α<ept i="4">&lt;/c4&gt;</ept>, <bpt i="5" x="5">&lt;c5&gt;</bpt>p x<ept i="5">&lt;/c5&gt;</ept> denotes the assertion that <bpt i="6" x="6">&lt;c6&gt;</bpt>p<ept i="6">&lt;/c6&gt;</ept> holds of <bpt i="7" x="7">&lt;c7&gt;</bpt>x<ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220222T141553Z" creationid="tlqk35" creationdate="20220222T141214Z">
        <seg>이 경우 <bpt i="4" x="4">&lt;c4&gt;</bpt>x : α<ept i="4">&lt;/c4&gt;</ept>가 주어진다면, <bpt i="5" x="5">&lt;c5&gt;</bpt>p x<ept i="5">&lt;/c5&gt;</ept>는  <bpt i="6" x="6">&lt;c6&gt;</bpt>p<ept i="6">&lt;/c6&gt;</ept>가  <bpt i="7" x="7">&lt;c7&gt;</bpt>x<ept i="7">&lt;/c7&gt;</ept>가 성립한다는 주장을 지칭합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In that case, the type <bpt i="8" x="8">&lt;c8&gt;</bpt>(a : α) → β a<ept i="8">&lt;/c8&gt;</ept> denotes the type of functions <bpt i="9" x="9">&lt;c9&gt;</bpt>f<ept i="9">&lt;/c9&gt;</ept> with the property that, for each <bpt i="10" x="10">&lt;c10&gt;</bpt>a : α<ept i="10">&lt;/c10&gt;</ept>, <bpt i="11" x="11">&lt;c11&gt;</bpt>f a<ept i="11">&lt;/c11&gt;</ept> is an element of <bpt i="12" x="12">&lt;c12&gt;</bpt>β a<ept i="12">&lt;/c12&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T073700Z" creationid="tlqk3" creationdate="20220131T073700Z">
        <seg>이 경우 유형 <bpt i="8" x="8">&lt;c8&gt;</bpt>(a : α) → β a<ept i="8">&lt;/c8&gt;</ept>는 모든  <bpt i="10" x="10">&lt;c10&gt;</bpt>a : α<ept i="10">&lt;/c10&gt;</ept>에 대해,  <bpt i="11" x="11">&lt;c11&gt;</bpt>f a<ept i="11">&lt;/c11&gt;</ept> 가  <bpt i="12" x="12">&lt;c12&gt;</bpt>β a<ept i="12">&lt;/c12&gt;</ept>의 원소라는 성질로 <bpt i="9" x="9">&lt;c9&gt;</bpt>f<ept i="9">&lt;/c9&gt;</ept> 함수의 유형을 지칭합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the Lean standard library, you often see Greek letters to denote types, and the Unicode symbol <bpt i="10" x="10">&lt;c10&gt;</bpt>→<ept i="10">&lt;/c10&gt;</ept> as a more compact version of <bpt i="11" x="11">&lt;c11&gt;</bpt>-&gt;<ept i="11">&lt;/c11&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T041220Z" creationid="tlqk3" creationdate="20220131T041220Z">
        <seg>린의 표준 라이브러리에서 여러분은 유형을 나타내는데 그리스 문자를 자주 보게 됩니다. 그리고 유니코드 기호 <bpt i="10" x="10">&lt;c10&gt;</bpt>→<ept i="10">&lt;/c10&gt;</ept> 은 <bpt i="11" x="11">&lt;c11&gt;</bpt>-&gt;<ept i="11">&lt;/c11&gt;</ept>보다 더 간결한 버전입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the case where <bpt i="0" x="0">&lt;c0&gt;</bpt>p x<ept i="0">&lt;/c0&gt;</ept> has type <bpt i="1" x="1">&lt;c1&gt;</bpt>Prop<ept i="1">&lt;/c1&gt;</ept>, if we replace <bpt i="2" x="2">&lt;c2&gt;</bpt>(x : α) → β x<ept i="2">&lt;/c2&gt;</ept> with <bpt i="3" x="3">&lt;c3&gt;</bpt>∀ x : α, p x<ept i="3">&lt;/c3&gt;</ept>, we can read these as the correct rules for building proofs involving the universal quantifier.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220222T142654Z" creationid="tlqk35" creationdate="20220222T142654Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>p x<ept i="0">&lt;/c0&gt;</ept>는 <bpt i="1" x="1">&lt;c1&gt;</bpt>Prop<ept i="1">&lt;/c1&gt;</ept>형을 갖는 이 경우에 대해, 우리가  <bpt i="2" x="2">&lt;c2&gt;</bpt>(x : α) → β x<ept i="2">&lt;/c2&gt;</ept>을 <bpt i="3" x="3">&lt;c3&gt;</bpt>∀ x : α, p x<ept i="3">&lt;/c3&gt;</ept>으로 대체한다면, 우리는 이것들을 전칭 한정기호를 포함한 증명을 만드는데 옳바른 규칙이라고 읽을 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the current setting, it shows how to "introduce" or establish an implication.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T162949Z" creationid="tlqk3" creationdate="20220211T162949Z">
        <seg>지금 상황에서 그것은 "도입"을 어떻게 하는지 또는 함의를 어떻게 세우는지 보여줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the example above, <bpt i="1" x="1">&lt;c1&gt;</bpt>def m : Nat := 1<ept i="1">&lt;/c1&gt;</ept> defines a new constant <bpt i="2" x="2">&lt;c2&gt;</bpt>m<ept i="2">&lt;/c2&gt;</ept> of type <bpt i="3" x="3">&lt;c3&gt;</bpt>Nat<ept i="3">&lt;/c3&gt;</ept> whose value is <bpt i="4" x="4">&lt;c4&gt;</bpt>1<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T035647Z" creationid="tlqk3" creationdate="20220131T035647Z">
        <seg>위 예제에서 <bpt i="1" x="1">&lt;c1&gt;</bpt>def m : Nat := 1<ept i="1">&lt;/c1&gt;</ept>는 <bpt i="4" x="4">&lt;c4&gt;</bpt>1<ept i="4">&lt;/c4&gt;</ept>을 값으로 갖는 새로운 상수 <bpt i="2" x="2">&lt;c2&gt;</bpt>m<ept i="2">&lt;/c2&gt;</ept>을 <bpt i="3" x="3">&lt;c3&gt;</bpt>Nat<ept i="3">&lt;/c3&gt;</ept>유형으로 정의합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the exposition below, we will slip back and forth between these two ways of talking, at times saying that an expression "constructs" or "produces" or "returns" a proof of a proposition, and at other times simply saying that it "is" such a proof.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T144025Z" creationid="tlqk3" creationdate="20220211T144025Z">
        <seg>아래의 설명에서 우리는 두 말하기 방식 사이를 앞뒤로 다닐 것인데, 어떤 표현은 명제의 증명을 "구성" 또는 "생성", "반환"을 말하고, 어떤 표현은 단순히 "그것"이라고 말합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the expression <bpt i="7" x="7">&lt;c7&gt;</bpt>Or.elim hpq hpr hqr<ept i="7">&lt;/c7&gt;</ept>, <bpt i="8" x="8">&lt;c8&gt;</bpt>Or.elim<ept i="8">&lt;/c8&gt;</ept> takes three arguments, <bpt i="9" x="9">&lt;c9&gt;</bpt>hpq : p ∨ q<ept i="9">&lt;/c9&gt;</ept>, <bpt i="10" x="10">&lt;c10&gt;</bpt>hpr : p → r<ept i="10">&lt;/c10&gt;</ept> and <bpt i="11" x="11">&lt;c11&gt;</bpt>hqr : q → r<ept i="11">&lt;/c11&gt;</ept>, and produces a proof of <bpt i="12" x="12">&lt;c12&gt;</bpt>r<ept i="12">&lt;/c12&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T171658Z" creationid="tlqk3" creationdate="20220211T171658Z">
        <seg>표현식 <bpt i="7" x="7">&lt;c7&gt;</bpt>Or.elim hpq hpr hqr<ept i="7">&lt;/c7&gt;</ept>과 <bpt i="8" x="8">&lt;c8&gt;</bpt>Or.elim<ept i="8">&lt;/c8&gt;</ept>은 세 인수 <bpt i="9" x="9">&lt;c9&gt;</bpt>hpq : p ∨ q<ept i="9">&lt;/c9&gt;</ept>, <bpt i="10" x="10">&lt;c10&gt;</bpt>hpr : p → r<ept i="10">&lt;/c10&gt;</ept> 그리고 <bpt i="11" x="11">&lt;c11&gt;</bpt>hqr : q → r<ept i="11">&lt;/c11&gt;</ept>를 받습니다. 그리고 <bpt i="12" x="12">&lt;c12&gt;</bpt>r<ept i="12">&lt;/c12&gt;</ept>의 증명을 만듭니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the first expression, you should think of every instance of <bpt i="2" x="2">&lt;c2&gt;</bpt>a<ept i="2">&lt;/c2&gt;</ept> in <bpt i="3" x="3">&lt;c3&gt;</bpt>t2<ept i="3">&lt;/c3&gt;</ept> as a syntactic abbreviation for <bpt i="4" x="4">&lt;c4&gt;</bpt>t1<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T070200Z" creationid="tlqk3" creationdate="20220131T070200Z">
        <seg>첫 번째 표현식에서, 여러분은 <bpt i="3" x="3">&lt;c3&gt;</bpt>t2<ept i="3">&lt;/c3&gt;</ept>속 <bpt i="2" x="2">&lt;c2&gt;</bpt>a<ept i="2">&lt;/c2&gt;</ept>의 모든 개체를 <bpt i="4" x="4">&lt;c4&gt;</bpt>t1<ept i="4">&lt;/c4&gt;</ept>에 대한 문법적 약어로 생각해야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the following example, we use <bpt i="13" x="13">&lt;c13&gt;</bpt>Or.elim<ept i="13">&lt;/c13&gt;</ept> to prove <bpt i="14" x="14">&lt;c14&gt;</bpt>p ∨ q → q ∨ p<ept i="14">&lt;/c14&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T171725Z" creationid="tlqk3" creationdate="20220211T171725Z">
        <seg>다음 예제에서 우리는 <bpt i="13" x="13">&lt;c13&gt;</bpt>Or.elim<ept i="13">&lt;/c13&gt;</ept>을 <bpt i="14" x="14">&lt;c14&gt;</bpt>p ∨ q → q ∨ p<ept i="14">&lt;/c14&gt;</ept>을 증명하는데 사용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the last chapter we observed that lambda abstraction can be viewed as an "introduction rule" for <bpt i="0" x="0">&lt;c0&gt;</bpt>→<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T162843Z" creationid="tlqk3" creationdate="20220211T162843Z">
        <seg>지난 장에서 우리는 람다 추상화가 <bpt i="0" x="0">&lt;c0&gt;</bpt>→<ept i="0">&lt;/c0&gt;</ept>에 대한 "도입 규칙"으로 본 적이 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the latter case, let us say that (the type associated with) <bpt i="4" x="4">&lt;c4&gt;</bpt>p<ept i="4">&lt;/c4&gt;</ept> is <bpt i="5" x="5">&lt;e5&gt;</bpt>inhabited<ept i="5">&lt;/e5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T141708Z" creationid="tlqk3" creationdate="20220211T141343Z">
        <seg>후자의 경우에서 (연관된 유형)<bpt i="4" x="4">&lt;c4&gt;</bpt>p<ept i="4">&lt;/c4&gt;</ept>은 <bpt i="5" x="5">&lt;e5&gt;</bpt>머무른다<ept i="5">&lt;/e5&gt;</ept>고 말합시다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the next example we use <bpt i="6" x="6">&lt;c6&gt;</bpt>And.intro<ept i="6">&lt;/c6&gt;</ept> to create a proof of <bpt i="7" x="7">&lt;c7&gt;</bpt>p → q → p ∧ q<ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T163748Z" creationid="tlqk3" creationdate="20220211T163748Z">
        <seg>다음 예제에서 우리는 <bpt i="6" x="6">&lt;c6&gt;</bpt>And.intro<ept i="6">&lt;/c6&gt;</ept>를 <bpt i="7" x="7">&lt;c7&gt;</bpt>p → q → p ∧ q<ept i="7">&lt;/c7&gt;</ept>의 증명을 만들기 위해 사용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the propositions-as-types paradigm, theorems involving only <bpt i="0" x="0">&lt;c0&gt;</bpt>→<ept i="0">&lt;/c0&gt;</ept> can be proved using lambda abstraction and application.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T144636Z" creationid="tlqk3" creationdate="20220211T144636Z">
        <seg>유형으로써 명제 패러다임에서 <bpt i="0" x="0">&lt;c0&gt;</bpt>→<ept i="0">&lt;/c0&gt;</ept>만을 포함하는 정리는 람다 추상화와 적용을 사용해 증명될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the second expression, <bpt i="5" x="5">&lt;c5&gt;</bpt>a<ept i="5">&lt;/c5&gt;</ept> is a variable, and the expression <bpt i="6" x="6">&lt;c6&gt;</bpt>fun a =&gt; t2<ept i="6">&lt;/c6&gt;</ept> has to make sense independently of the value of <bpt i="7" x="7">&lt;c7&gt;</bpt>a<ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T070240Z" creationid="tlqk3" creationdate="20220131T070240Z">
        <seg>두 번째 표현식에서 <bpt i="5" x="5">&lt;c5&gt;</bpt>a<ept i="5">&lt;/c5&gt;</ept>는 변수이고 표현식 <bpt i="6" x="6">&lt;c6&gt;</bpt>fun a =&gt; t2<ept i="6">&lt;/c6&gt;</ept>는  <bpt i="7" x="7">&lt;c7&gt;</bpt>a<ept i="7">&lt;/c7&gt;</ept>의 값과 별개로 의미를 가져야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the second pair of examples below, this mechanism is used to specify the desired types of the expressions <bpt i="5" x="5">&lt;c5&gt;</bpt>id<ept i="5">&lt;/c5&gt;</ept> and <bpt i="6" x="6">&lt;c6&gt;</bpt>List.nil<ept i="6">&lt;/c6&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T075933Z" creationid="tlqk3" creationdate="20220131T075933Z">
        <seg>아래 예제의 쌍의 두 번째에서, 이 메커니즘은 식 <bpt i="5" x="5">&lt;c5&gt;</bpt>id<ept i="5">&lt;/c5&gt;</ept>와 <bpt i="6" x="6">&lt;c6&gt;</bpt>List.nil<ept i="6">&lt;/c6&gt;</ept>의 바람직한 유형을 명시하는데 사용됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In this case you can think of <bpt i="0" x="0">&lt;c0&gt;</bpt>def<ept i="0">&lt;/c0&gt;</ept> as a kind of named <bpt i="1" x="1">&lt;c1&gt;</bpt>lambda<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T064533Z" creationid="tlqk3" creationdate="20220131T064533Z">
        <seg>이 경우 여러분은 <bpt i="0" x="0">&lt;c0&gt;</bpt>def<ept i="0">&lt;/c0&gt;</ept>를 <bpt i="1" x="1">&lt;c1&gt;</bpt>lambda<ept i="1">&lt;/c1&gt;</ept>와 같은 종류로 생각할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In this chapter, we extend the repertoire of logical constructions to include the universal and existential quantifiers, and the equality relation.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220222T140900Z" creationid="tlqk35" creationdate="20220222T140900Z">
        <seg>이번 장에서는 우리는 전칭과 존재 한정기호와 동등 관계를 포함한 논리 구축 레퍼토리를 확장합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In this chapter, we will begin to explain how to write mathematical assertions and proofs in the language of dependent type theory as well.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T101616Z" creationid="tlqk3" creationdate="20220211T101616Z">
        <seg>이 장에서 우리는 수학적 주장과 증명을 의존 유형론의 언어로써 어떻게 작성할지 설명할 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In type theory, this is generally more convenient than writing <bpt i="9" x="9">&lt;c9&gt;</bpt>Nat.add<ept i="9">&lt;/c9&gt;</ept> as a function that takes a pair of natural numbers as input and returns a natural number as output.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T043236Z" creationid="tlqk3" creationdate="20220131T043236Z">
        <seg>유형론에서 보통 <bpt i="9" x="9">&lt;c9&gt;</bpt>Nat.add<ept i="9">&lt;/c9&gt;</ept>과 같이 쓰는 것이 자연수 쌍을 입력으로 받고 자연수를 출력으로 하는 함수로 쓰는 것보다 더 편리합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Incidentally, just as <bpt i="0" x="0">&lt;c0&gt;</bpt>False<ept i="0">&lt;/c0&gt;</ept> has only an elimination rule, <bpt i="1" x="1">&lt;c1&gt;</bpt>True<ept i="1">&lt;/c1&gt;</ept> has only an introduction rule, <bpt i="2" x="2">&lt;c2&gt;</bpt>True.intro : true<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T173751Z" creationid="tlqk3" creationdate="20220211T173751Z">
        <seg>참고로 <bpt i="0" x="0">&lt;c0&gt;</bpt>False<ept i="0">&lt;/c0&gt;</ept>은 제거 규칙만 있듯이 <bpt i="1" x="1">&lt;c1&gt;</bpt>True<ept i="1">&lt;/c1&gt;</ept>는 도입 규칙 <bpt i="2" x="2">&lt;c2&gt;</bpt>True.intro : true<ept i="2">&lt;/c2&gt;</ept>만 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Indeed, if <bpt i="0" x="0">&lt;c0&gt;</bpt>p : Prop<ept i="0">&lt;/c0&gt;</ept> is any proposition, Lean's kernel treats any two elements <bpt i="1" x="1">&lt;c1&gt;</bpt>t1 t2 : p<ept i="1">&lt;/c1&gt;</ept> as being definitionally equal, much the same way as it treats <bpt i="2" x="2">&lt;c2&gt;</bpt>(fun x =&gt; t) s<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>t[s/x]<ept i="3">&lt;/c3&gt;</ept> as definitionally equal.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T142651Z" creationid="tlqk3" creationdate="20220211T142651Z">
        <seg>실제로 <bpt i="0" x="0">&lt;c0&gt;</bpt>p : Prop<ept i="0">&lt;/c0&gt;</ept>이 어떤 명제라면, 린의 커널은 임의의 두 원소 <bpt i="1" x="1">&lt;c1&gt;</bpt>t2 : p <ept i="1">&lt;/c1&gt;</ept>을 <bpt i="2" x="2">&lt;c2&gt;</bpt>(fun x = t) s<ept i="2">&lt;/c2&gt;</ept>와 <bpt i="3" x="3">&lt;c3&gt;</bpt>t[/x]<ept i="3">&lt;/c3&gt;</ept>를 정의상으로 동등하다고 같다는 것과 거의 같은 방식으로 정의상 동등하게 취급합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Indeed, in dependent type theory (and in Lean), <bpt i="10" x="10">&lt;c10&gt;</bpt>α → β<ept i="10">&lt;/c10&gt;</ept> is just notation for <bpt i="11" x="11">&lt;c11&gt;</bpt>(a : α) → β<ept i="11">&lt;/c11&gt;</ept> when <bpt i="12" x="12">&lt;c12&gt;</bpt>β<ept i="12">&lt;/c12&gt;</ept> does not depend on <bpt i="13" x="13">&lt;c13&gt;</bpt>a<ept i="13">&lt;/c13&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T074014Z" creationid="tlqk3" creationdate="20220131T074014Z">
        <seg>물론, 종속 유형론에서(그리고 Lean에서) <bpt i="10" x="10">&lt;c10&gt;</bpt>α → β<ept i="10">&lt;/c10&gt;</ept>는 <bpt i="12" x="12">&lt;c12&gt;</bpt>β<ept i="12">&lt;/c12&gt;</ept>가 <bpt i="13" x="13">&lt;c13&gt;</bpt>a<ept i="13">&lt;/c13&gt;</ept>에 의존하지 않을 때 <bpt i="11" x="11">&lt;c11&gt;</bpt>(a : α) → β<ept i="11">&lt;/c11&gt;</ept>에 대한 표기일 뿐입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Informally, the introduction rule states:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220222T142007Z" creationid="tlqk35" creationdate="20220222T141852Z">
        <seg>비공식적으로 도입 규칙은 다음과 같이 말합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Instead of using <bpt i="0" x="0">&lt;c0&gt;</bpt>sorry<ept i="0">&lt;/c0&gt;</ept>, you can use an underscore <bpt i="1" x="1">&lt;c1&gt;</bpt>_<ept i="1">&lt;/c1&gt;</ept> as a placeholder.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T153009Z" creationid="tlqk3" creationdate="20220211T153009Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>sorry<ept i="0">&lt;/c0&gt;</ept>를 사용하는 것 대신 밑줄 문자  <bpt i="1" x="1">&lt;c1&gt;</bpt>_<ept i="1">&lt;/c1&gt;</ept>를 자리 차지자로 사용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Internally, the expression <bpt i="0" x="0">&lt;c0&gt;</bpt>have h : p := s; t<ept i="0">&lt;/c0&gt;</ept> produces the term <bpt i="1" x="1">&lt;c1&gt;</bpt>(fun (h : p) =&gt; t) s<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T175141Z" creationid="tlqk3" creationdate="20220211T174651Z">
        <seg>내부적으로 표현식 <bpt i="0" x="0">&lt;c0&gt;</bpt>have h : p := s; t<ept i="0">&lt;/c0&gt;</ept>은 항 <bpt i="1" x="1">&lt;c1&gt;</bpt>(fun (h : p) =&gt; t) s<ept i="1">&lt;/c1&gt;</ept>을 만듭니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Introducing Auxiliary Subgoals</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T174545Z" creationid="tlqk3" creationdate="20220211T174407Z">
        <seg>보조적인 세부 목표를 도입하기</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Introduction</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T084132Z" creationid="tlqk35" creationdate="20220130T084132Z">
        <seg>소개(Introduction)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Intuitively, our proof of <bpt i="2" x="2">&lt;c2&gt;</bpt>p → q → p<ept i="2">&lt;/c2&gt;</ept> assumes <bpt i="3" x="3">&lt;c3&gt;</bpt>p<ept i="3">&lt;/c3&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt>q<ept i="4">&lt;/c4&gt;</ept> are true, and uses the first hypothesis (trivially) to establish that the conclusion, <bpt i="5" x="5">&lt;c5&gt;</bpt>p<ept i="5">&lt;/c5&gt;</ept>, is true.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T145111Z" creationid="tlqk3" creationdate="20220211T145111Z">
        <seg>직관적으로  <bpt i="2" x="2">&lt;c2&gt;</bpt>p → q → p<ept i="2">&lt;/c2&gt;</ept>에 대한 우리의 증명은 <bpt i="3" x="3">&lt;c3&gt;</bpt>p<ept i="3">&lt;/c3&gt;</ept>와 <bpt i="4" x="4">&lt;c4&gt;</bpt>q<ept i="4">&lt;/c4&gt;</ept>가 참이라고 가정한다. 그리고 (명백히) 첫 번 째 가정을 <bpt i="5" x="5">&lt;c5&gt;</bpt>p<ept i="5">&lt;/c5&gt;</ept>가 참이라는 결론을 세우기 위해 사용한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Intuitively, the constructive "Or" is very strong: asserting <bpt i="0" x="0">&lt;c0&gt;</bpt>p ∨ q<ept i="0">&lt;/c0&gt;</ept> amounts to knowing which is the case.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T180002Z" creationid="tlqk3" creationdate="20220211T180002Z">
        <seg>직관적으로 구성자 "논리합"은 아주 강력합니다.  <bpt i="0" x="0">&lt;c0&gt;</bpt>p ∨ q<ept i="0">&lt;/c0&gt;</ept>라 주장하는 것은 각 경우를 아는 것과 같습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It has a compiler that generates a binary executable and an interactive interpreter.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T064005Z" creationid="tlqk3" creationdate="20220131T064005Z">
        <seg>이것은 이진 실행 프로그램을 만드는 컴파일러와 상호작용적인 인터프리터를 갖고 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It is an ongoing, long-term effort, and much of the potential for automation will be realized only gradually over time.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T101545Z" creationid="tlqk35" creationdate="20220130T093650Z">
        <seg>이것은 장기적으로 현재진행 중이고 자동화에 대한 대부분의 잠재성은 시간이 지나면서 점차 실현될 겁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It is clear that <bpt i="0" x="0">&lt;c0&gt;</bpt>cons α<ept i="0">&lt;/c0&gt;</ept> should have type <bpt i="1" x="1">&lt;c1&gt;</bpt>α → List α → List α<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T072945Z" creationid="tlqk3" creationdate="20220131T072945Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>cons α<ept i="0">&lt;/c0&gt;</ept>가  <bpt i="1" x="1">&lt;c1&gt;</bpt>α → List α → List α<ept i="1">&lt;/c1&gt;</ept> 유형을 가져야 함은 분명합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It is common to describe <bpt i="4" x="4">&lt;c4&gt;</bpt>And.intro<ept i="4">&lt;/c4&gt;</ept> as the <bpt i="5" x="5">&lt;e5&gt;</bpt>and-introduction<ept i="5">&lt;/e5&gt;</ept> rule.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T163711Z" creationid="tlqk3" creationdate="20220211T163711Z">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>And.intro<ept i="4">&lt;/c4&gt;</ept>를 <bpt i="5" x="5">&lt;e5&gt;</bpt>and-도입<ept i="5">&lt;/e5&gt;</ept> 규칙이라고 설명하는 것은 흔합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It is common to iterate constructions like "And." Lean also allows you to flatten nested constructors that associate to the right, so that these two proofs are equivalent:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T171012Z" creationid="tlqk3" creationdate="20220211T171012Z">
        <seg>"And"같은 반복적 생성은 흔합니다. 두 증명이 동등함을 보이기 위해 린은 여러분에게 오른쪽에 연관된 중첩된 생성자를 평평하게 만들도록 허용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It is convenient for illustration, and we will use it often.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T164213Z" creationid="tlqk3" creationdate="20220211T164213Z">
        <seg>이는 설명에 유용하고 예제 명령을 자주 사용할 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It is needed in the following example because, from a constructive standpoint, knowing that <bpt i="0" x="0">&lt;c0&gt;</bpt>p<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>q<ept i="1">&lt;/c1&gt;</ept> are not both true does not necessarily tell you which one is false:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T162004Z" creationid="tlqk3" creationdate="20220211T162004Z">
        <seg>다음 예제에서 이게 필요한데 왜냐하면 직관주의적 관점에서 <bpt i="0" x="0">&lt;c0&gt;</bpt>p<ept i="0">&lt;/c0&gt;</ept>와 <bpt i="1" x="1">&lt;c1&gt;</bpt>q<ept i="1">&lt;/c1&gt;</ept> 둘 다 참이 아니라는 것을 아는 것은 여러분에게 반드시 어떤 것이 거짓이라는 것을 말해줄 필요는 없기 때문입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It is still tedious, however, to type all these underscores.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T075036Z" creationid="tlqk3" creationdate="20220131T075036Z">
        <seg>그래도 여전히 이 밑줄문자를 치는 것은 번거롭습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It is the typing rule for dependent arrow types, and the universal quantifier in particular, that distinguishes <bpt i="0" x="0">&lt;c0&gt;</bpt>Prop<ept i="0">&lt;/c0&gt;</ept> from other types.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220222T145937Z" creationid="tlqk35" creationdate="20220222T145937Z">
        <seg>이것은 의존 화살표 유형에 대한 타자 규칙입니다. 특히 그리고 전칭 한정기호는 <bpt i="0" x="0">&lt;c0&gt;</bpt>Prop<ept i="0">&lt;/c0&gt;</ept> 과 다른 유형들을 구분합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It just so happens that the rules for function application and abstraction can conveniently help us keep track of which elements of <bpt i="6" x="6">&lt;c6&gt;</bpt>Prop<ept i="6">&lt;/c6&gt;</ept> are inhabited.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T142144Z" creationid="tlqk3" creationdate="20220211T141805Z">
        <seg>함수 적용 및 추상화 규칙이 <bpt i="6" x="6">&lt;c6&gt;</bpt>Prop<ept i="6">&lt;/c6&gt;</ept>의 원소가 머무르는 것을 우리가 추적하는 것을 편리하게 도울 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It means that even though we can treat proofs <bpt i="5" x="5">&lt;c5&gt;</bpt>t : p<ept i="5">&lt;/c5&gt;</ept> as ordinary objects in the language of dependent type theory, they carry no information beyond the fact that <bpt i="6" x="6">&lt;c6&gt;</bpt>p<ept i="6">&lt;/c6&gt;</ept> is true.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T142903Z" creationid="tlqk3" creationdate="20220211T142903Z">
        <seg>우리가 증명<bpt i="5" x="5">&lt;c5&gt;</bpt>t : p<ept i="5">&lt;/c5&gt;</ept>을 의존 유형론 언어의 평범한 대상으로 다룰 수 있음에도 <bpt i="6" x="6">&lt;c6&gt;</bpt>p<ept i="6">&lt;/c6&gt;</ept>가 참이라는 사실 이상의 정보를 전달하지 않는다는 것을 의미합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Just as dependent function types <bpt i="0" x="0">&lt;c0&gt;</bpt>(a : α) → β a<ept i="0">&lt;/c0&gt;</ept> generalize the notion of a function type <bpt i="1" x="1">&lt;c1&gt;</bpt>α → β<ept i="1">&lt;/c1&gt;</ept> by allowing <bpt i="2" x="2">&lt;c2&gt;</bpt>β<ept i="2">&lt;/c2&gt;</ept> to depend on <bpt i="3" x="3">&lt;c3&gt;</bpt>α<ept i="3">&lt;/c3&gt;</ept>, dependent Cartesian product types <bpt i="4" x="4">&lt;c4&gt;</bpt>(a : α) × β a<ept i="4">&lt;/c4&gt;</ept> generalize the Cartesian product <bpt i="5" x="5">&lt;c5&gt;</bpt>α × β<ept i="5">&lt;/c5&gt;</ept> in the same way.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T074236Z" creationid="tlqk3" creationdate="20220131T074236Z">
        <seg>의존적 함수 유형 <bpt i="0" x="0">&lt;c0&gt;</bpt>(a : α) → β a<ept i="0">&lt;/c0&gt;</ept>는 함수의 유형 <bpt i="1" x="1">&lt;c1&gt;</bpt>α → β<ept i="1">&lt;/c1&gt;</ept>의 개념을 <bpt i="2" x="2">&lt;c2&gt;</bpt>β<ept i="2">&lt;/c2&gt;</ept>가 <bpt i="3" x="3">&lt;c3&gt;</bpt>α<ept i="3">&lt;/c3&gt;</ept>에 종속적이라고 함으로써 일반화한 것처럼 의존적 카테시안 곱 유형은 <bpt i="4" x="4">&lt;c4&gt;</bpt>(a : α) × β a<ept i="4">&lt;/c4&gt;</ept>는 카테시안 곱  <bpt i="5" x="5">&lt;c5&gt;</bpt>α × β<ept i="5">&lt;/c5&gt;</ept>를 같은 방식으로 일반화합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean allows us to use <bpt i="8" x="8">&lt;e8&gt;</bpt>anonymous constructor<ept i="8">&lt;/e8&gt;</ept> notation <bpt i="9" x="9">&lt;c9&gt;</bpt>⟨arg1, arg2, ...⟩<ept i="9">&lt;/c9&gt;</ept> in situations like these, when the relevant type is an inductive type and can be inferred from the context.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T165646Z" creationid="tlqk3" creationdate="20220211T165514Z">
        <seg>연관된 유형이 유도형이고 맥락으로부터 추리할 수 있는 상황에서 린은 <bpt i="8" x="8">&lt;e8&gt;</bpt>익명 생성자<ept i="8">&lt;/e8&gt;</ept> 표기 <bpt i="9" x="9">&lt;c9&gt;</bpt>⟨arg1, arg2, ...⟩<ept i="9">&lt;/c9&gt;</ept>를 쓸 수 있게 해줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean also allows us to specify the type of the final term <bpt i="3" x="3">&lt;c3&gt;</bpt>hp<ept i="3">&lt;/c3&gt;</ept>, explicitly, with a <bpt i="4" x="4">&lt;c4&gt;</bpt>show<ept i="4">&lt;/c4&gt;</ept> statement.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T150920Z" creationid="tlqk3" creationdate="20220211T150920Z">
        <seg>린은 여러분에게 마지막 항 <bpt i="3" x="3">&lt;c3&gt;</bpt>hp<ept i="3">&lt;/c3&gt;</ept>을 명시적으로 <bpt i="4" x="4">&lt;c4&gt;</bpt>show<ept i="4">&lt;/c4&gt;</ept> 문장으로 유형을 명시하는 것을 허용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean also allows you to introduce "local" definitions using the <bpt i="0" x="0">&lt;c0&gt;</bpt>let<ept i="0">&lt;/c0&gt;</ept> keyword.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T065759Z" creationid="tlqk3" creationdate="20220131T065759Z">
        <seg>Lean은 여러분이 <bpt i="0" x="0">&lt;c0&gt;</bpt>let<ept i="0">&lt;/c0&gt;</ept> 키워드를 사용해 "지역" 정의를 가져올 수 있게 허용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean also has mechanisms to serve as its own <bpt i="0" x="0">&lt;e0&gt;</bpt>metaprogramming language<ept i="0">&lt;/e0&gt;</ept>, which means that you can implement automation and extend the functionality of Lean using Lean itself.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T101600Z" creationid="tlqk35" creationdate="20220130T092222Z">
        <seg>또한 Lean은 그 자체로 <bpt i="0" x="0">&lt;e0&gt;</bpt>메타프로그래밍 언어<ept i="0">&lt;/e0&gt;</ept>로 기능하는 작동 원리가 있어 자동화의 수행 및 Lean 자체로 그 기능을 확장할 수 있음을 의미합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean also supports a structured way of reasoning backwards from a goal, which models the "suffices to show" construction in ordinary mathematics.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T175112Z" creationid="tlqk3" creationdate="20220211T174936Z">
        <seg>린은 또 구조화된 목표로부터 후방향 추론 방식을 지원합니다. 이것은 일상 수학에서 "보여주기에 충분하다" 구성을 모델링 한 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean can not only define mathematical objects and express mathematical assertions in dependent type theory, but it also can be used as a language for writing proofs.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T101353Z" creationid="tlqk35" creationdate="20220130T095054Z">
        <seg>우리는 수학적 대상들을 정의하고 수학적 주장을 의존 유형론으로 진술할 수 있고 증명을 작성하는 언어로써 사용될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean can usually infer the type <bpt i="3" x="3">&lt;c3&gt;</bpt>α<ept i="3">&lt;/c3&gt;</ept>, but it is often a good idea to write it explicitly.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T064721Z" creationid="tlqk3" creationdate="20220131T064721Z">
        <seg>Lean은 <bpt i="3" x="3">&lt;c3&gt;</bpt>α<ept i="3">&lt;/c3&gt;</ept>의 유형을 추론할 수 있습니다. 그러나 이를 명백히 적는 것이 좋습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean defines all the standard logical connectives and notation.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T153902Z" creationid="tlqk3" creationdate="20220211T153902Z">
        <seg>린은 모든 표준 논리 연결사와 표기를 정의합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean detects that the proof uses <bpt i="0" x="0">&lt;c0&gt;</bpt>hp<ept i="0">&lt;/c0&gt;</ept> and automatically adds <bpt i="1" x="1">&lt;c1&gt;</bpt>hp : p<ept i="1">&lt;/c1&gt;</ept> as a premise.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T155016Z" creationid="tlqk3" creationdate="20220211T155016Z">
        <seg>린은 <bpt i="0" x="0">&lt;c0&gt;</bpt>hp<ept i="0">&lt;/c0&gt;</ept>를 사용하는 증명을 감지하고 자동적으로 <bpt i="1" x="1">&lt;c1&gt;</bpt>hp : p<ept i="1">&lt;/c1&gt;</ept>를 전제로 추가합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean has very complex mechanisms for instantiating implicit arguments, and we will see that they can be used to infer function types, predicates, and even proofs.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T075622Z" creationid="tlqk3" creationdate="20220131T075532Z">
        <seg>Lean은 암시적인 인수를 인스턴스화(instantiating)하는데 아주 복잡한 매커니즘을 가지고 있습니다. 그리고 우리는 함수의 유형과 술어 그리고 심지어 증명을 추론하는데 사용될 수 있음을 볼 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean interprets the final three examples as the same expression; in the last expression, Lean infers the type of <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>y<ept i="1">&lt;/c1&gt;</ept> from the expression <bpt i="2" x="2">&lt;c2&gt;</bpt>if not y then x + 1 else x + 2<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T053236Z" creationid="tlqk3" creationdate="20220131T053236Z">
        <seg>린은 마지막 세 예제를 같은 표현식으로 해석합니다. 마지막 표현식에서 린은 <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>와 <bpt i="1" x="1">&lt;c1&gt;</bpt>y<ept i="1">&lt;/c1&gt;</ept>의 유형을 표현식 <bpt i="2" x="2">&lt;c2&gt;</bpt>if not y then x + 1 else x + 2<ept i="2">&lt;/c2&gt;</ept>으로부터 추론합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean is a complete programming language.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T061055Z" creationid="tlqk3" creationdate="20220131T061055Z">
        <seg>린은 완전한 프로그래밍 언어입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean is based on a version of dependent type theory known as the <bpt i="0" x="0">&lt;e0&gt;</bpt>Calculus of Constructions<ept i="0">&lt;/e0&gt;</ept>, with a countable hierarchy of non-cumulative universes and inductive types.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T034412Z" creationid="tlqk3" creationdate="20220131T034412Z">
        <seg>린은  <bpt i="0" x="0">&lt;e0&gt;</bpt>직관주의 계산법<ept i="0">&lt;/e0&gt;</ept>이라고 하는 가산적인 비축적적 세계(Universe)와 유도형이 있는 의존 유형론 버전을 기반합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean is released under the <bpt i="1" x="1">&lt;a1&gt;</bpt>Apache 2.0 license<ept i="1">&lt;/a1&gt;</ept>, a permissive open source license that permits others to use and extend the code and mathematical libraries freely.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T101536Z" creationid="tlqk35" creationdate="20220130T093858Z">
        <seg>Lean은  <bpt i="1" x="1">&lt;a1&gt;</bpt>Apache 2.0 라이센스<ept i="1">&lt;/a1&gt;</ept>하에서 배포되었습니다. 이는 타인에게 자유롭게 사용하는 것과 수학 라이브러리 및 코드의 확장을 허락합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean is smart enough to figure out which variables are used explicitly or implicitly in a definition.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T070647Z" creationid="tlqk3" creationdate="20220131T070647Z">
        <seg>Lean은 정의에서 명시적으로나 암시적으로 사용된 변수를 구분하기에 충분히 똑똑합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean provides a <bpt i="0" x="0">&lt;c0&gt;</bpt>fun<ept i="0">&lt;/c0&gt;</ept> (or <bpt i="1" x="1">&lt;c1&gt;</bpt>λ<ept i="1">&lt;/c1&gt;</ept>) keyword to create a function from an expression as follows:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T052344Z" creationid="tlqk3" creationdate="20220131T052344Z">
        <seg>린은 <bpt i="0" x="0">&lt;c0&gt;</bpt>fun<ept i="0">&lt;/c0&gt;</ept> (또는 <bpt i="1" x="1">&lt;c1&gt;</bpt>λ<ept i="1">&lt;/c1&gt;</ept>) 키워드를 제공하여 다음과 같은 표현식으로부터 함수를 만들 수 있게 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean provides another useful syntactic gadget.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T165819Z" creationid="tlqk3" creationdate="20220211T165819Z">
        <seg>린은 또 다른 유용한 문법적 도구를 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean provides you with the <bpt i="0" x="0">&lt;c0&gt;</bpt>variable<ept i="0">&lt;/c0&gt;</ept> command to make such declarations look more compact:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T070450Z" creationid="tlqk3" creationdate="20220131T070450Z">
        <seg>린은 여러분에게 이런 선언을 더 간결하게 보이게 만들도록 <bpt i="0" x="0">&lt;c0&gt;</bpt>variable<ept i="0">&lt;/c0&gt;</ept> 명령을 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean provides you with the ability to group definitions into nested, hierarchical <bpt i="0" x="0">&lt;e0&gt;</bpt>namespaces<ept i="0">&lt;/e0&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T071119Z" creationid="tlqk3" creationdate="20220131T071119Z">
        <seg>Lean은 여러분에게 정의를 중첩되고 계층적인 <bpt i="0" x="0">&lt;e0&gt;</bpt>namespaces<ept i="0">&lt;/e0&gt;</ept>에 묶을 수 있는 능력을 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean therefore provides <bpt i="2" x="2">&lt;c2&gt;</bpt>Or.inr<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>Or.inl<ept i="3">&lt;/c3&gt;</ept> which can be viewed as shorthand for <bpt i="4" x="4">&lt;c4&gt;</bpt>Or.intro_right _<ept i="4">&lt;/c4&gt;</ept> and <bpt i="5" x="5">&lt;c5&gt;</bpt>Or.intro_left _<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T171932Z" creationid="tlqk3" creationdate="20220211T171932Z">
        <seg>린은 그러므로  <bpt i="4" x="4">&lt;c4&gt;</bpt>Or.intro_right _<ept i="4">&lt;/c4&gt;</ept>과 <bpt i="5" x="5">&lt;c5&gt;</bpt>Or.intro_left _<ept i="5">&lt;/c5&gt;</ept>의 약식 표현으로 볼 수 있는 <bpt i="2" x="2">&lt;c2&gt;</bpt>Or.inr<ept i="2">&lt;/c2&gt;</ept> 과 <bpt i="3" x="3">&lt;c3&gt;</bpt>Or.inl<ept i="3">&lt;/c3&gt;</ept>을 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean's standard library contains proofs of many valid statements of propositional logic, all of which you are free to use in proofs of your own.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T161510Z" creationid="tlqk3" creationdate="20220211T161510Z">
        <seg>린의 표준 라이브러리는 명제 논리의 유효한 많은 진술들이 담겨있고 그 모든 것들은 여러분들의 주장을 증명하는데 자유롭게 사용될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean's task, as a proof assistant, is to help us to construct such a term, <bpt i="3" x="3">&lt;c3&gt;</bpt>t<ept i="3">&lt;/c3&gt;</ept>, and to verify that it is well-formed and has the correct type.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T144450Z" creationid="tlqk3" creationdate="20220211T144450Z">
        <seg>증명 보조기로써 린의 일은 그러한 항 <bpt i="3" x="3">&lt;c3&gt;</bpt>t<ept i="3">&lt;/c3&gt;</ept>를 생성하고 그것이 올바른 유형이고 잘 형성된 것을 검증하도록 돕는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean's underlying foundation has an infinite hierarchy of types:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T050025Z" creationid="tlqk3" creationdate="20220131T050025Z">
        <seg>린의 기저에는 무한한 유형의 계층이 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean's underlying logic has a computational interpretation, and Lean can be viewed equally well as a programming language.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T101612Z" creationid="tlqk35" creationdate="20220130T091710Z">
        <seg>Lean의 기본 논리는 컴퓨팅 해석기(interpretor)을 가지는데 있다. 그래서 Lean은 프로그래밍 언어와 마찬가지로 동등하게 볼 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Let's create one that adds two natural numbers:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T064923Z" creationid="tlqk3" creationdate="20220131T064923Z">
        <seg>두 자연수를 더하는 함수를 만들어 봅시다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Let's take a look at some basic syntax.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T041535Z" creationid="tlqk3" creationdate="20220131T041535Z">
        <seg>몇 가지 기본 문법에 대해 살펴봅시다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Light (default)</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T073304Z" creationid="tlqk35" creationdate="20220130T073304Z">
        <seg>밝게(기본)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Like sections, namespaces can be nested:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T071550Z" creationid="tlqk3" creationdate="20220131T071550Z">
        <seg>section처럼 이름공간도 중첩될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Like sections, nested namespaces have to be closed in the order they are opened.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T071644Z" creationid="tlqk3" creationdate="20220131T071644Z">
        <seg>섹션과 마찬가지로 중첩된 이름공간은 그들이 열린 순서대로 닫혀야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Local Definitions</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T065719Z" creationid="tlqk3" creationdate="20220131T065719Z">
        <seg>지역 정의(Local Definitions)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Logical Equivalence</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T173855Z" creationid="tlqk3" creationdate="20220211T173855Z">
        <seg>논리적 동등성</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Make sure Lean accepts the term with all the <bpt i="3" x="3">&lt;c3&gt;</bpt>sorry<ept i="3">&lt;/c3&gt;</ept>'s; if not, there are errors that you need to correct.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T152835Z" creationid="tlqk3" creationdate="20220211T152835Z">
        <seg>린이 모든 <bpt i="2" x="2">&lt;c2&gt;</bpt>sorry<ept i="2">&lt;/c2&gt;</ept>에 대한 말을 받아들이게 만드세요. 그렇지 않으면 여러분이 고쳐야 하는 에러가 생깁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Many people have contributed to the effort, providing corrections, suggestions, examples, and text.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T100516Z" creationid="tlqk35" creationdate="20220130T100516Z">
        <seg>많은 사람들이 오타 정정, 제안, 예제, 본분을 제공하는 등의 노력으로 기여했습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>More specifically, Lean is based on a version of a system known as the Calculus of Constructions with inductive types.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T101410Z" creationid="tlqk35" creationdate="20220130T095034Z">
        <seg>더 구체적으로 Lean은 유도형(inductive types)의 직관주의적 계산법(calculus of Construction)으로 알려진 시스템에 기반한 버전입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>More to the point, it can be viewed as a system for writing programs with a precise semantics, as well as reasoning about the functions that the programs compute.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T101607Z" creationid="tlqk35" creationdate="20220130T091939Z">
        <seg>더욱이 이것은 정밀한 의미를 갖는 편집프로그램이나 프로그램이 계산하는 함수에 대한 추론 프로그램으로도 볼 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Moreover, <bpt i="4" x="4">&lt;c4&gt;</bpt>Type u<ept i="4">&lt;/c4&gt;</ept> is also just syntactic sugar for <bpt i="5" x="5">&lt;c5&gt;</bpt>Sort (u+1)<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T141502Z" creationid="tlqk3" creationdate="20220211T140310Z">
        <seg>게다가 <bpt i="4" x="4">&lt;c4&gt;</bpt>Type u<ept i="4">&lt;/c4&gt;</ept>도 <bpt i="5" x="5">&lt;c5&gt;</bpt>Sort (u+1)<ept i="5">&lt;/c5&gt;</ept>에 대한 문법적 설탕입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Moreover, once we make this identification, the rules for implication show that we can pass back and forth between <bpt i="0" x="0">&lt;c0&gt;</bpt>Implies p q<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>p → q<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T135152Z" creationid="tlqk3" creationdate="20220211T135152Z">
        <seg>게다가 한번 우리가 이런 식별을 하면 함의 규칙은 <bpt i="0" x="0">&lt;c0&gt;</bpt>Implies p q<ept i="0">&lt;/c0&gt;</ept>과 <bpt i="1" x="1">&lt;c1&gt;</bpt>p → q<ept i="1">&lt;/c1&gt;</ept>의 앞뒤를 오갈 수 있다는 것을 보여줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Moreover, the output indicates that the first argument is implicit.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T080347Z" creationid="tlqk3" creationdate="20220131T080347Z">
        <seg>게다가 출력은 첫 번째 인수가 암시적임을 가리킵니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Much of the background information you will need in order to do this is not specific to Lean at all.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T101423Z" creationid="tlqk35" creationdate="20220130T094656Z">
        <seg>이를 배우기 위해 필요한 대부분의 배경지식은 Lean으로만 국한되어 있지 않습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Namespaces</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T071046Z" creationid="tlqk3" creationdate="20220131T071046Z">
        <seg>이름공간(Namespaces)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Namespaces and sections serve different purposes: namespaces organize data and sections declare variables for insertion in definitions.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T071712Z" creationid="tlqk3" creationdate="20220131T071712Z">
        <seg>이름공간과 섹션은 다른 목적을 갖고 일합니다. 이름공간은 데이터를 정리하고 섹션은 정의의 삽입에 대해 변수를 선언합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Namespaces that have been closed can later be reopened, even in another file:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T071617Z" creationid="tlqk3" creationdate="20220131T071617Z">
        <seg>닫힌 이름공간은 심지어 다른 파일일지라도 나중에 다시 열릴 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Navy</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T073622Z" creationid="tlqk35" creationdate="20220130T073424Z">
        <seg>짙푸른색</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Negation and Falsity</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T172631Z" creationid="tlqk3" creationdate="20220211T172631Z">
        <seg>부정과 거짓</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Negation, <bpt i="0" x="0">&lt;c0&gt;</bpt>¬p<ept i="0">&lt;/c0&gt;</ept>, is actually defined to be <bpt i="1" x="1">&lt;c1&gt;</bpt>p → False<ept i="1">&lt;/c1&gt;</ept>, so we obtain <bpt i="2" x="2">&lt;c2&gt;</bpt>¬p<ept i="2">&lt;/c2&gt;</ept> by deriving a contradiction from <bpt i="3" x="3">&lt;c3&gt;</bpt>p<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T172745Z" creationid="tlqk3" creationdate="20220211T172745Z">
        <seg>부정 <bpt i="0" x="0">&lt;c0&gt;</bpt>¬p<ept i="0">&lt;/c0&gt;</ept>은 실제로 <bpt i="1" x="1">&lt;c1&gt;</bpt>p → False<ept i="1">&lt;/c1&gt;</ept>로 정의되어 있습니다. 그래서 우리는 <bpt i="3" x="3">&lt;c3&gt;</bpt>p<ept i="3">&lt;/c3&gt;</ept>로부터 모순을 유도함으로써 <bpt i="2" x="2">&lt;c2&gt;</bpt>¬p<ept i="2">&lt;/c2&gt;</ept>를 얻습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Next chapter</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T074142Z" creationid="tlqk35" creationdate="20220130T074142Z">
        <seg>다음 장</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Nor do you have to name a section, which is to say, you can use an anonymous <bpt i="0" x="0">&lt;c0&gt;</bpt>section<ept i="0">&lt;/c0&gt;</ept> / <bpt i="1" x="1">&lt;c1&gt;</bpt>end<ept i="1">&lt;/c1&gt;</ept> pair.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T071007Z" creationid="tlqk3" creationdate="20220131T070920Z">
        <seg>섹션에 이름을 줄 필요도 없습니다. 그말은 즉슨, 여러분은 익명의 <bpt i="0" x="0">&lt;c0&gt;</bpt>section<ept i="0">&lt;/c0&gt;</ept> / <bpt i="1" x="1">&lt;c1&gt;</bpt>end<ept i="1">&lt;/c1&gt;</ept> 쌍을 사용할 수 있다는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Not</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T160021Z" creationid="tlqk3" creationdate="20220211T160021Z">
        <seg>부정</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Notationally, this hides the specification of the type, making it look as though <bpt i="1" x="1">&lt;c1&gt;</bpt>ident<ept i="1">&lt;/c1&gt;</ept> simply takes an argument of any type.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T075329Z" creationid="tlqk3" creationdate="20220131T075329Z">
        <seg>표기상으로 <bpt i="1" x="1">&lt;c1&gt;</bpt>ident<ept i="1">&lt;/c1&gt;</ept>가 단순히 임의의 유형의 인수를 받을 수 있는 것처럼 만들어 유형의 명세를 감춥니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Note that <bpt i="9" x="9">&lt;c9&gt;</bpt>×<ept i="9">&lt;/c9&gt;</ept> is a Unicode symbol.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T040812Z" creationid="tlqk3" creationdate="20220131T040812Z">
        <seg><bpt i="9" x="9">&lt;c9&gt;</bpt>×<ept i="9">&lt;/c9&gt;</ept>은 유니코드 기호임을 보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Note that it is often useful to use numeric unicode subscripts, entered as <bpt i="0" x="0">&lt;c0&gt;</bpt>\0<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>\1<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>\2<ept i="2">&lt;/c2&gt;</ept>, ..., for hypotheses, as we did in this example.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T160242Z" creationid="tlqk3" creationdate="20220211T160242Z">
        <seg>수치 유니코드 밑첨자를 사용하는 것은 종종 유용합니다. 이 예제에서 그런 것처럼 가정에 대해 <bpt i="0" x="0">&lt;c0&gt;</bpt>\0<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>\1<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>\2<ept i="2">&lt;/c2&gt;</ept>, ..., 으로 쳐서 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Note that the <bpt i="0" x="0">&lt;c0&gt;</bpt>theorem<ept i="0">&lt;/c0&gt;</ept> command is really a version of the <bpt i="1" x="1">&lt;c1&gt;</bpt>def<ept i="1">&lt;/c1&gt;</ept> command: under the propositions and types correspondence, proving the theorem <bpt i="2" x="2">&lt;c2&gt;</bpt>p → q → p<ept i="2">&lt;/c2&gt;</ept> is really the same as defining an element of the associated type.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T145322Z" creationid="tlqk3" creationdate="20220211T145322Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>theorem<ept i="0">&lt;/c0&gt;</ept> 명령은 <bpt i="1" x="1">&lt;c1&gt;</bpt>def<ept i="1">&lt;/c1&gt;</ept> 명령의 한 버전이라는 것을 주목하세요. 명제와 유형 대응 하에서 정리 <bpt i="2" x="2">&lt;c2&gt;</bpt>p → q → p<ept i="2">&lt;/c2&gt;</ept>의 증명하는 것은 연관된 유형의 원소를 증명하는 것과 정말 같습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Notice here we called the <bpt i="0" x="0">&lt;c0&gt;</bpt>double<ept i="0">&lt;/c0&gt;</ept> function to create the first parameter to <bpt i="1" x="1">&lt;c1&gt;</bpt>add<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T065017Z" creationid="tlqk3" creationdate="20220131T065017Z">
        <seg>여기서 우리가 <bpt i="1" x="1">&lt;c1&gt;</bpt>add<ept i="1">&lt;/c1&gt;</ept>의 첫 번째 매개변수를 만들기 위해 <bpt i="0" x="0">&lt;c0&gt;</bpt>double<ept i="0">&lt;/c0&gt;</ept> 함수를 호출한 것을 보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Notice that <bpt i="0" x="0">&lt;c0&gt;</bpt>(a : α) → β<ept i="0">&lt;/c0&gt;</ept> makes sense for any expression <bpt i="1" x="1">&lt;c1&gt;</bpt>β : Type<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T073758Z" creationid="tlqk3" creationdate="20220131T073758Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>(a : α) → β<ept i="0">&lt;/c0&gt;</ept>는  모든 식  <bpt i="1" x="1">&lt;c1&gt;</bpt>β : Type<ept i="1">&lt;/c1&gt;</ept>에 대해 성립하는 것을 주목하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Notice that and-introduction and and-elimination are similar to the pairing and projection operations for the cartesian product.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T164644Z" creationid="tlqk3" creationdate="20220211T164644Z">
        <seg>and-도입과 and-제거는 카테시안 곱 연산의 순서쌍을 구성하는 것과 순서쌍에서 원소를 추출하는 연산과 비슷한 것을 보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Notice that applying a term <bpt i="0" x="0">&lt;c0&gt;</bpt>t : α → β<ept i="0">&lt;/c0&gt;</ept> to a term <bpt i="1" x="1">&lt;c1&gt;</bpt>s : α<ept i="1">&lt;/c1&gt;</ept> yields an expression <bpt i="2" x="2">&lt;c2&gt;</bpt>t s : β<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T055910Z" creationid="tlqk3" creationdate="20220131T055910Z">
        <seg>항 <bpt i="0" x="0">&lt;c0&gt;</bpt>t : α → β<ept i="0">&lt;/c0&gt;</ept>을 항 <bpt i="1" x="1">&lt;c1&gt;</bpt>s : α<ept i="1">&lt;/c1&gt;</ept>에 적용하여 표현식 <bpt i="2" x="2">&lt;c2&gt;</bpt>t s : β<ept i="2">&lt;/c2&gt;</ept>을 얻는 것을 보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Notice that if <bpt i="0" x="0">&lt;c0&gt;</bpt>α<ept i="0">&lt;/c0&gt;</ept> is any type, we can form the type <bpt i="1" x="1">&lt;c1&gt;</bpt>α → Prop<ept i="1">&lt;/c1&gt;</ept> of all predicates on <bpt i="2" x="2">&lt;c2&gt;</bpt>α<ept i="2">&lt;/c2&gt;</ept> (the "power type of <bpt i="3" x="3">&lt;c3&gt;</bpt>α<ept i="3">&lt;/c3&gt;</ept>").</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220222T153408Z" creationid="tlqk35" creationdate="20220222T153408Z">
        <seg>만약 <bpt i="0" x="0">&lt;c0&gt;</bpt>α<ept i="0">&lt;/c0&gt;</ept>가 임의의 유형이면, 우리는  <bpt i="2" x="2">&lt;c2&gt;</bpt>α<ept i="2">&lt;/c2&gt;</ept>에 대한 모든 술어에 대해 <bpt i="1" x="1">&lt;c1&gt;</bpt>α → Prop<ept i="1">&lt;/c1&gt;</ept>형을 만들 수 있습니다. (" <bpt i="3" x="3">&lt;c3&gt;</bpt>α<ept i="3">&lt;/c3&gt;</ept>형의 능력")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Notice that if <bpt i="0" x="0">&lt;c0&gt;</bpt>α<ept i="0">&lt;/c0&gt;</ept> is any type, we can represent a unary predicate <bpt i="1" x="1">&lt;c1&gt;</bpt>p<ept i="1">&lt;/c1&gt;</ept> on <bpt i="2" x="2">&lt;c2&gt;</bpt>α<ept i="2">&lt;/c2&gt;</ept> as an object of type <bpt i="3" x="3">&lt;c3&gt;</bpt>α → Prop<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220222T141106Z" creationid="tlqk35" creationdate="20220222T141106Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>α<ept i="0">&lt;/c0&gt;</ept> 가 임의의 유형인지를 보세요, 우리는 <bpt i="2" x="2">&lt;c2&gt;</bpt>α<ept i="2">&lt;/c2&gt;</ept>에 대해 단항 술어 p를  <bpt i="3" x="3">&lt;c3&gt;</bpt>α → Prop<ept i="3">&lt;/c3&gt;</ept>형의 대상으로 나타낼 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Notice that now the first <bpt i="0" x="0">&lt;c0&gt;</bpt>#check<ept i="0">&lt;/c0&gt;</ept> command gives the type of the identifier, <bpt i="1" x="1">&lt;c1&gt;</bpt>id<ept i="1">&lt;/c1&gt;</ept>, without inserting any placeholders.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T080336Z" creationid="tlqk3" creationdate="20220131T080336Z">
        <seg>현재 첫 번째 <bpt i="0" x="0">&lt;c0&gt;</bpt>#check<ept i="0">&lt;/c0&gt;</ept> 명령은 식별자 <bpt i="1" x="1">&lt;c1&gt;</bpt>id<ept i="1">&lt;/c1&gt;</ept>의 유형을 어떤 플레이스 홀더도 삽입하지 않고 주는 것을 보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Notice that the lambda abstractions <bpt i="0" x="0">&lt;c0&gt;</bpt>hp : p<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>hq : q<ept i="1">&lt;/c1&gt;</ept> can be viewed as temporary assumptions in the proof of <bpt i="2" x="2">&lt;c2&gt;</bpt>t1<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T150800Z" creationid="tlqk3" creationdate="20220211T150800Z">
        <seg>람다 추상화 <bpt i="0" x="0">&lt;c0&gt;</bpt>hp : p<ept i="0">&lt;/c0&gt;</ept>과 <bpt i="1" x="1">&lt;c1&gt;</bpt>hq : q<ept i="1">&lt;/c1&gt;</ept>은 <bpt i="2" x="2">&lt;c2&gt;</bpt>t1<ept i="2">&lt;/c2&gt;</ept>의 증명에서 일시적인 가정으로 보일 수 있음을 주목하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Notice that the meaning of the expression <bpt i="0" x="0">&lt;c0&gt;</bpt>let a := t1; t2<ept i="0">&lt;/c0&gt;</ept> is very similar to the meaning of <bpt i="1" x="1">&lt;c1&gt;</bpt>(fun a =&gt; t2) t1<ept i="1">&lt;/c1&gt;</ept>, but the two are not the same.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T070109Z" creationid="tlqk3" creationdate="20220131T070109Z">
        <seg>표현식 <bpt i="0" x="0">&lt;c0&gt;</bpt>let a := t1; t2<ept i="0">&lt;/c0&gt;</ept>의 의미는 <bpt i="1" x="1">&lt;c1&gt;</bpt>(fun a =&gt; t2) t1<ept i="1">&lt;/c1&gt;</ept>의 의미와 아주 비슷함을 주목하세요. 그러나 이 둘은 같지는 않습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Notice that there is enough information in the full expression for Lean to infer the types of <bpt i="0" x="0">&lt;c0&gt;</bpt>hp<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>hq<ept i="1">&lt;/c1&gt;</ept> as well.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T172147Z" creationid="tlqk3" creationdate="20220211T172147Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>hp<ept i="0">&lt;/c0&gt;</ept>와 <bpt i="1" x="1">&lt;c1&gt;</bpt>hq<ept i="1">&lt;/c1&gt;</ept>의 유형을 추론하기에 린에게 완전한 표현식에 충분한 정보가 있음을 보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Now to get a bit more abstract, you can also specify arguments that are like type parameters:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T065125Z" creationid="tlqk3" creationdate="20220131T065125Z">
        <seg>이제 약간 더 추상적으로 갑시다. 여러분은 유형 매개변수같은 인수를 지정할 수도 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Now we can apply the theorem <bpt i="0" x="0">&lt;c0&gt;</bpt>t1<ept i="0">&lt;/c0&gt;</ept> just as a function application.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T151739Z" creationid="tlqk3" creationdate="20220211T151450Z">
        <seg>이제 우리는 정리 <bpt i="0" x="0">&lt;c0&gt;</bpt>t1<ept i="0">&lt;/c0&gt;</ept>을 함수 활용에 적용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Now, given that <bpt i="4" x="4">&lt;c4&gt;</bpt>h<ept i="4">&lt;/c4&gt;</ept> has type <bpt i="5" x="5">&lt;c5&gt;</bpt>∀ x : α, p x ∧ q x<ept i="5">&lt;/c5&gt;</ept>, the expression <bpt i="6" x="6">&lt;c6&gt;</bpt>h y<ept i="6">&lt;/c6&gt;</ept> has type <bpt i="7" x="7">&lt;c7&gt;</bpt>p y ∧ q y<ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220222T144120Z" creationid="tlqk35" creationdate="20220222T144120Z">
        <seg>이제 <bpt i="4" x="4">&lt;c4&gt;</bpt>h<ept i="4">&lt;/c4&gt;</ept>가 <bpt i="5" x="5">&lt;c5&gt;</bpt>∀ x : α, p x ∧ q x<ept i="5">&lt;/c5&gt;</ept>형을 갖는다고 해봅시다. 그러면 표현식 <bpt i="6" x="6">&lt;c6&gt;</bpt>h y<ept i="6">&lt;/c6&gt;</ept>는  <bpt i="7" x="7">&lt;c7&gt;</bpt>p y ∧ q y<ept i="7">&lt;/c7&gt;</ept>형을 갖습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Numerals are overloaded in Lean, but when the type of a numeral cannot be inferred, Lean assumes, by default, that it is a natural number.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T080008Z" creationid="tlqk3" creationdate="20220131T080008Z">
        <seg>수치들은 Lean에 매우 많이 있습니다. 그러나 수치 유형이 추론되지 못할 때, 린은 기본적으로 그걸 자연수라고 가정합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Of course, it is unsound as a proof method -- for example, you can use it to prove <bpt i="1" x="1">&lt;c1&gt;</bpt>False<ept i="1">&lt;/c1&gt;</ept> -- and Lean produces severe warnings when files use or import theorems which depend on it.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T152629Z" creationid="tlqk3" creationdate="20220211T152629Z">
        <seg>물론 증명 방법으로 건전하지 않습니다. -- 예를 들어, 여러분은 <bpt i="1" x="1">&lt;c1&gt;</bpt>False<ept i="1">&lt;/c1&gt;</ept> 을 증명하는데 그것을 사용할 수 있습니다. --그러면 린은 그것에 의존하는 정리를 불러오거나 그런 파일을 사용할 때 심각한 경고를 보냅니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Often, when you import a module, you will want to open one or more of the namespaces it contains, to have access to the short identifiers.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T071403Z" creationid="tlqk3" creationdate="20220131T071403Z">
        <seg>짧은 식별자로 접근하기 위해서 종종 여러분이 모듈을 가져오기(import) 할 때, 모듈이 담은 다수의 이름공간을 열기 원할 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Once again, using the propositions-as-types correspondence, the variable <bpt i="0" x="0">&lt;c0&gt;</bpt>h<ept i="0">&lt;/c0&gt;</ept> of type <bpt i="1" x="1">&lt;c1&gt;</bpt>r → s<ept i="1">&lt;/c1&gt;</ept> can be viewed as the hypothesis, or premise, that <bpt i="2" x="2">&lt;c2&gt;</bpt>r → s<ept i="2">&lt;/c2&gt;</ept> holds.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T155820Z" creationid="tlqk3" creationdate="20220211T155820Z">
        <seg>다시 한 번, 유형으로써 명제 대응을 사용하면 <bpt i="1" x="1">&lt;c1&gt;</bpt>r → s<ept i="1">&lt;/c1&gt;</ept>형의 변수 <bpt i="0" x="0">&lt;c0&gt;</bpt>h<ept i="0">&lt;/c0&gt;</ept>는 <bpt i="2" x="2">&lt;c2&gt;</bpt>r → s<ept i="2">&lt;/c2&gt;</ept>을 성립시키는 가정 또는 전제로 볼 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Once again, you should exercise judgment as to whether such abbreviations enhance or diminish readability.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T172622Z" creationid="tlqk3" creationdate="20220211T172622Z">
        <seg>다시 한 번, 여러분은 그러한 간략화가 가독성을 높이는지 낮추는지 판단을 시험해보셔야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Once again, you should try some examples on your own.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T041509Z" creationid="tlqk3" creationdate="20220131T041509Z">
        <seg>다시 한번 여러분 스스로 몇 가지 예제를 시도해보기 바랍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Once the proof of a theorem is complete, typically we only need to know that the proof exists; it doesn't matter what the proof is.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T150059Z" creationid="tlqk3" creationdate="20220211T150045Z">
        <seg>한번 정리의 증명이 마쳐지면 우리는 증명이 존재한다는 것만 알면 됩니다. 증명이 무엇인지 아는 것은 중요하지 않습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>One can always specify the type <bpt i="0" x="0">&lt;c0&gt;</bpt>T<ept i="0">&lt;/c0&gt;</ept> of an expression <bpt i="1" x="1">&lt;c1&gt;</bpt>e<ept i="1">&lt;/c1&gt;</ept> by writing <bpt i="2" x="2">&lt;c2&gt;</bpt>(e : T)<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T075828Z" creationid="tlqk3" creationdate="20220131T075822Z">
        <seg>누군가는 표현식 <bpt i="1" x="1">&lt;c1&gt;</bpt>e<ept i="1">&lt;/c1&gt;</ept>의 유형 <bpt i="0" x="0">&lt;c0&gt;</bpt>T<ept i="0">&lt;/c0&gt;</ept>를 <bpt i="2" x="2">&lt;c2&gt;</bpt>(e : T)<ept i="2">&lt;/c2&gt;</ept>와 같이 씀으로써 항상 명시할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>One can similarly infer the argument in <bpt i="5" x="5">&lt;c5&gt;</bpt>Lst.nil Nat<ept i="5">&lt;/c5&gt;</ept>, not from anything else in that expression, but from the fact that it is sent as an argument to the function <bpt i="6" x="6">&lt;c6&gt;</bpt>Lst.cons<ept i="6">&lt;/c6&gt;</ept>, which expects an element of type <bpt i="7" x="7">&lt;c7&gt;</bpt>Lst α<ept i="7">&lt;/c7&gt;</ept> in that position.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T074855Z" creationid="tlqk3" creationdate="20220131T074855Z">
        <seg>그 식에서 <bpt i="6" x="6">&lt;c6&gt;</bpt>Lst.cons<ept i="6">&lt;/c6&gt;</ept> 함수의 인수로 전달되었다는 사실로부터 마찬가지로 <bpt i="5" x="5">&lt;c5&gt;</bpt>Lst.nil Nat<ept i="5">&lt;/c5&gt;</ept>에서 인수를 추론할 수 있습니다. 그리고 <bpt i="6" x="6">&lt;c6&gt;</bpt>Lst.cons<ept i="6">&lt;/c6&gt;</ept>는  <bpt i="7" x="7">&lt;c7&gt;</bpt>Lst α<ept i="7">&lt;/c7&gt;</ept> 유형의 원소를 기대합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>One consequence of the law of the excluded middle is the principle of double-negation elimination:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T180333Z" creationid="tlqk3" creationdate="20220211T180333Z">
        <seg>배중률의 한 결과는 이중 부정 제거의 원리입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>One strategy for proving assertions about objects defined in the language of dependent type theory is to layer an assertion language and a proof language on top of the definition language.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T101849Z" creationid="tlqk3" creationdate="20220211T101849Z">
        <seg>의존 유형론의 언어로 정의된 객체에 대해서 주장을 증명하는 한 전략은 주장 언어와 증명 언어를 정의언어의 꼭대기 층에 두는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <note>번역이 자연스럽지 못한것으로 보임.
그래서 의역을 하였는데 정확한 것인지 모르겠음.</note>
      <tuv xml:lang="en-US">
        <seg>One way in which Lean's dependent type theory extends simple type theory is that types themselves --- entities like <bpt i="0" x="0">&lt;c0&gt;</bpt>Nat<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>Bool<ept i="1">&lt;/c1&gt;</ept> --- are first-class citizens, which is to say that they themselves are objects.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T045135Z" creationid="tlqk3" creationdate="20220131T044953Z">
        <seg>린의 종속 유형론이 단순 유형론을 확장시키는 한 방법은 ---<bpt i="0" x="0">&lt;c0&gt;</bpt>Nat<ept i="0">&lt;/c0&gt;</ept>과 <bpt i="1" x="1">&lt;c1&gt;</bpt>Bool<ept i="1">&lt;/c1&gt;</ept>같은 개체는 그들 그 자체로 대상인 일등 시민 ---으로 두는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Or</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T160046Z" creationid="tlqk3" creationdate="20220211T160046Z">
        <seg>논리합</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Or you can carry out a proof by contradiction:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T161703Z" creationid="tlqk3" creationdate="20220211T161703Z">
        <seg>또는 여러분은 귀류법으로 증명을 도출할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Ordinary classical logic adds to this the law of the excluded middle, <bpt i="0" x="0">&lt;c0&gt;</bpt>p ∨ ¬p<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T175804Z" creationid="tlqk3" creationdate="20220211T175804Z">
        <seg>평범한 고전 논리는 여기에 배중률 <bpt i="0" x="0">&lt;c0&gt;</bpt>p ∨ ¬p<ept i="0">&lt;/c0&gt;</ept>을 추가합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Other properties:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T153622Z" creationid="tlqk3" creationdate="20220211T153622Z">
        <seg>다른 특성들</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Other systems provide search procedures and decision procedures for specific languages and domains, such as linear or nonlinear expressions over the integers or the real numbers.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T101724Z" creationid="tlqk35" creationdate="20220130T090101Z">
        <seg>다른 시스템들은 특정 언어와 영역에 대한 선형 혹은 비선형 식(가령 정수나 실수에 대해 정의된)들에 탐색 절차과 결정 절차를 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Please see <bpt i="0" x="0">&lt;a0&gt;</bpt>lean prover<ept i="0">&lt;/a0&gt;</ept> and <bpt i="1" x="1">&lt;a1&gt;</bpt>lean community<ept i="1">&lt;/a1&gt;</ept> for an up to date list of our amazing contributors.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T101107Z" creationid="tlqk35" creationdate="20220130T100730Z">
        <seg>합<bpt i="0" x="0">&lt;a0&gt;</bpt>린 증명보조기<ept i="0">&lt;/a0&gt;</ept>와 <bpt i="1" x="1">&lt;a1&gt;</bpt>린 커뮤니티<ept i="1">&lt;/a1&gt;</ept>에서 놀라운 최신 기여자 명단을 확인할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Previous chapter</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T100738Z" creationid="tlqk35" creationdate="20220130T100738Z">
        <seg>이전 장</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Print this book</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T073656Z" creationid="tlqk35" creationdate="20220130T073656Z">
        <seg>책 인쇄하기</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Printing them out shows that all three groups of definitions have exactly the same effect.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T070603Z" creationid="tlqk3" creationdate="20220131T070603Z">
        <seg>이것을 출력하는 것은 세 정의 그룹이 정확히 동일한 효과를 가짐을 보여줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Propositional Logic</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T153837Z" creationid="tlqk3" creationdate="20220211T153837Z">
        <seg>명제 논리</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Propositions and Proofs</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T101504Z" creationid="tlqk3" creationdate="20220211T101504Z">
        <seg>명제와 증명</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Propositions and Proofs - Theorem Proving in Lean 4</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T101407Z" creationid="tlqk3" creationdate="20220211T101407Z">
        <seg>명제와 증명 - 린4로 하는 정리 증명</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Propositions as Types</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T101640Z" creationid="tlqk3" creationdate="20220211T101640Z">
        <seg>유형으로써 명제</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Prove <bpt i="0" x="0">&lt;c0&gt;</bpt>¬(p ↔ ¬p)<ept i="0">&lt;/c0&gt;</ept> without using classical logic.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T152111Z" creationid="tlqk3" creationdate="20220211T152111Z">
        <seg>고전 논리를 사용하지 않고 <bpt i="0" x="0">&lt;c0&gt;</bpt>¬(p ↔ ¬p)<ept i="0">&lt;/c0&gt;</ept>을 증명하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Prove the following identities, replacing the "sorry" placeholders with actual proofs.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T152135Z" creationid="tlqk3" creationdate="20220211T152135Z">
        <seg>다음 항등식을 증명하세요. "sorry"를 실제 증명으로 대체하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Quantifiers and Equality</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220222T140617Z" creationid="tlqk35" creationdate="20220222T140617Z">
        <seg>한정기호와 동등성</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Quantifiers and Equality - Theorem Proving in Lean 4</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220222T140609Z" creationid="tlqk35" creationdate="20220222T140538Z">
        <seg>한정기호와 동등성 - 린4로 하는 정리 증명</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Rather, it is the fact that we can write them down and check that they are well-typed that ensures that the proposition in question is true.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T143440Z" creationid="tlqk3" creationdate="20220211T143440Z">
        <seg>그것보다 우리가 표현식을 쓰고 잘 쓰여졌는지 확인할 수 있다는 사실은 의문의 명제가 참인지를 확실히 만듭니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Recall that the <bpt i="0" x="0">&lt;c0&gt;</bpt>def<ept i="0">&lt;/c0&gt;</ept> keyword provides one important way of declaring new named objects.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T064129Z" creationid="tlqk3" creationdate="20220131T064129Z">
        <seg> <bpt i="0" x="0">&lt;c0&gt;</bpt>def<ept i="0">&lt;/c0&gt;</ept>가 새 이름을 가진 대상을 선언하는 중요한 방식임을 기억하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Recall that we can also write theorem <bpt i="0" x="0">&lt;c0&gt;</bpt>t1<ept i="0">&lt;/c0&gt;</ept> as follows:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T154413Z" creationid="tlqk3" creationdate="20220211T154413Z">
        <seg>우리는 정리 <bpt i="0" x="0">&lt;c0&gt;</bpt>t1<ept i="0">&lt;/c0&gt;</ept>을 다음과 같이 쓸 수 있음을 기억하세요/ Recall that we can also write theorem <bpt i="0" x="0">&lt;c0&gt;</bpt>t1<ept i="0">&lt;/c0&gt;</ept> as follows:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Recall that, in the case of ordinary function spaces, we could interpret <bpt i="6" x="6">&lt;c6&gt;</bpt>α → β<ept i="6">&lt;/c6&gt;</ept> as the special case of <bpt i="7" x="7">&lt;c7&gt;</bpt>(x : α) → β<ept i="7">&lt;/c7&gt;</ept> in which <bpt i="8" x="8">&lt;c8&gt;</bpt>β<ept i="8">&lt;/c8&gt;</ept> does not depend on <bpt i="9" x="9">&lt;c9&gt;</bpt>x<ept i="9">&lt;/c9&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220222T143151Z" creationid="tlqk35" creationdate="20220222T143151Z">
        <seg>평범한 함수공간의 경우에 대해 우리는 <bpt i="6" x="6">&lt;c6&gt;</bpt>α → β<ept i="6">&lt;/c6&gt;</ept>을 <bpt i="7" x="7">&lt;c7&gt;</bpt>(x : α) → β<ept i="7">&lt;/c7&gt;</ept>의 특별한 경우로 해석할 수 있음을 생각해보세요. 이때  <bpt i="8" x="8">&lt;c8&gt;</bpt>β<ept i="8">&lt;/c8&gt;</ept>는 <bpt i="9" x="9">&lt;c9&gt;</bpt>x<ept i="9">&lt;/c9&gt;</ept>에 의존하지 않습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Recall this tells Lean that the argument is implicit, and should be filled in automatically.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T153111Z" creationid="tlqk3" creationdate="20220211T153111Z">
        <seg>이것이 린에게 인수가 암시적이고 자동적으로 채우게 함을 의미한다는 것을 기억하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Remember that <bpt i="7" x="7">&lt;c7&gt;</bpt>→<ept i="7">&lt;/c7&gt;</ept> associates to the right (nothing changes now that the arguments are elements of <bpt i="8" x="8">&lt;c8&gt;</bpt>Prop<ept i="8">&lt;/c8&gt;</ept>, instead of some other <bpt i="9" x="9">&lt;c9&gt;</bpt>Type<ept i="9">&lt;/c9&gt;</ept>), as do the other binary connectives.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T160801Z" creationid="tlqk3" creationdate="20220211T160801Z">
        <seg>다른 이항 결합자들처럼 <bpt i="7" x="7">&lt;c7&gt;</bpt>→<ept i="7">&lt;/c7&gt;</ept>은 오른쪽으로 결합한다는 것을 기억하세요.(인수가 <bpt i="9" x="9">&lt;c9&gt;</bpt>Type<ept i="9">&lt;/c9&gt;</ept> 대신 <bpt i="8" x="8">&lt;c8&gt;</bpt>Prop<ept i="8">&lt;/c8&gt;</ept>인 것을 제외하고 변한 건 없습니다.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Remember that expressions which differ up to renaming of bound variables are considered to be equivalent.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220222T144308Z" creationid="tlqk35" creationdate="20220222T144308Z">
        <seg>표현식들은 구속변수의 이름이 달라지기까지 동등한 것으로 간주된다는 것을 기억하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Remember that this type can just as well be written <bpt i="4" x="4">&lt;c4&gt;</bpt>∀ (p q : Prop) (hp : p) (hq :q), p<ept i="4">&lt;/c4&gt;</ept>, since the arrow denotes nothing more than an arrow type in which the target does not depend on the bound variable.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T155343Z" creationid="tlqk3" creationdate="20220211T155343Z">
        <seg>왜냐하면 화살표는 대상이 구속 변수에 의존하지 않는 화살표 유형만을 나타내기 때문에 이 유형은 <bpt i="4" x="4">&lt;c4&gt;</bpt>∀ (p q : Prop) (hp : p) (hq :q), p<ept i="4">&lt;/c4&gt;</ept>로 쓸 수 있게 함을 기억하세요. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Remember the introduction and elimination rules for dependent arrow types:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220222T142255Z" creationid="tlqk35" creationdate="20220222T142255Z">
        <seg>의존 화살표 유형에 대한 도입과 소거 규칙을 기억하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Resolution theorem provers, tableau theorem provers, fast satisfiability solvers, and so on provide means of establishing the validity of formulas in propositional and first-order logic.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T101729Z" creationid="tlqk35" creationdate="20220130T085735Z">
        <seg>Resolution 증명 보조기, tableau 증명 보조기, fast satisfiability 솔버 등등은 명제 논리식와 1계 논리식의 유효성을 식별하는 세우는 수단을 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returning to the example of lists, you can use the command <bpt i="0" x="0">&lt;c0&gt;</bpt>#check<ept i="0">&lt;/c0&gt;</ept> to inspect the type of the following <bpt i="1" x="1">&lt;c1&gt;</bpt>List<ept i="1">&lt;/c1&gt;</ept> functions.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T074045Z" creationid="tlqk3" creationdate="20220131T074045Z">
        <seg>리스트의 예로 돌아가서 여러분은 다음 <bpt i="1" x="1">&lt;c1&gt;</bpt>List<ept i="1">&lt;/c1&gt;</ept> 함수의 유형을 검사하기 위해 <bpt i="0" x="0">&lt;c0&gt;</bpt>#check<ept i="0">&lt;/c0&gt;</ept> 명령을 사용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returning to the previous example and renaming bound variables for clarity, notice the types of the following expressions:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T060103Z" creationid="tlqk3" creationdate="20220131T060103Z">
        <seg>이전 예제로 돌아가 명확성을 위해 구속변수의 이름을 바꿉시다. 다음 표현식의 유형을 주목하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Rust</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T073319Z" creationid="tlqk35" creationdate="20220130T073319Z">
        <seg>녹슨 색</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Search this book ...</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T073716Z" creationid="tlqk35" creationdate="20220130T073716Z">
        <seg>이 책을 찾아보기 ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Search.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T073635Z" creationid="tlqk35" creationdate="20220130T073635Z">
        <seg>탐색.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Second, when writing type expressions, arrows associate to the <bpt i="4" x="4">&lt;e4&gt;</bpt>right<ept i="4">&lt;/e4&gt;</ept>; for example, the type of <bpt i="5" x="5">&lt;c5&gt;</bpt>Nat.add<ept i="5">&lt;/c5&gt;</ept> is <bpt i="6" x="6">&lt;c6&gt;</bpt>Nat → Nat → Nat<ept i="6">&lt;/c6&gt;</ept> which is equivalent to <bpt i="7" x="7">&lt;c7&gt;</bpt>Nat → (Nat → Nat)<ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T042927Z" creationid="tlqk3" creationdate="20220131T042927Z">
        <seg>둘째로 유형 표현식을 쓸 때 화살표는<bpt i="4" x="4">&lt;e4&gt;</bpt>오른쪽<ept i="4">&lt;/e4&gt;</ept> 먼저 결합합니다. 가령<bpt i="5" x="5">&lt;c5&gt;</bpt>Nat.add<ept i="5">&lt;/c5&gt;</ept>의 유형은 <bpt i="6" x="6">&lt;c6&gt;</bpt>Nat → Nat → Nat<ept i="6">&lt;/c6&gt;</ept>이고 이는 <bpt i="7" x="7">&lt;c7&gt;</bpt>Nat → (Nat → Nat)<ept i="7">&lt;/c7&gt;</ept>과 동등합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Sections are also useful for delimiting the scope of commands such as <bpt i="0" x="0">&lt;c0&gt;</bpt>set_option<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>open<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T071740Z" creationid="tlqk3" creationdate="20220131T071740Z">
        <seg>section은 <bpt i="0" x="0">&lt;c0&gt;</bpt>set_option<ept i="0">&lt;/c0&gt;</ept>과 <bpt i="1" x="1">&lt;c1&gt;</bpt>open<ept i="1">&lt;/c1&gt;</ept>같이 명령의 범위를 제한하는데 유용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Sections can also be nested, which allows you to declare new variables incrementally.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T071035Z" creationid="tlqk3" creationdate="20220131T071035Z">
        <seg>section은 중첩될 수도 있습니다. 이는 여러분에게 새로운 변수를 점진적으로 선언할 수 있게 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>See the <bpt i="0" x="0">&lt;a0&gt;</bpt>Setting Up Lean section<ept i="0">&lt;/a0&gt;</ept> of the <bpt i="1" x="1">&lt;a1&gt;</bpt>Lean 4 Manual<ept i="1">&lt;/a1&gt;</ept> to install Lean.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T074010Z" creationid="tlqk35" creationdate="20220130T074010Z">
        <seg>린을 설치하기 위해  <bpt i="1" x="1">&lt;a1&gt;</bpt>린 4 메뉴얼<ept i="1">&lt;/a1&gt;</ept>의 <bpt i="0" x="0">&lt;a0&gt;</bpt>린 설치하기(Setting Up Lean)<ept i="0">&lt;/a0&gt;</ept>을 확인하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Show hidden lines</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T064448Z" creationid="tlqk3" creationdate="20220131T064448Z">
        <seg>숨겨진 선 보이기</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Similarly, <bpt i="3" x="3">&lt;c3&gt;</bpt>And.right h<ept i="3">&lt;/c3&gt;</ept> is a proof of <bpt i="4" x="4">&lt;c4&gt;</bpt>q<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T164330Z" creationid="tlqk3" creationdate="20220211T164330Z">
        <seg>마찬가지로 <bpt i="3" x="3">&lt;c3&gt;</bpt>And.right h<ept i="3">&lt;/c3&gt;</ept>는 <bpt i="4" x="4">&lt;c4&gt;</bpt>q<ept i="4">&lt;/c4&gt;</ept>의 증명입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Similarly, <bpt i="3" x="3">&lt;c3&gt;</bpt>Or.intro_right p hq<ept i="3">&lt;/c3&gt;</ept> creates a proof for <bpt i="4" x="4">&lt;c4&gt;</bpt>p ∨ q<ept i="4">&lt;/c4&gt;</ept> using a proof <bpt i="5" x="5">&lt;c5&gt;</bpt>hq : q<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T171232Z" creationid="tlqk3" creationdate="20220211T171232Z">
        <seg>마찬가지로 <bpt i="3" x="3">&lt;c3&gt;</bpt>Or.intro_right p hq<ept i="3">&lt;/c3&gt;</ept>는 <bpt i="5" x="5">&lt;c5&gt;</bpt>hq : q<ept i="5">&lt;/c5&gt;</ept>의 증명을 사용하여 <bpt i="4" x="4">&lt;c4&gt;</bpt>p ∨ q<ept i="4">&lt;/c4&gt;</ept> 의 증명을 만듭니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Similarly, <bpt i="7" x="7">&lt;c7&gt;</bpt>Iff.mpr h<ept i="7">&lt;/c7&gt;</ept> produces a proof of <bpt i="8" x="8">&lt;c8&gt;</bpt>q → p<ept i="8">&lt;/c8&gt;</ept> from <bpt i="9" x="9">&lt;c9&gt;</bpt>h : p ↔ q<ept i="9">&lt;/c9&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T174115Z" creationid="tlqk3" creationdate="20220211T174115Z">
        <seg>마찬가지로 <bpt i="7" x="7">&lt;c7&gt;</bpt>Iff.mpr h<ept i="7">&lt;/c7&gt;</ept>는 <bpt i="9" x="9">&lt;c9&gt;</bpt>h : p ↔ q<ept i="9">&lt;/c9&gt;</ept>으로부터 <bpt i="8" x="8">&lt;c8&gt;</bpt>q → p<ept i="8">&lt;/c8&gt;</ept>의 증명을 생성합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Similarly, an object <bpt i="8" x="8">&lt;c8&gt;</bpt>r : α → α → Prop<ept i="8">&lt;/c8&gt;</ept> denotes a binary relation on <bpt i="9" x="9">&lt;c9&gt;</bpt>α<ept i="9">&lt;/c9&gt;</ept>: given <bpt i="10" x="10">&lt;c10&gt;</bpt>x y : α<ept i="10">&lt;/c10&gt;</ept>, <bpt i="11" x="11">&lt;c11&gt;</bpt>r x y<ept i="11">&lt;/c11&gt;</ept> denotes the assertion that <bpt i="12" x="12">&lt;c12&gt;</bpt>x<ept i="12">&lt;/c12&gt;</ept> is related to <bpt i="13" x="13">&lt;c13&gt;</bpt>y<ept i="13">&lt;/c13&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220222T141341Z" creationid="tlqk35" creationdate="20220222T141341Z">
        <seg>마찬가지로 대상 <bpt i="8" x="8">&lt;c8&gt;</bpt>r : α → α → Prop<ept i="8">&lt;/c8&gt;</ept>은 <bpt i="9" x="9">&lt;c9&gt;</bpt>α<ept i="9">&lt;/c9&gt;</ept>에 대한 이항 관계 즉, <bpt i="10" x="10">&lt;c10&gt;</bpt>x y : α<ept i="10">&lt;/c10&gt;</ept>이 주어진다면 , <bpt i="11" x="11">&lt;c11&gt;</bpt>r x y<ept i="11">&lt;/c11&gt;</ept>은 <bpt i="12" x="12">&lt;c12&gt;</bpt>x<ept i="12">&lt;/c12&gt;</ept>가 <bpt i="13" x="13">&lt;c13&gt;</bpt>y<ept i="13">&lt;/c13&gt;</ept>에 연관된다는 주장을 지칭합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Similarly, if you use an <bpt i="3" x="3">&lt;c3&gt;</bpt>open<ept i="3">&lt;/c3&gt;</ept> command within a namespace, its effects disappear when the namespace is closed.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T071900Z" creationid="tlqk3" creationdate="20220131T071900Z">
        <seg>마찬가지로 여러분이 이름공간 내에서 <bpt i="3" x="3">&lt;c3&gt;</bpt>open<ept i="3">&lt;/c3&gt;</ept> 명령을 사용한다면 그것의 효과는 이름공간이 닫힐 때 사라질 것 입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Similarly, methods of <bpt i="1" x="1">&lt;e1&gt;</bpt>elaboration<ept i="1">&lt;/e1&gt;</ept> and <bpt i="2" x="2">&lt;e2&gt;</bpt>type inference<ept i="2">&lt;/e2&gt;</ept>, which can be used to support flexible forms of algebraic reasoning.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T095630Z" creationid="tlqk35" creationdate="20220130T095608Z">
        <seg>비슷하게 대수 추론의 유연한 형태를 지원하는데 사용될 수 있는 <bpt i="1" x="1">&lt;e1&gt;</bpt>협력법<ept i="1">&lt;/e1&gt;</ept>과  <bpt i="2" x="2">&lt;e2&gt;</bpt>유형 추론<ept i="2">&lt;/e2&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Similarly, the expression <bpt i="4" x="4">&lt;c4&gt;</bpt>hnp hp<ept i="4">&lt;/c4&gt;</ept> produces a proof of <bpt i="5" x="5">&lt;c5&gt;</bpt>False<ept i="5">&lt;/c5&gt;</ept> from <bpt i="6" x="6">&lt;c6&gt;</bpt>hp : p<ept i="6">&lt;/c6&gt;</ept> and <bpt i="7" x="7">&lt;c7&gt;</bpt>hnp : ¬p<ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T172836Z" creationid="tlqk3" creationdate="20220211T172836Z">
        <seg>마찬가지로 표현식 <bpt i="4" x="4">&lt;c4&gt;</bpt>hnp hp<ept i="4">&lt;/c4&gt;</ept>은 <bpt i="6" x="6">&lt;c6&gt;</bpt>hp : p<ept i="6">&lt;/c6&gt;</ept>과 <bpt i="7" x="7">&lt;c7&gt;</bpt>hnp : ¬p<ept i="7">&lt;/c7&gt;</ept>으로부터 <bpt i="5" x="5">&lt;c5&gt;</bpt>False<ept i="5">&lt;/c5&gt;</ept>의 증명을 만듭니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Similarly, two dashes <bpt i="2" x="2">&lt;c2&gt;</bpt>--<ept i="2">&lt;/c2&gt;</ept> indicate that the rest of the line contains a comment that is also ignored.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T035350Z" creationid="tlqk3" creationdate="20220131T035217Z">
        <seg>마찬가지로 두 개의 대시 <bpt i="2" x="2">&lt;c2&gt;</bpt>--<ept i="2">&lt;/c2&gt;</ept>는 이 줄의 나머지는 주석을 포함함을 나타내고 이 또한 무시됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Similarly, we can think of an implication <bpt i="10" x="10">&lt;c10&gt;</bpt>p → q<ept i="10">&lt;/c10&gt;</ept> between propositions as the special case of <bpt i="11" x="11">&lt;c11&gt;</bpt>∀ x : p, q<ept i="11">&lt;/c11&gt;</ept> in which the expression <bpt i="12" x="12">&lt;c12&gt;</bpt>q<ept i="12">&lt;/c12&gt;</ept> does not depend on <bpt i="13" x="13">&lt;c13&gt;</bpt>x<ept i="13">&lt;/c13&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220222T143408Z" creationid="tlqk35" creationdate="20220222T143408Z">
        <seg>마찬가지로 우리는 명제들 사이의 함의 <bpt i="10" x="10">&lt;c10&gt;</bpt>p → q<ept i="10">&lt;/c10&gt;</ept>를 <bpt i="11" x="11">&lt;c11&gt;</bpt>∀ x : p, q<ept i="11">&lt;/c11&gt;</ept>의 특별한 경우로써 생각할 수 있습니다. 이때 <bpt i="12" x="12">&lt;c12&gt;</bpt>q<ept i="12">&lt;/c12&gt;</ept>는 <bpt i="13" x="13">&lt;c13&gt;</bpt>x<ept i="13">&lt;/c13&gt;</ept>에 의존하지 않습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Simple Type Theory</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T034457Z" creationid="tlqk3" creationdate="20220131T034457Z">
        <seg>단순 유형론(Simple Type Theory)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>So <bpt i="1" x="1">&lt;c1&gt;</bpt>def<ept i="1">&lt;/c1&gt;</ept> can also be used to simply name a value like this:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T064840Z" creationid="tlqk3" creationdate="20220131T064840Z">
        <seg>그래서 <bpt i="1" x="1">&lt;c1&gt;</bpt>def<ept i="1">&lt;/c1&gt;</ept>는 이 같은 값을 단순히 이름으로 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>So constructing an element <bpt i="7" x="7">&lt;c7&gt;</bpt>t : p<ept i="7">&lt;/c7&gt;</ept> tells us that <bpt i="8" x="8">&lt;c8&gt;</bpt>p<ept i="8">&lt;/c8&gt;</ept> is indeed true.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T142137Z" creationid="tlqk3" creationdate="20220211T141814Z">
        <seg>그러므로 원소 <bpt i="7" x="7">&lt;c7&gt;</bpt>t : p<ept i="7">&lt;/c7&gt;</ept>을 생성하는 것은 <bpt i="8" x="8">&lt;c8&gt;</bpt>p<ept i="8">&lt;/c8&gt;</ept>가 사실이라고 우리에게 알립니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>So if we have <bpt i="10" x="10">&lt;c10&gt;</bpt>p q r : Prop<ept i="10">&lt;/c10&gt;</ept>, the expression <bpt i="11" x="11">&lt;c11&gt;</bpt>p → q → r<ept i="11">&lt;/c11&gt;</ept> reads "if <bpt i="12" x="12">&lt;c12&gt;</bpt>p<ept i="12">&lt;/c12&gt;</ept>, then if <bpt i="13" x="13">&lt;c13&gt;</bpt>q<ept i="13">&lt;/c13&gt;</ept>, then <bpt i="14" x="14">&lt;c14&gt;</bpt>r<ept i="14">&lt;/c14&gt;</ept>." This is just the "curried" form of <bpt i="15" x="15">&lt;c15&gt;</bpt>p ∧ q → r<ept i="15">&lt;/c15&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T161038Z" creationid="tlqk3" creationdate="20220211T161038Z">
        <seg>그래서 만약 <bpt i="10" x="10">&lt;c10&gt;</bpt>p q r : Prop<ept i="10">&lt;/c10&gt;</ept>이 있다면 표현식 <bpt i="11" x="11">&lt;c11&gt;</bpt>p → q → r<ept i="11">&lt;/c11&gt;</ept>은 "<bpt i="12" x="12">&lt;c12&gt;</bpt>p<ept i="12">&lt;/c12&gt;</ept>이면 그러면<bpt i="13" x="13">&lt;c13&gt;</bpt>q<ept i="13">&lt;/c13&gt;</ept>이면<bpt i="14" x="14">&lt;c14&gt;</bpt>r<ept i="14">&lt;/c14&gt;</ept>이다."로 읽습니다. 이는 <bpt i="15" x="15">&lt;c15&gt;</bpt>p ∧ q → r<ept i="15">&lt;/c15&gt;</ept>의 "커리된(curried)" 형태일 뿐입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>So it makes sense to take the type to be the first argument to <bpt i="7" x="7">&lt;c7&gt;</bpt>cons<ept i="7">&lt;/c7&gt;</ept>, so that for any type, <bpt i="8" x="8">&lt;c8&gt;</bpt>α<ept i="8">&lt;/c8&gt;</ept>, <bpt i="9" x="9">&lt;c9&gt;</bpt>cons α<ept i="9">&lt;/c9&gt;</ept> is the insertion function for lists of type <bpt i="10" x="10">&lt;c10&gt;</bpt>α<ept i="10">&lt;/c10&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T072715Z" creationid="tlqk3" creationdate="20220131T072715Z">
        <seg>그래서 <bpt i="7" x="7">&lt;c7&gt;</bpt>cons<ept i="7">&lt;/c7&gt;</ept>의 첫번째 인수의 유형으로 임의의 유형 <bpt i="8" x="8">&lt;c8&gt;</bpt>α<ept i="8">&lt;/c8&gt;</ept>를 받아들이게 하는게 타당합니다. <bpt i="9" x="9">&lt;c9&gt;</bpt>cons α<ept i="9">&lt;/c9&gt;</ept>는 <bpt i="10" x="10">&lt;c10&gt;</bpt>α<ept i="10">&lt;/c10&gt;</ept>유형을 원소로 하는 리스트에 대한 삽입 함수입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>So the expressions in the first two <bpt i="0" x="0">&lt;c0&gt;</bpt>#check<ept i="0">&lt;/c0&gt;</ept> commands below are elaborated in the same way, whereas the third <bpt i="1" x="1">&lt;c1&gt;</bpt>#check<ept i="1">&lt;/c1&gt;</ept> command interprets <bpt i="2" x="2">&lt;c2&gt;</bpt>2<ept i="2">&lt;/c2&gt;</ept> as an integer.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T080133Z" creationid="tlqk3" creationdate="20220131T080133Z">
        <seg>그래서 아래 첫 두 <bpt i="0" x="0">&lt;c0&gt;</bpt>#check<ept i="0">&lt;/c0&gt;</ept>명령에서 표현식은 같은 방식으로 해석됩니다. 반면 세 번째 <bpt i="1" x="1">&lt;c1&gt;</bpt>#check<ept i="1">&lt;/c1&gt;</ept> 명령은 <bpt i="2" x="2">&lt;c2&gt;</bpt>2<ept i="2">&lt;/c2&gt;</ept>를 정수로 해석합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>So, for example, we could have used the same variable, <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>, in both the hypothesis and conclusion, and instantiated it by a different variable, <bpt i="1" x="1">&lt;c1&gt;</bpt>z<ept i="1">&lt;/c1&gt;</ept>, in the proof:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220222T144535Z" creationid="tlqk35" creationdate="20220222T144535Z">
        <seg>그럼 예를들어 우리가 같은 변수 <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept> 가정과 결론 양쪽에 사용할 수 있어야 합니다. 그리고 증명에서 다른 변수 <bpt i="1" x="1">&lt;c1&gt;</bpt>z<ept i="1">&lt;/c1&gt;</ept>에 의해 이것이 개체화됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>So, for example, you can write <bpt i="7" x="7">&lt;c7&gt;</bpt>fun x =&gt; g (f x)<ept i="7">&lt;/c7&gt;</ept> instead of <bpt i="8" x="8">&lt;c8&gt;</bpt>fun x : Nat =&gt; g (f x)<ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T053952Z" creationid="tlqk3" creationdate="20220131T053952Z">
        <seg>그래서 여러분은 <bpt i="8" x="8">&lt;c8&gt;</bpt>fun x : Nat =&gt; g (f x)<ept i="8">&lt;/c8&gt;</ept>대신에 <bpt i="7" x="7">&lt;c7&gt;</bpt>fun x =&gt; g (f x)<ept i="7">&lt;/c7&gt;</ept>와 같이 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Some mathematically common examples of operations of functions can be described in terms of lambda abstraction:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T053520Z" creationid="tlqk3" creationdate="20220131T053520Z">
        <seg>수학적으로 흔한 함수 연산 예제는 람다 추상화에 대한 것으로 설명될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Some operations, however, need to be <bpt i="0" x="0">&lt;e0&gt;</bpt>polymorphic<ept i="0">&lt;/e0&gt;</ept> over type universes.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T050816Z" creationid="tlqk3" creationdate="20220131T050816Z">
        <seg>그러나 몇몇 연산은 유형 세계에 대해 <bpt i="0" x="0">&lt;e0&gt;</bpt>다형적(polymorphic, 구체적인 유형이 다르더다도 비슷한 동작을 바랄 수 있는 성질)<ept i="0">&lt;/e0&gt;</ept>일 필요가 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Some simplifications are possible, however.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T141356Z" creationid="tlqk3" creationdate="20220211T134458Z">
        <seg>하지만 몇 가지 단순화는 가능합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Sometimes, however, it is useful to limit the scope of a variable.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T070750Z" creationid="tlqk3" creationdate="20220131T070750Z">
        <seg>그러나 때때로 변수의 범위를 제한하는 것이 유용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Sometimes, however, we may find ourselves in a situation where we have declared an argument to a function to be implicit, but now want to provide the argument explicitly.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T080222Z" creationid="tlqk3" creationdate="20220131T080202Z">
        <seg>하지만 때때로 우리는 우리 스스로 함수에 대한 인수가 암시적이도록 선언하는 걸 발견합니다. 그러나 지금 인수를 명시적으로 제공하길 원합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Special modes in Visual Studio Code (VS Code for short) and Emacs offer powerful support for writing and debugging proofs, and is much better suited for serious use.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T101444Z" creationid="tlqk35" creationdate="20220130T094304Z">
        <seg>비주얼 스튜디오 코드(짧게는 VS code)에서 특정 모드와 Emacs는 강력한 편집 기능과 증명 디버깅 기능을 지원합니다. 그리고 진지한 사용을 생각한다면 이게 훨씬 적합합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Start writing the proof from the top down, using <bpt i="2" x="2">&lt;c2&gt;</bpt>sorry<ept i="2">&lt;/c2&gt;</ept> to fill in subproofs.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T152732Z" creationid="tlqk3" creationdate="20220211T152732Z">
        <seg>하향식으로 증명 작성을 하작하려면 보조 증명에 <bpt i="2" x="2">&lt;c2&gt;</bpt>sorry<ept i="2">&lt;/c2&gt;</ept>를 채워 사용하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Such a function is <bpt i="2" x="2">&lt;e2&gt;</bpt>polymorphic<ept i="2">&lt;/e2&gt;</ept>: you expect the <bpt i="3" x="3">&lt;c3&gt;</bpt>cons<ept i="3">&lt;/c3&gt;</ept> function for <bpt i="4" x="4">&lt;c4&gt;</bpt>Nat<ept i="4">&lt;/c4&gt;</ept>, <bpt i="5" x="5">&lt;c5&gt;</bpt>Bool<ept i="5">&lt;/c5&gt;</ept>, or an arbitrary type <bpt i="6" x="6">&lt;c6&gt;</bpt>α<ept i="6">&lt;/c6&gt;</ept> to behave the same way.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T072614Z" creationid="tlqk3" creationdate="20220131T072614Z">
        <seg>이러한 함수는 <bpt i="2" x="2">&lt;e2&gt;</bpt>polymorphic<ept i="2">&lt;/e2&gt;</ept>입니다. 여러분은 <bpt i="3" x="3">&lt;c3&gt;</bpt>cons<ept i="3">&lt;/c3&gt;</ept>는  <bpt i="4" x="4">&lt;c4&gt;</bpt>Nat<ept i="4">&lt;/c4&gt;</ept>, <bpt i="5" x="5">&lt;c5&gt;</bpt>Bool<ept i="5">&lt;/c5&gt;</ept> 혹은 임의의 유형  <bpt i="6" x="6">&lt;c6&gt;</bpt>α<ept i="6">&lt;/c6&gt;</ept>에 대해 동일한 방식으로 동작해야 한다고 기대합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Such systems can have bugs, and it can be difficult to ensure that the results they deliver are correct.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T101659Z" creationid="tlqk35" creationdate="20220130T090524Z">
        <seg>이런 시스템들은 버그가 생길 수 있고, 그들이 올바르다고 도출한 결과를 확실히 보장하기가 어려울 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Suppose that, assuming <bpt i="0" x="0">&lt;c0&gt;</bpt>p<ept i="0">&lt;/c0&gt;</ept> as a hypothesis, we have a proof of <bpt i="1" x="1">&lt;c1&gt;</bpt>q<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T103153Z" creationid="tlqk3" creationdate="20220211T103153Z">
        <seg>그것은 <bpt i="0" x="0">&lt;c0&gt;</bpt>p<ept i="0">&lt;/c0&gt;</ept>를 가정으로 하면 <bpt i="1" x="1">&lt;c1&gt;</bpt>q<ept i="1">&lt;/c1&gt;</ept>의 증명을 가질 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Suppose we have <bpt i="1" x="1">&lt;c1&gt;</bpt>α : Sort i<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>β : Sort j<ept i="2">&lt;/c2&gt;</ept>, where the expression <bpt i="3" x="3">&lt;c3&gt;</bpt>β<ept i="3">&lt;/c3&gt;</ept> may depend on a variable <bpt i="4" x="4">&lt;c4&gt;</bpt>x : α<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220222T150033Z" creationid="tlqk35" creationdate="20220222T150033Z">
        <seg>우리가 <bpt i="1" x="1">&lt;c1&gt;</bpt>α : Sort i<ept i="1">&lt;/c1&gt;</ept>과 <bpt i="2" x="2">&lt;c2&gt;</bpt>β : Sort j<ept i="2">&lt;/c2&gt;</ept>을 갖고 있다고 가정합시다. 여기서 표현식 <bpt i="3" x="3">&lt;c3&gt;</bpt>β<ept i="3">&lt;/c3&gt;</ept>는 변수  <bpt i="4" x="4">&lt;c4&gt;</bpt>x : α<ept i="4">&lt;/c4&gt;</ept>에 의존할 수도 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Suppose we have an implementation of lists as:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T074503Z" creationid="tlqk3" creationdate="20220131T074503Z">
        <seg>우리가 리스트의 구현을 다음과 같이 했다고 가정합시다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Suppose you have the variable <bpt i="1" x="1">&lt;c1&gt;</bpt>x : α<ept i="1">&lt;/c1&gt;</ept> and you can construct an expression <bpt i="2" x="2">&lt;c2&gt;</bpt>t : β<ept i="2">&lt;/c2&gt;</ept>, then the expression <bpt i="3" x="3">&lt;c3&gt;</bpt>fun (x : α) =&gt; t<ept i="3">&lt;/c3&gt;</ept>, or, equivalently, <bpt i="4" x="4">&lt;c4&gt;</bpt>λ (x : α) =&gt; t<ept i="4">&lt;/c4&gt;</ept>, is an object of type <bpt i="5" x="5">&lt;c5&gt;</bpt>α → β<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T052835Z" creationid="tlqk3" creationdate="20220131T052835Z">
        <seg>여러분이 변수 <bpt i="1" x="1">&lt;c1&gt;</bpt>x : α<ept i="1">&lt;/c1&gt;</ept>를 갖고 있고 표현식 <bpt i="2" x="2">&lt;c2&gt;</bpt>t : β<ept i="2">&lt;/c2&gt;</ept>을 만들 수 있다 가정합시다. 그러면 표현식<bpt i="3" x="3">&lt;c3&gt;</bpt>fun (x : α) =&gt; t<ept i="3">&lt;/c3&gt;</ept> 또는 등가적으로 <bpt i="4" x="4">&lt;c4&gt;</bpt>λ (x : α) =&gt; t<ept i="4">&lt;/c4&gt;</ept>은 <bpt i="5" x="5">&lt;c5&gt;</bpt>α → β<ept i="5">&lt;/c5&gt;</ept> 유형인 대상입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Suppose you wish to write a function <bpt i="0" x="0">&lt;c0&gt;</bpt>cons<ept i="0">&lt;/c0&gt;</ept> which inserts a new element at the head of a list.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T072457Z" creationid="tlqk3" creationdate="20220131T072457Z">
        <seg>여러분이 리스트의 머리에 새 원소를 삽입하는 함수 <bpt i="0" x="0">&lt;c0&gt;</bpt>cons<ept i="0">&lt;/c0&gt;</ept>를 만들기 원한다 해봅시다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Suppose, however, that <bpt i="8" x="8">&lt;c8&gt;</bpt>β<ept i="8">&lt;/c8&gt;</ept> is of <bpt i="9" x="9">&lt;c9&gt;</bpt>Sort 0<ept i="9">&lt;/c9&gt;</ept>, that is, an element of <bpt i="10" x="10">&lt;c10&gt;</bpt>Prop<ept i="10">&lt;/c10&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220222T150733Z" creationid="tlqk35" creationdate="20220222T150733Z">
        <seg>그러나 <bpt i="8" x="8">&lt;c8&gt;</bpt>β<ept i="8">&lt;/c8&gt;</ept>가 <bpt i="9" x="9">&lt;c9&gt;</bpt>Sort 0<ept i="9">&lt;/c9&gt;</ept>형이라고 가정하면 즉, <bpt i="10" x="10">&lt;c10&gt;</bpt>Prop<ept i="10">&lt;/c10&gt;</ept>의 원소라면</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Systems of natural deduction for propositional logic also typically rely on the following rule:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T103010Z" creationid="tlqk3" creationdate="20220211T103010Z">
        <seg>명제논리의 자연 영역에 대한 시스템은 주로 다음 규칙에 의존합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Taking the left conjunct gives the desired conclusion, <bpt i="8" x="8">&lt;c8&gt;</bpt>p y<ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220222T144215Z" creationid="tlqk35" creationdate="20220222T144215Z">
        <seg>왼쪽의 결합자를 취하는 것은 원하는 결론 <bpt i="8" x="8">&lt;c8&gt;</bpt>p y<ept i="8">&lt;/c8&gt;</ept>을 줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>;<ept i="0">&lt;/c0&gt;</ept> can be omitted when a line break is used.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T070017Z" creationid="tlqk3" creationdate="20220131T070017Z">
        <seg>세미콜론<bpt i="0" x="0">&lt;c0&gt;</bpt>;<ept i="0">&lt;/c0&gt;</ept>은 줄을 분리할 때 사용되므로 생략될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>def<ept i="0">&lt;/c0&gt;</ept> keyword declares new constant symbols into the working environment.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T035544Z" creationid="tlqk3" creationdate="20220131T035544Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>def<ept i="0">&lt;/c0&gt;</ept>는 작업 환경에 새로운 상수기호를 선언합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>example<ept i="0">&lt;/c0&gt;</ept> command states a theorem without naming it or storing it in the permanent context.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T164040Z" creationid="tlqk3" creationdate="20220211T163955Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>example<ept i="0">&lt;/c0&gt;</ept> 명령은 이름이 없이 영구적인 맥락으로 저장하지 않는 정리를 기술합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>open<ept i="0">&lt;/c0&gt;</ept> command brings the shorter names into the current context.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T071322Z" creationid="tlqk3" creationdate="20220131T071322Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>open<ept i="0">&lt;/c0&gt;</ept> 명령은 현재 맥락에서 짧은 이름을 가져옵니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>show<ept i="0">&lt;/c0&gt;</ept> command does nothing more than annotate the type, and, internally, all the presentations of <bpt i="1" x="1">&lt;c1&gt;</bpt>t1<ept i="1">&lt;/c1&gt;</ept> that we have seen produce the same term.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T151755Z" creationid="tlqk3" creationdate="20220211T151320Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>show<ept i="0">&lt;/c0&gt;</ept> 명령은 유형에 주석을 달 뿐이고, 내부적으로 우리가 본 <bpt i="1" x="1">&lt;c1&gt;</bpt>t1<ept i="1">&lt;/c1&gt;</ept>의 모든 나타남이 동일한 용어를 생성할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>sorry<ept i="0">&lt;/c0&gt;</ept> identifier magically produces a proof of anything, or provides an object of any data type at all.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T152513Z" creationid="tlqk3" creationdate="20220211T152513Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>sorry<ept i="0">&lt;/c0&gt;</ept> 식별자는 어떤 증명이든 마법같이 만듭니다. 혹은 임의의 데이터 유형의 객체를 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>variable<ept i="0">&lt;/c0&gt;</ept> command instructs Lean to insert the declared variables as bound variables in definitions that refer to them by name.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T070617Z" creationid="tlqk3" creationdate="20220131T070617Z">
        <seg> <bpt i="0" x="0">&lt;c0&gt;</bpt>variable<ept i="0">&lt;/c0&gt;</ept>명령은 Lean에게 선언된 변수를 그들을 이름으로 참조하는 정의의 구속 변수로 삽입하라고 지시합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="2" x="2">&lt;c2&gt;</bpt>@<ept i="2">&lt;/c2&gt;</ept> symbol and the difference between the round and curly braces will be explained momentarily.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T074106Z" creationid="tlqk3" creationdate="20220131T074106Z">
        <seg> <bpt i="2" x="2">&lt;c2&gt;</bpt>@<ept i="2">&lt;/c2&gt;</ept> 기호와 소괄호와 중괄호 사이의 차이는 곧 설명할 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="5" x="5">&lt;c5&gt;</bpt>#check<ept i="5">&lt;/c5&gt;</ept> command asks Lean to report their types; in Lean, auxiliary commands that query the system for information typically begin with the hash (#) symbol.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T035943Z" creationid="tlqk3" creationdate="20220131T035843Z">
        <seg><bpt i="5" x="5">&lt;c5&gt;</bpt>#check<ept i="5">&lt;/c5&gt;</ept> 명령은 린에게 그것의 유형을 보고하도록 요청합니다. 린에서 시스템에게 정보를 불러오는 보조 명령은 주로 해시(#) 기호로 시작합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="6" x="6">&lt;c6&gt;</bpt>#eval<ept i="6">&lt;/c6&gt;</ept> command asks Lean to evaluate the given expression.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T040038Z" creationid="tlqk3" creationdate="20220131T035934Z">
        <seg><bpt i="6" x="6">&lt;c6&gt;</bpt>#eval<ept i="6">&lt;/c6&gt;</ept> 명령은 린에게 제시된 표현의 값을 평가하도록 요청합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="8" x="8">&lt;c8&gt;</bpt>let<ept i="8">&lt;/c8&gt;</ept> construct is a stronger means of abbreviation, and there are expressions of the form <bpt i="9" x="9">&lt;c9&gt;</bpt>let a := t1; t2<ept i="9">&lt;/c9&gt;</ept> that cannot be expressed as <bpt i="10" x="10">&lt;c10&gt;</bpt>(fun a =&gt; t2) t1<ept i="10">&lt;/c10&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T070332Z" creationid="tlqk3" creationdate="20220131T070332Z">
        <seg> <bpt i="8" x="8">&lt;c8&gt;</bpt>let<ept i="8">&lt;/c8&gt;</ept> 생성은 약어의 의미로 더 강합니다. 그리고 <bpt i="9" x="9">&lt;c9&gt;</bpt>let a := t1; t2<ept i="9">&lt;/c9&gt;</ept> 형태의 표현식은 <bpt i="10" x="10">&lt;c10&gt;</bpt>(fun a =&gt; t2) t1<ept i="10">&lt;/c10&gt;</ept>같이 표현될 수 없는 식이 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;e0&gt;</bpt>Lean Theorem Prover<ept i="0">&lt;/e0&gt;</ept> aims to bridge the gap between interactive and automated theorem proving, by situating automated tools and methods in a framework that supports user interaction and the construction of fully specified axiomatic proofs.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T101623Z" creationid="tlqk35" creationdate="20220130T091353Z">
        <seg> <bpt i="0" x="0">&lt;e0&gt;</bpt>Lean 증명 보조기<ept i="0">&lt;/e0&gt;</ept>는 사용자의 상호작용과 완전히 구체화된 공리적 증명의 생성을 돕는 자동화된 도구와 방법들을 프레임워크에 둠으로써 상호작용과 자동화된 정리 증명 사이의 빈틈을 메우는 것을 목표로 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;e0&gt;</bpt>Lean<ept i="0">&lt;/e0&gt;</ept> project was launched by Leonardo de Moura at Microsoft Research Redmond in 2013.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T101549Z" creationid="tlqk35" creationdate="20220130T093113Z">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>Lean<ept i="0">&lt;/e0&gt;</ept> 프로젝트는 마이크로소프트 연구소 Redmond의 Leonardo de Moura가 2013년 시작했습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;e0&gt;</bpt>or-elimination<ept i="0">&lt;/e0&gt;</ept> rule is slightly more complicated.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T171319Z" creationid="tlqk3" creationdate="20220211T171319Z">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>or-제거<ept i="0">&lt;/e0&gt;</ept> 규칙은 약간 더 복잡합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The Calculus of Constructions therefore identifies dependent arrow types with forall-expressions in this way.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220222T142801Z" creationid="tlqk35" creationdate="20220222T142801Z">
        <seg>그러므로 직관주의 계산법은 의존 화살표 유형을 이처럼 모든-표현식으로 바라봅니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The Universal Quantifier</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220222T140912Z" creationid="tlqk35" creationdate="20220222T140912Z">
        <seg>전칭 한정기호</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The advantage is that we can simply write <bpt i="0" x="0">&lt;c0&gt;</bpt>trans_r hab hbc<ept i="0">&lt;/c0&gt;</ept> as a proof of <bpt i="1" x="1">&lt;c1&gt;</bpt>r a c<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220222T145411Z" creationid="tlqk35" creationdate="20220222T145411Z">
        <seg>이것의 장점은 우리가 간단히 <bpt i="0" x="0">&lt;c0&gt;</bpt>trans_r hab hbc<ept i="0">&lt;/c0&gt;</ept>을  <bpt i="1" x="1">&lt;c1&gt;</bpt>r a c<ept i="1">&lt;/c1&gt;</ept>의 증명으로 쓸 수 있다는 것이고,The advantage is that we can simply write <bpt i="0" x="0">&lt;c0&gt;</bpt>trans_r hab hbc<ept i="0">&lt;/c0&gt;</ept> as a proof of <bpt i="1" x="1">&lt;c1&gt;</bpt>r a c<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The arbitrary fact, <bpt i="0" x="0">&lt;c0&gt;</bpt>q<ept i="0">&lt;/c0&gt;</ept>, that follows from falsity is an implicit argument in <bpt i="1" x="1">&lt;c1&gt;</bpt>False.elim<ept i="1">&lt;/c1&gt;</ept> and is inferred automatically.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T173532Z" creationid="tlqk3" creationdate="20220211T173532Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>q<ept i="0">&lt;/c0&gt;</ept>가 어떤 거짓 명제로부터 나온다는 사실은 <bpt i="1" x="1">&lt;c1&gt;</bpt>False.elim<ept i="1">&lt;/c1&gt;</ept>에 대한 암시적 인수이며 자동적으로 추론됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The canonical way to prove <bpt i="1" x="1">&lt;c1&gt;</bpt>∀ y : α, p y<ept i="1">&lt;/c1&gt;</ept> is to take an arbitrary <bpt i="2" x="2">&lt;c2&gt;</bpt>y<ept i="2">&lt;/c2&gt;</ept>, and prove <bpt i="3" x="3">&lt;c3&gt;</bpt>p y<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220222T143951Z" creationid="tlqk35" creationdate="20220222T143951Z">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>∀ y : α, p y<ept i="1">&lt;/c1&gt;</ept>을 증명하는 표준 방법은 임의의 <bpt i="2" x="2">&lt;c2&gt;</bpt>y<ept i="2">&lt;/c2&gt;</ept>를 받고  <bpt i="3" x="3">&lt;c3&gt;</bpt>p y<ept i="3">&lt;/c3&gt;</ept>임을 증명하는 것 입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The classical axioms also give you access to additional patterns of proof that can be justified by appeal to <bpt i="0" x="0">&lt;c0&gt;</bpt>em<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T162445Z" creationid="tlqk3" creationdate="20220211T162445Z">
        <seg>고전적 공리도 여러분에게 <bpt i="0" x="0">&lt;c0&gt;</bpt>em<ept i="0">&lt;/c0&gt;</ept>에 호소하여 정당화될 수 있는 추가적인 증명 패턴의 접근을 줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The command <bpt i="0" x="0">&lt;c0&gt;</bpt>open List<ept i="0">&lt;/c0&gt;</ept> allows you to use the shorter names:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T071541Z" creationid="tlqk3" creationdate="20220131T071541Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>open List<ept i="0">&lt;/c0&gt;</ept>  명령은 여러분이 더 짧은 이름을 사용할 수 있게 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The connective <bpt i="0" x="0">&lt;c0&gt;</bpt>False<ept i="0">&lt;/c0&gt;</ept> has a single elimination rule, <bpt i="1" x="1">&lt;c1&gt;</bpt>False.elim<ept i="1">&lt;/c1&gt;</ept>, which expresses the fact that anything follows from a contradiction.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T173110Z" creationid="tlqk3" creationdate="20220211T173110Z">
        <seg>연결사 <bpt i="0" x="0">&lt;c0&gt;</bpt>False<ept i="0">&lt;/c0&gt;</ept>은 하나의 제거 규칙 <bpt i="1" x="1">&lt;c1&gt;</bpt>False.elim<ept i="1">&lt;/c1&gt;</ept>을 갖습니다. 이것은 모순으로부터 어떤 것이든 도출된다는 사실을 표현합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The difference is that given <bpt i="0" x="0">&lt;c0&gt;</bpt>hp : p<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>hq : q<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>And.intro hp hq<ept i="2">&lt;/c2&gt;</ept> has type <bpt i="3" x="3">&lt;c3&gt;</bpt>p ∧ q : Prop<ept i="3">&lt;/c3&gt;</ept>, while <bpt i="4" x="4">&lt;c4&gt;</bpt>Prod hp hq<ept i="4">&lt;/c4&gt;</ept> has type <bpt i="5" x="5">&lt;c5&gt;</bpt>p × q : Type<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T164753Z" creationid="tlqk3" creationdate="20220211T164753Z">
        <seg>차이는 <bpt i="0" x="0">&lt;c0&gt;</bpt>hp : p<ept i="0">&lt;/c0&gt;</ept>와 <bpt i="1" x="1">&lt;c1&gt;</bpt>hq : q<ept i="1">&lt;/c1&gt;</ept>가 주어졌을 때 <bpt i="2" x="2">&lt;c2&gt;</bpt>And.intro hp hq<ept i="2">&lt;/c2&gt;</ept>는 <bpt i="3" x="3">&lt;c3&gt;</bpt>p ∧ q : Prop<ept i="3">&lt;/c3&gt;</ept>형을 갖는 한편 <bpt i="4" x="4">&lt;c4&gt;</bpt>Prod hp hq<ept i="4">&lt;/c4&gt;</ept>는 <bpt i="5" x="5">&lt;c5&gt;</bpt>p × q : Type<ept i="5">&lt;/c5&gt;</ept>형을 갖는다는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The elimination rule states:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220222T142021Z" creationid="tlqk35" creationdate="20220222T142021Z">
        <seg>제거 규칙은 이와 같이 말합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The example above shows that <bpt i="11" x="11">&lt;c11&gt;</bpt>Nat.add 3<ept i="11">&lt;/c11&gt;</ept> has type <bpt i="12" x="12">&lt;c12&gt;</bpt>Nat → Nat<ept i="12">&lt;/c12&gt;</ept>, that is, <bpt i="13" x="13">&lt;c13&gt;</bpt>Nat.add 3<ept i="13">&lt;/c13&gt;</ept> returns a function that "waits" for a second argument, <bpt i="14" x="14">&lt;c14&gt;</bpt>n<ept i="14">&lt;/c14&gt;</ept>, which is then equivalent to writing <bpt i="15" x="15">&lt;c15&gt;</bpt>Nat.add 3 n<ept i="15">&lt;/c15&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T043603Z" creationid="tlqk3" creationdate="20220131T043603Z">
        <seg>위의 예제에서 <bpt i="11" x="11">&lt;c11&gt;</bpt>Nat.add 3<ept i="11">&lt;/c11&gt;</ept>는 <bpt i="12" x="12">&lt;c12&gt;</bpt>Nat → Nat<ept i="12">&lt;/c12&gt;</ept>유형을 가짐을  보였습니다. 즉 <bpt i="13" x="13">&lt;c13&gt;</bpt>Nat.add 3<ept i="13">&lt;/c13&gt;</ept>은 두번째 인자 <bpt i="14" x="14">&lt;c14&gt;</bpt>n<ept i="14">&lt;/c14&gt;</ept>을 "기다리는" 함수를 반환하는 것입니다. 이것은 <bpt i="15" x="15">&lt;c15&gt;</bpt>Nat.add 3 n<ept i="15">&lt;/c15&gt;</ept>로 쓰는 것과 동등합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The expression <bpt i="0" x="0">&lt;c0&gt;</bpt>And.intro h1 h2<ept i="0">&lt;/c0&gt;</ept> builds a proof of <bpt i="1" x="1">&lt;c1&gt;</bpt>p ∧ q<ept i="1">&lt;/c1&gt;</ept> using proofs <bpt i="2" x="2">&lt;c2&gt;</bpt>h1 : p<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>h2 : q<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T163623Z" creationid="tlqk3" creationdate="20220211T163623Z">
        <seg>표현식 <bpt i="0" x="0">&lt;c0&gt;</bpt>And.intro h1 h2<ept i="0">&lt;/c0&gt;</ept>은 <bpt i="1" x="1">&lt;c1&gt;</bpt>p ∧ q<ept i="1">&lt;/c1&gt;</ept>의 증명을 <bpt i="2" x="2">&lt;c2&gt;</bpt>h1 : p<ept i="2">&lt;/c2&gt;</ept>과 <bpt i="3" x="3">&lt;c3&gt;</bpt>h2 : q<ept i="3">&lt;/c3&gt;</ept>의 증명을 사용하여 만듭니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The expression <bpt i="0" x="0">&lt;c0&gt;</bpt>And.left h<ept i="0">&lt;/c0&gt;</ept> creates a proof of <bpt i="1" x="1">&lt;c1&gt;</bpt>p<ept i="1">&lt;/c1&gt;</ept> from a proof <bpt i="2" x="2">&lt;c2&gt;</bpt>h : p ∧ q<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T164310Z" creationid="tlqk3" creationdate="20220211T164310Z">
        <seg>표현식 <bpt i="0" x="0">&lt;c0&gt;</bpt>And.left h<ept i="0">&lt;/c0&gt;</ept>는 <bpt i="2" x="2">&lt;c2&gt;</bpt>h : p ∧ q<ept i="2">&lt;/c2&gt;</ept>의 증명으로부터 <bpt i="1" x="1">&lt;c1&gt;</bpt>p<ept i="1">&lt;/c1&gt;</ept>의 증명을 만듭니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The expression <bpt i="0" x="0">&lt;c0&gt;</bpt>Iff.intro h1 h2<ept i="0">&lt;/c0&gt;</ept> produces a proof of <bpt i="1" x="1">&lt;c1&gt;</bpt>p ↔ q<ept i="1">&lt;/c1&gt;</ept> from <bpt i="2" x="2">&lt;c2&gt;</bpt>h1 : p → q<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>h2 : q → p<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T174003Z" creationid="tlqk3" creationdate="20220211T174003Z">
        <seg>표현식 <bpt i="0" x="0">&lt;c0&gt;</bpt>Iff.intro h1 h2<ept i="0">&lt;/c0&gt;</ept>은 <bpt i="2" x="2">&lt;c2&gt;</bpt>h1 : p → q<ept i="2">&lt;/c2&gt;</ept>과 <bpt i="3" x="3">&lt;c3&gt;</bpt>h2 : q → p<ept i="3">&lt;/c3&gt;</ept>으로부터  <bpt i="1" x="1">&lt;c1&gt;</bpt>p ↔ q<ept i="1">&lt;/c1&gt;</ept>의 증명을 생성합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The expression <bpt i="0" x="0">&lt;c0&gt;</bpt>Or.intro_left q hp<ept i="0">&lt;/c0&gt;</ept> creates a proof of <bpt i="1" x="1">&lt;c1&gt;</bpt>p ∨ q<ept i="1">&lt;/c1&gt;</ept> from a proof <bpt i="2" x="2">&lt;c2&gt;</bpt>hp : p<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T171148Z" creationid="tlqk3" creationdate="20220211T171148Z">
        <seg>표현식 <bpt i="0" x="0">&lt;c0&gt;</bpt>Or.intro_left q hp<ept i="0">&lt;/c0&gt;</ept>은 <bpt i="2" x="2">&lt;c2&gt;</bpt>hp : p<ept i="2">&lt;/c2&gt;</ept>의 증명으로부터 <bpt i="1" x="1">&lt;c1&gt;</bpt>p ∨ q<ept i="1">&lt;/c1&gt;</ept>의 증명을 만듭니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The expression <bpt i="0" x="0">&lt;c0&gt;</bpt>fun x : Nat =&gt; x<ept i="0">&lt;/c0&gt;</ept> denotes the identity function on <bpt i="1" x="1">&lt;c1&gt;</bpt>Nat<ept i="1">&lt;/c1&gt;</ept>, the expression <bpt i="2" x="2">&lt;c2&gt;</bpt>fun x : Nat =&gt; true<ept i="2">&lt;/c2&gt;</ept> denotes the constant function that always returns <bpt i="3" x="3">&lt;c3&gt;</bpt>true<ept i="3">&lt;/c3&gt;</ept>, and <bpt i="4" x="4">&lt;c4&gt;</bpt>fun x : Nat =&gt; g (f x)<ept i="4">&lt;/c4&gt;</ept> denotes the composition of <bpt i="5" x="5">&lt;c5&gt;</bpt>f<ept i="5">&lt;/c5&gt;</ept> and <bpt i="6" x="6">&lt;c6&gt;</bpt>g<ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T053827Z" creationid="tlqk3" creationdate="20220131T053827Z">
        <seg>표현식 <bpt i="0" x="0">&lt;c0&gt;</bpt>fun x : Nat =&gt; x<ept i="0">&lt;/c0&gt;</ept>은 <bpt i="1" x="1">&lt;c1&gt;</bpt>Nat<ept i="1">&lt;/c1&gt;</ept>에 대한 항등함수를 의미합니다. 표현식 <bpt i="2" x="2">&lt;c2&gt;</bpt>fun x : Nat =&gt; true<ept i="2">&lt;/c2&gt;</ept>은 항상  <bpt i="3" x="3">&lt;c3&gt;</bpt>true<ept i="3">&lt;/c3&gt;</ept>을 반환하는 상수함수를 가리합니다. 그리고 <bpt i="4" x="4">&lt;c4&gt;</bpt>fun x : Nat =&gt; g (f x)<ept i="4">&lt;/c4&gt;</ept>는 <bpt i="5" x="5">&lt;c5&gt;</bpt>f<ept i="5">&lt;/c5&gt;</ept>와 <bpt i="6" x="6">&lt;c6&gt;</bpt>g<ept i="6">&lt;/c6&gt;</ept>의 합성함수를 가리킵니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The expression <bpt i="1" x="1">&lt;c1&gt;</bpt>let a := t1; t2<ept i="1">&lt;/c1&gt;</ept> is definitionally equal to the result of replacing every occurrence of <bpt i="2" x="2">&lt;c2&gt;</bpt>a<ept i="2">&lt;/c2&gt;</ept> in <bpt i="3" x="3">&lt;c3&gt;</bpt>t2<ept i="3">&lt;/c3&gt;</ept> by <bpt i="4" x="4">&lt;c4&gt;</bpt>t1<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T065858Z" creationid="tlqk3" creationdate="20220131T065858Z">
        <seg>표현식 <bpt i="1" x="1">&lt;c1&gt;</bpt>let a := t1; t2<ept i="1">&lt;/c1&gt;</ept> 는 <bpt i="3" x="3">&lt;c3&gt;</bpt>t2<ept i="3">&lt;/c3&gt;</ept>  속 <bpt i="2" x="2">&lt;c2&gt;</bpt>a<ept i="2">&lt;/c2&gt;</ept>의 모든 나타남(occurrence)을 <bpt i="4" x="4">&lt;c4&gt;</bpt>t1<ept i="4">&lt;/c4&gt;</ept>으로 대체한 결과에 대해 정의상으로 같습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The expression <bpt i="4" x="4">&lt;c4&gt;</bpt>Iff.mp h<ept i="4">&lt;/c4&gt;</ept> produces a proof of <bpt i="5" x="5">&lt;c5&gt;</bpt>p → q<ept i="5">&lt;/c5&gt;</ept> from <bpt i="6" x="6">&lt;c6&gt;</bpt>h : p ↔ q<ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T174039Z" creationid="tlqk3" creationdate="20220211T174039Z">
        <seg>표현식 <bpt i="4" x="4">&lt;c4&gt;</bpt>Iff.mp h<ept i="4">&lt;/c4&gt;</ept>는 <bpt i="6" x="6">&lt;c6&gt;</bpt>h : p ↔ q<ept i="6">&lt;/c6&gt;</ept>으로부터 <bpt i="5" x="5">&lt;c5&gt;</bpt>p → q<ept i="5">&lt;/c5&gt;</ept>의 증명을 생성합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The fact that the rules for implication in a proof system for natural deduction correspond exactly to the rules governing abstraction and application for functions is an instance of the <bpt i="0" x="0">&lt;e0&gt;</bpt>Curry-Howard isomorphism<ept i="0">&lt;/e0&gt;</ept>, sometimes known as the <bpt i="1" x="1">&lt;e1&gt;</bpt>propositions-as-types<ept i="1">&lt;/e1&gt;</ept> paradigm.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T141449Z" creationid="tlqk3" creationdate="20220211T140142Z">
        <seg>자연 추론을 위한 증명 보조기에서 함의에 대한 규칙이 함수 추상화와 함수 적용을 지배하는 규칙과 정확히 일치한다는 사실은 <bpt i="0" x="0">&lt;e0&gt;</bpt>커리-하워드 동형론(Curry-Howard isomorphism) <ept i="0">&lt;/e0&gt;</ept>의 한 예이며, 때때로 <bpt i="1" x="1">&lt;e1&gt;</bpt>유형으로써 명제(propositions-as-types)<ept i="1">&lt;/e1&gt;</ept> 패러다임으로 알려져 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The first function returns a type <bpt i="5" x="5">&lt;c5&gt;</bpt>γ<ept i="5">&lt;/c5&gt;</ept> so that is also the return type of the <bpt i="6" x="6">&lt;c6&gt;</bpt>compose<ept i="6">&lt;/c6&gt;</ept> function.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T065545Z" creationid="tlqk3" creationdate="20220131T065545Z">
        <seg>첫 번째 함수는 유형 <bpt i="5" x="5">&lt;c5&gt;</bpt>γ<ept i="5">&lt;/c5&gt;</ept> 를 반환하여 이게 <bpt i="6" x="6">&lt;c6&gt;</bpt>compose<ept i="6">&lt;/c6&gt;</ept> 함수의 반환형이 되게 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The first is to run it from the web: a Javascript version of Lean, a standard library of definitions and theorems, and an editor are actually downloaded to your browser and run there.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T101515Z" creationid="tlqk35" creationdate="20220130T093929Z">
        <seg>첫째는 웹으로부터 이것을 실행하는 것입니다.(Lean의 자바스크립트 버전, 정의와 정리들의 표준 라이브러리, 편집자는 실제로 여러분의 브라우저에 다운로드를 시키고 거기서 실행하는 것임)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The first version of this book was written for Lean 2, and the Lean 3 version is is available <bpt i="2" x="2">&lt;a2&gt;</bpt>here<ept i="2">&lt;/a2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T074119Z" creationid="tlqk35" creationdate="20220130T074119Z">
        <seg>이 책의 첫번째 버전은 린 2와 린 3를 대상으로 작성되었습니다. 그것은 <bpt i="2" x="2">&lt;a2&gt;</bpt>여기<ept i="2">&lt;/a2&gt;</ept>에서 이용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following calls a given function twice passing the output of the first invocation to the second:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T065103Z" creationid="tlqk3" creationdate="20220131T065103Z">
        <seg>다음은 주어진 함수를 첫번째 호출의 출력을 두번째에 전달하는 것으로 두 번 호출합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following list includes a number of common identities.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T161602Z" creationid="tlqk3" creationdate="20220211T161602Z">
        <seg>다음 리스트는 흔히 사용되는 항등식들을 포함합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following yields the same result:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T064541Z" creationid="tlqk3" creationdate="20220131T064541Z">
        <seg>다음은 같은 결과를 만듭니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The full list of axioms that are used in Lean to support classical reasoning are discussed in <bpt i="0" x="0">&lt;a0&gt;</bpt>Axioms and Computations<ept i="0">&lt;/a0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T161229Z" creationid="tlqk3" creationdate="20220211T161229Z">
        <seg>고전 추론을 지원하기 위해 린에서 사용된 모든 공리의 리스트는 <bpt i="0" x="0">&lt;a0&gt;</bpt>공리와 계산<ept i="0">&lt;/a0&gt;</ept>에서 다뤄집니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The function <bpt i="6" x="6">&lt;c6&gt;</bpt>Prod<ept i="6">&lt;/c6&gt;</ept> is similarly polymorphic:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T051722Z" creationid="tlqk3" creationdate="20220131T051722Z">
        <seg>마찬가지로 <bpt i="6" x="6">&lt;c6&gt;</bpt>Prod<ept i="6">&lt;/c6&gt;</ept> 함수는 다형적입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The functions <bpt i="0" x="0">&lt;c0&gt;</bpt>f<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>g<ept i="1">&lt;/c1&gt;</ept> above denote the same function.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T074426Z" creationid="tlqk3" creationdate="20220131T074426Z">
        <seg>위 함수  <bpt i="0" x="0">&lt;c0&gt;</bpt>f<ept i="0">&lt;/c0&gt;</ept>와 <bpt i="1" x="1">&lt;c1&gt;</bpt>g<ept i="1">&lt;/c1&gt;</ept>는 같은 함수를 지칭합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The general form of a definition is <bpt i="0" x="0">&lt;c0&gt;</bpt>def foo : α := bar<ept i="0">&lt;/c0&gt;</ept> where <bpt i="1" x="1">&lt;c1&gt;</bpt>α<ept i="1">&lt;/c1&gt;</ept> is the type returned from the expression <bpt i="2" x="2">&lt;c2&gt;</bpt>bar<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T064659Z" creationid="tlqk3" creationdate="20220131T064659Z">
        <seg>정의의 일반적인 형태는  <bpt i="0" x="0">&lt;c0&gt;</bpt>def foo : α := bar<ept i="0">&lt;/c0&gt;</ept>입니다. 여기서  <bpt i="1" x="1">&lt;c1&gt;</bpt>α<ept i="1">&lt;/c1&gt;</ept> 는 식 <bpt i="2" x="2">&lt;c2&gt;</bpt>bar<ept i="2">&lt;/c2&gt;</ept>로부터 반환되는 유형입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The general form of a lambda expression is <bpt i="0" x="0">&lt;c0&gt;</bpt>fun x : α =&gt; t<ept i="0">&lt;/c0&gt;</ept>, where the variable <bpt i="1" x="1">&lt;c1&gt;</bpt>x<ept i="1">&lt;/c1&gt;</ept> is a "bound variable": it is really a placeholder, whose "scope" does not extend beyond the expression <bpt i="2" x="2">&lt;c2&gt;</bpt>t<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T055206Z" creationid="tlqk3" creationdate="20220131T055206Z">
        <seg>람다 표현식의 일반적인 형태는 <bpt i="0" x="0">&lt;c0&gt;</bpt>fun x : α =&gt; t<ept i="0">&lt;/c0&gt;</ept>입니다. 여기서 변수 <bpt i="1" x="1">&lt;c1&gt;</bpt>x<ept i="1">&lt;/c1&gt;</ept>는 "구속변수"입니다. 이는 그것의 "범위"가 표현식  <bpt i="2" x="2">&lt;c2&gt;</bpt>t<ept i="2">&lt;/c2&gt;</ept> 안으로 제한되는 '자리차지자'일 뿐 입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The goal is to support both mathematical reasoning and reasoning about complex systems, and to verify claims in both domains.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T101618Z" creationid="tlqk35" creationdate="20220130T091436Z">
        <seg>목표는 수학적 추론과 복잡한 시스템에 대한 추론을 모두 지원하고 양쪽 영역의 주장을 식별하게 만드는 겁이다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The gold standard for supporting a mathematical claim is to provide a proof, and twentieth-century developments in logic show most if not all conventional proof methods can be reduced to a small set of axioms and rules in any of a number of foundational systems.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T085213Z" creationid="tlqk35" creationdate="20220130T085213Z">
        <seg>수학 진술을 지지하기 위한 황금률은 증명을 제공하는 것이며 20세기 논리학의 발전은 기존은 몇 가지의 공리의 모임과 기초계의 몇 가지 규칙으로 축소될 수 있음을 거의 보여주었습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The idea is as follows.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220222T150354Z" creationid="tlqk35" creationdate="20220222T150354Z">
        <seg>아이디어는 다음과 같습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The idea is that we can prove <bpt i="1" x="1">&lt;c1&gt;</bpt>r<ept i="1">&lt;/c1&gt;</ept> from <bpt i="2" x="2">&lt;c2&gt;</bpt>p ∨ q<ept i="2">&lt;/c2&gt;</ept>, by showing that <bpt i="3" x="3">&lt;c3&gt;</bpt>r<ept i="3">&lt;/c3&gt;</ept> follows from <bpt i="4" x="4">&lt;c4&gt;</bpt>p<ept i="4">&lt;/c4&gt;</ept> and that <bpt i="5" x="5">&lt;c5&gt;</bpt>r<ept i="5">&lt;/c5&gt;</ept> follows from <bpt i="6" x="6">&lt;c6&gt;</bpt>q<ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T171540Z" creationid="tlqk3" creationdate="20220211T171540Z">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>r<ept i="3">&lt;/c3&gt;</ept>이 <bpt i="4" x="4">&lt;c4&gt;</bpt>p<ept i="4">&lt;/c4&gt;</ept>로부터 나오고 <bpt i="5" x="5">&lt;c5&gt;</bpt>r<ept i="5">&lt;/c5&gt;</ept>이 <bpt i="6" x="6">&lt;c6&gt;</bpt>q<ept i="6">&lt;/c6&gt;</ept>로부터 나온다는 것을 보임으로써 우리가 <bpt i="2" x="2">&lt;c2&gt;</bpt>p ∨ q<ept i="2">&lt;/c2&gt;</ept>로부터 <bpt i="1" x="1">&lt;c1&gt;</bpt>r<ept i="1">&lt;/c1&gt;</ept>을 증명할 수 있다는 생각입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The impredicativity of Prop means that we can form propositions that quantify over <bpt i="4" x="4">&lt;c4&gt;</bpt>α → Prop<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220222T153456Z" creationid="tlqk35" creationdate="20220222T153456Z">
        <seg>Prop의 impredicativity는 우리가 <bpt i="4" x="4">&lt;c4&gt;</bpt>α → Prop<ept i="4">&lt;/c4&gt;</ept>를 한정하는 명제를 세울 수 있음을 의미합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The introduction and elimination rules we have seen so far are all constructive, which is to say, they reflect a computational understanding of the logical connectives based on the propositions-as-types correspondence.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T175719Z" creationid="tlqk3" creationdate="20220211T175719Z">
        <seg>지금까지 우리가 본 도입과 제거 규칙은 모두 직관적입니다. 그 말은 그들은 유형으로써 명제 대응에 기반한 논리 연결사의 계산적인 이해를 반영하고 있다는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The judicious use of Unicode improves legibility, and all modern editors have great support for it.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T041032Z" creationid="tlqk3" creationdate="20220131T041032Z">
        <seg>분별있는 유니코드의 사용은 가독성을 개선합니다. 그리고 현대의 모든 편집기는 그것의 사용을 지원합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The last chapter introduced you to methods that construct proofs of statements involving the propositional connectives.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220222T140720Z" creationid="tlqk35" creationdate="20220222T140720Z">
        <seg>지난 장에서 여러분에게 명제적 연결사를 포함한 문장의 증명을 구성하는 방법을 소개했습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The last expression, for example, denotes the function that takes three types, <bpt i="0" x="0">&lt;c0&gt;</bpt>α<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>β<ept i="1">&lt;/c1&gt;</ept>, and <bpt i="2" x="2">&lt;c2&gt;</bpt>γ<ept i="2">&lt;/c2&gt;</ept>, and two functions, <bpt i="3" x="3">&lt;c3&gt;</bpt>g : β → γ<ept i="3">&lt;/c3&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt>f : α → β<ept i="4">&lt;/c4&gt;</ept>, and returns the composition of <bpt i="5" x="5">&lt;c5&gt;</bpt>g<ept i="5">&lt;/c5&gt;</ept> and <bpt i="6" x="6">&lt;c6&gt;</bpt>f<ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T054620Z" creationid="tlqk3" creationdate="20220131T054620Z">
        <seg>마지막 표현식은 세 유형 <bpt i="0" x="0">&lt;c0&gt;</bpt>α<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>β<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>γ<ept i="2">&lt;/c2&gt;</ept>과 두 함수 <bpt i="3" x="3">&lt;c3&gt;</bpt>g : β → γ<ept i="3">&lt;/c3&gt;</ept>과 <bpt i="4" x="4">&lt;c4&gt;</bpt>f : α → β<ept i="4">&lt;/c4&gt;</ept>을 받고 <bpt i="5" x="5">&lt;c5&gt;</bpt>g<ept i="5">&lt;/c5&gt;</ept>과 <bpt i="6" x="6">&lt;c6&gt;</bpt>f<ept i="6">&lt;/c6&gt;</ept>의 합성을 반환하는 함수를 나타냅니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The list is indefinite, so that there is a <bpt i="5" x="5">&lt;c5&gt;</bpt>Type n<ept i="5">&lt;/c5&gt;</ept> for every natural number <bpt i="6" x="6">&lt;c6&gt;</bpt>n<ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T050513Z" creationid="tlqk3" creationdate="20220131T050513Z">
        <seg>모든 자연수 <bpt i="6" x="6">&lt;c6&gt;</bpt>n<ept i="6">&lt;/c6&gt;</ept>에 대해 <bpt i="5" x="5">&lt;c5&gt;</bpt>Type n<ept i="5">&lt;/c5&gt;</ept>가 있어서 이런 리스트를 무한히 나열할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The name <bpt i="0" x="0">&lt;c0&gt;</bpt>double<ept i="0">&lt;/c0&gt;</ept> is defined as a function that takes an input parameter <bpt i="1" x="1">&lt;c1&gt;</bpt>x<ept i="1">&lt;/c1&gt;</ept> of type <bpt i="2" x="2">&lt;c2&gt;</bpt>Nat<ept i="2">&lt;/c2&gt;</ept>, where the result of the call is <bpt i="3" x="3">&lt;c3&gt;</bpt>x + x<ept i="3">&lt;/c3&gt;</ept>, so it is returning type <bpt i="4" x="4">&lt;c4&gt;</bpt>Nat<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T064325Z" creationid="tlqk3" creationdate="20220131T064325Z">
        <seg>이름 <bpt i="0" x="0">&lt;c0&gt;</bpt>double<ept i="0">&lt;/c0&gt;</ept>은 <bpt i="2" x="2">&lt;c2&gt;</bpt>Nat<ept i="2">&lt;/c2&gt;</ept> 유형의 입력 매개변수 <bpt i="1" x="1">&lt;c1&gt;</bpt>x<ept i="1">&lt;/c1&gt;</ept>를 받고  호출의 결과로 <bpt i="3" x="3">&lt;c3&gt;</bpt>x + x<ept i="3">&lt;/c3&gt;</ept>인 함수로 정의되었습니다. 그래서 <bpt i="4" x="4">&lt;c4&gt;</bpt>Nat<ept i="4">&lt;/c4&gt;</ept> 유형을 반환합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The native version is much faster than the web version, and is more flexible in other ways, too.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T101448Z" creationid="tlqk35" creationdate="20220130T094207Z">
        <seg>원본 버전은 웹 버전보다 더 빠르고 다른 방식보다 유연합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The next example simply permutes the last two lines in the previous proof.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T175300Z" creationid="tlqk3" creationdate="20220211T175300Z">
        <seg>다음 예제는 이전 증명에서 마지막 두 줄을 단순히 바꾼 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The next example uses both these rules to produce a proof of <bpt i="8" x="8">&lt;c8&gt;</bpt>(p → q) → ¬q → ¬p<ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T172919Z" creationid="tlqk3" creationdate="20220211T172919Z">
        <seg>다음 예제는 <bpt i="8" x="8">&lt;c8&gt;</bpt>(p → q) → ¬q → ¬p<ept i="8">&lt;/c8&gt;</ept>의 증명을 만들기 위해 세 가지 규칙 모두를 사용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The order of operations is as follows: unary negation <bpt i="0" x="0">&lt;c0&gt;</bpt>¬<ept i="0">&lt;/c0&gt;</ept> binds most strongly, then <bpt i="1" x="1">&lt;c1&gt;</bpt>∧<ept i="1">&lt;/c1&gt;</ept>, then <bpt i="2" x="2">&lt;c2&gt;</bpt>∨<ept i="2">&lt;/c2&gt;</ept>, then <bpt i="3" x="3">&lt;c3&gt;</bpt>→<ept i="3">&lt;/c3&gt;</ept>, and finally <bpt i="4" x="4">&lt;c4&gt;</bpt>↔<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T160542Z" creationid="tlqk3" creationdate="20220211T160542Z">
        <seg>연산자의 우선순위는 다음과 같습니다. 일항 부정 <bpt i="0" x="0">&lt;c0&gt;</bpt>¬<ept i="0">&lt;/c0&gt;</ept> 은 가장 강하게 결합하고 그 다음은 <bpt i="1" x="1">&lt;c1&gt;</bpt>∧<ept i="1">&lt;/c1&gt;</ept> 그 다음 <bpt i="2" x="2">&lt;c2&gt;</bpt>∨<ept i="2">&lt;/c2&gt;</ept> 그 다음 <bpt i="3" x="3">&lt;c3&gt;</bpt>→<ept i="3">&lt;/c3&gt;</ept> 그리고 마지막으로 <bpt i="4" x="4">&lt;c4&gt;</bpt>↔<ept i="4">&lt;/c4&gt;</ept>입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The other propositional connectives are defined in Lean's library in the file <bpt i="1" x="1">&lt;c1&gt;</bpt>Prelude.core<ept i="1">&lt;/c1&gt;</ept> (see <bpt i="2" x="2">&lt;a2&gt;</bpt>importing files<ept i="2">&lt;/a2&gt;</ept> for more information on the library hierarchy), and each connective comes with its canonical introduction and elimination rules.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T163358Z" creationid="tlqk3" creationdate="20220211T163358Z">
        <seg>다른 명제논리적 연결사들은  린의 라이브러리의 <bpt i="1" x="1">&lt;c1&gt;</bpt>Prelude.core<ept i="1">&lt;/c1&gt;</ept> 파일 속에 정의되 있습니다. (라이브러리 계층에 대한 더 많은 정보를 위해 <bpt i="2" x="2">&lt;a2&gt;</bpt>파일 불러오기<ept i="2">&lt;/a2&gt;</ept>를 보세요.) 그리고 각 연결사들마다 그것의 정식 도입, 제거 규칙이 딸려 나옵니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The output of the <bpt i="1" x="1">&lt;c1&gt;</bpt>#check<ept i="1">&lt;/c1&gt;</ept> command means that whenever <bpt i="2" x="2">&lt;c2&gt;</bpt>α<ept i="2">&lt;/c2&gt;</ept> has type <bpt i="3" x="3">&lt;c3&gt;</bpt>Type n<ept i="3">&lt;/c3&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>List α<ept i="4">&lt;/c4&gt;</ept> also has type <bpt i="5" x="5">&lt;c5&gt;</bpt>Type n<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T051637Z" creationid="tlqk3" creationdate="20220131T051549Z">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>#check<ept i="1">&lt;/c1&gt;</ept> 명령의 출력은 <bpt i="2" x="2">&lt;c2&gt;</bpt>α<ept i="2">&lt;/c2&gt;</ept>가 <bpt i="3" x="3">&lt;c3&gt;</bpt>Type n<ept i="3">&lt;/c3&gt;</ept>유형을 갖는 한 <bpt i="4" x="4">&lt;c4&gt;</bpt>List α<ept i="4">&lt;/c4&gt;</ept>도 <bpt i="5" x="5">&lt;c5&gt;</bpt>Type n<ept i="5">&lt;/c5&gt;</ept> 유형을 가짐을 의미합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The output of the first <bpt i="4" x="4">&lt;c4&gt;</bpt>#check<ept i="4">&lt;/c4&gt;</ept> command is <bpt i="5" x="5">&lt;c5&gt;</bpt>r ?m.1 ?m.2 → r ?m.2 ?m.3 → r ?m.1 ?m.3<ept i="5">&lt;/c5&gt;</ept>, indicating that the implicit arguments are unspecified in this case.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220222T145617Z" creationid="tlqk35" creationdate="20220222T145617Z">
        <seg>처음 <bpt i="4" x="4">&lt;c4&gt;</bpt>#check<ept i="4">&lt;/c4&gt;</ept> 명령의 출력은 <bpt i="5" x="5">&lt;c5&gt;</bpt>r ?m.1 ?m.2 → r ?m.2 ?m.3 → r ?m.1 ?m.3<ept i="5">&lt;/c5&gt;</ept>입니다. 이들은 여기에서 명시되지 않은 암시적 인자들을 지칭합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The parameter list can be separated like this:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T064940Z" creationid="tlqk3" creationdate="20220131T064940Z">
        <seg>매개변수 리스트는 이와 같이 나눠 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The presence of implicit arguments means that at times there may be insufficient information to fix the meaning of an expression precisely.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T075644Z" creationid="tlqk3" creationdate="20220131T075644Z">
        <seg>암시적 인수의 존재는 현재로는 식의 정확한 의미를 고치기에 정보가 불충분함을 의미할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The previous examples can therefore be written concisely as follows:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T174353Z" creationid="tlqk3" creationdate="20220211T174353Z">
        <seg>그러므로 이전 예제는 다음과 같이 간결하게 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The process of instantiating these "holes," or "placeholders," in a term is often known as <bpt i="0" x="0">&lt;e0&gt;</bpt>elaboration<ept i="0">&lt;/e0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T075628Z" creationid="tlqk3" creationdate="20220131T075616Z">
        <seg>이런 "구멍" 또는 "플레이스 홀더"의 인스턴스화 과정은 <bpt i="0" x="0">&lt;e0&gt;</bpt>협력(elaboration)<ept i="0">&lt;/e0&gt;</ept>으로 불리기도 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The propositional connectives come with the following notation:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T153946Z" creationid="tlqk3" creationdate="20220211T153946Z">
        <seg>명제 연결사는 다음 기호로 따라온다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The right hand side <bpt i="0" x="0">&lt;c0&gt;</bpt>bar<ept i="0">&lt;/c0&gt;</ept> can be any expression, not just a lambda.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T064825Z" creationid="tlqk3" creationdate="20220131T064825Z">
        <seg>우변 <bpt i="0" x="0">&lt;c0&gt;</bpt>bar<ept i="0">&lt;/c0&gt;</ept>는 lambda뿐만 아니라 어떤 식이든 될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The second way to use Lean is to install and run it natively on your computer.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T101524Z" creationid="tlqk35" creationdate="20220130T094054Z">
        <seg>Lean을 사용하는 두 번째 방법은 여러분의 컴퓨터에 설치하여 로컬로 실행하는 것 입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The short explanation is that types can depend on parameters.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T072001Z" creationid="tlqk3" creationdate="20220131T072001Z">
        <seg>간단한 설명은 유형이 매개변수에 의존할 수 있다는 겁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The similarity between <bpt i="6" x="6">&lt;c6&gt;</bpt>∧<ept i="6">&lt;/c6&gt;</ept> and <bpt i="7" x="7">&lt;c7&gt;</bpt>×<ept i="7">&lt;/c7&gt;</ept> is another instance of the Curry-Howard isomorphism, but in contrast to implication and the function space constructor, <bpt i="8" x="8">&lt;c8&gt;</bpt>∧<ept i="8">&lt;/c8&gt;</ept> and <bpt i="9" x="9">&lt;c9&gt;</bpt>×<ept i="9">&lt;/c9&gt;</ept> are treated separately in Lean.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T164938Z" creationid="tlqk3" creationdate="20220211T164938Z">
        <seg><bpt i="6" x="6">&lt;c6&gt;</bpt>∧<ept i="6">&lt;/c6&gt;</ept>과 <bpt i="7" x="7">&lt;c7&gt;</bpt>×<ept i="7">&lt;/c7&gt;</ept>의 유사성은 커리-하워드 동형론의 또다른 예입니다. 그러나 함의와 함수 공간 생성자와는 대조적으로  <bpt i="8" x="8">&lt;c8&gt;</bpt>∧<ept i="8">&lt;/c8&gt;</ept>과 <bpt i="9" x="9">&lt;c9&gt;</bpt>×<ept i="9">&lt;/c9&gt;</ept>은 린에서 별개로 다뤄집니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The source code, and instructions for building Lean, are available at <bpt i="0" x="0">&lt;a0&gt;</bpt>https://github.com/leanprover/lean4/<ept i="0">&lt;/a0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T101435Z" creationid="tlqk35" creationdate="20220130T094335Z">
        <seg>Lean을 만든 소스코드와  명령어들은 <bpt i="0" x="0">&lt;a0&gt;</bpt>https://github.com/leanprover/lean4/<ept i="0">&lt;/a0&gt;</ept>에서 볼 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The term "predicative" stems from foundational developments around the turn of the twentieth century, when logicians such as Poincaré and Russell blamed set-theoretic paradoxes on the "vicious circles" that arise when we define a property by quantifying over a collection that includes the very property being defined.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220222T153731Z" creationid="tlqk35" creationdate="20220222T153244Z">
        <seg>"술어"라는 말은 20세기로 접어드는 시기에 기초수학의 발전으로부터 유래되었습니다.  이때 푸엥카레와 레셀 같은 논리학자들은 정의되는 바로 그 정의되는 성질을 포함하는 모임에 대해 한정함으로써 성질을 정의할 때 발생하는 집합론적 역설 "악순환(vicious circles)"을 비난했습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The two ways we have suggested thinking about the propositions-as-types paradigm differ in a fundamental way.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T143247Z" creationid="tlqk3" creationdate="20220211T143018Z">
        <seg>우리가 제안한 유형별 명제 패러다임에 대해 생각하는 두 가지 방법은 근본적인 면에서 다릅니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The type algebra <bpt i="1" x="1">&lt;c1&gt;</bpt>β → γ<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>α → β<ept i="2">&lt;/c2&gt;</ept> means it is a requirement that the type of the output of the second function must match the type of the input to the first function - which makes sense, otherwise the two functions would not be composable.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T065312Z" creationid="tlqk3" creationdate="20220131T065312Z">
        <seg> <bpt i="1" x="1">&lt;c1&gt;</bpt>β → γ<ept i="1">&lt;/c1&gt;</ept> 와 <bpt i="2" x="2">&lt;c2&gt;</bpt>α → β<ept i="2">&lt;/c2&gt;</ept>의 유형 대수는 두 번째 함수의 출력 유형이 첫 번째 함수의 입력 유형과 반드시 일치해야 한다는 요구를 같습니다. 이렇지 않다면 두 함수는 합성될 수 없을 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The type of <bpt i="0" x="0">&lt;c0&gt;</bpt>t1<ept i="0">&lt;/c0&gt;</ept> is now <bpt i="1" x="1">&lt;c1&gt;</bpt>∀ {p q : Prop}, p → q → p<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T154450Z" creationid="tlqk3" creationdate="20220211T154450Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>t1<ept i="0">&lt;/c0&gt;</ept>의 유형은 이제 <bpt i="1" x="1">&lt;c1&gt;</bpt>∀ {p q : Prop}, p → q → p<ept i="1">&lt;/c1&gt;</ept>입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The unicode symbol <bpt i="7" x="7">&lt;c7&gt;</bpt>×<ept i="7">&lt;/c7&gt;</ept> for the Cartesian product is entered as <bpt i="8" x="8">&lt;c8&gt;</bpt>\times<ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T041952Z" creationid="tlqk3" creationdate="20220131T041952Z">
        <seg>카테시안 곱을 나타내는 유니코드 기호 <bpt i="7" x="7">&lt;c7&gt;</bpt>×<ept i="7">&lt;/c7&gt;</ept>는 <bpt i="8" x="8">&lt;c8&gt;</bpt>\times<ept i="8">&lt;/c8&gt;</ept>을 입력하여 씁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The universal quantifier, <bpt i="0" x="0">&lt;c0&gt;</bpt>∀ x : α, p x<ept i="0">&lt;/c0&gt;</ept> is supposed to denote the assertion that "for every <bpt i="1" x="1">&lt;c1&gt;</bpt>x : α<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>p x<ept i="2">&lt;/c2&gt;</ept>" holds.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220222T141511Z" creationid="tlqk35" creationdate="20220222T141511Z">
        <seg>전칭 한정기호 <bpt i="0" x="0">&lt;c0&gt;</bpt>∀ x : α, p x<ept i="0">&lt;/c0&gt;</ept> 은 "모든 <bpt i="1" x="1">&lt;c1&gt;</bpt>x : α<ept i="1">&lt;/c1&gt;</ept>에 대해  <bpt i="2" x="2">&lt;c2&gt;</bpt>p x<ept i="2">&lt;/c2&gt;</ept>"가 성립한다는 주장을 가리켜야 할 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Then <bpt i="5" x="5">&lt;c5&gt;</bpt>(x : α) → β<ept i="5">&lt;/c5&gt;</ept> is an element of <bpt i="6" x="6">&lt;c6&gt;</bpt>Sort (imax i j)<ept i="6">&lt;/c6&gt;</ept>, where <bpt i="7" x="7">&lt;c7&gt;</bpt>imax i j<ept i="7">&lt;/c7&gt;</ept> is the maximum of <bpt i="8" x="8">&lt;c8&gt;</bpt>i<ept i="8">&lt;/c8&gt;</ept> and <bpt i="9" x="9">&lt;c9&gt;</bpt>j<ept i="9">&lt;/c9&gt;</ept> if <bpt i="10" x="10">&lt;c10&gt;</bpt>j<ept i="10">&lt;/c10&gt;</ept> is not 0, and 0 otherwise.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220222T150618Z" creationid="tlqk35" creationdate="20220222T150344Z">
        <seg>그러면 <bpt i="5" x="5">&lt;c5&gt;</bpt>(x : α) → β<ept i="5">&lt;/c5&gt;</ept>은 <bpt i="6" x="6">&lt;c6&gt;</bpt>Sort (imax i j)<ept i="6">&lt;/c6&gt;</ept>의 원소입니다. 여기서 <bpt i="7" x="7">&lt;c7&gt;</bpt>imax i j<ept i="7">&lt;/c7&gt;</ept>는 <bpt i="8" x="8">&lt;c8&gt;</bpt>i<ept i="8">&lt;/c8&gt;</ept>와 <bpt i="9" x="9">&lt;c9&gt;</bpt>j<ept i="9">&lt;/c9&gt;</ept>사이의 최대값이고, <bpt i="10" x="10">&lt;c10&gt;</bpt>j<ept i="10">&lt;/c10&gt;</ept>가 0이 아니면 0입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Then go back and replace each <bpt i="4" x="4">&lt;c4&gt;</bpt>sorry<ept i="4">&lt;/c4&gt;</ept> with an actual proof, until no more remain.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T152918Z" creationid="tlqk3" creationdate="20220211T152918Z">
        <seg>그리고 다시 뒤로 돌아가 각각의 <bpt i="4" x="4">&lt;c4&gt;</bpt>sorry<ept i="4">&lt;/c4&gt;</ept>가 더 남지 않을 때까지 실제 증명으로 바꾸세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Then we can "cancel" the hypothesis and obtain a proof of <bpt i="2" x="2">&lt;c2&gt;</bpt>Implies p q<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T103326Z" creationid="tlqk3" creationdate="20220211T103326Z">
        <seg>그러면 우리는 가정을 "상쇄"하여 <bpt i="2" x="2">&lt;c2&gt;</bpt>Implies p q<ept i="2">&lt;/c2&gt;</ept>의 증명을 얻을 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Then, you can construct lists of <bpt i="0" x="0">&lt;c0&gt;</bpt>Nat<ept i="0">&lt;/c0&gt;</ept> as follows.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T074527Z" creationid="tlqk3" creationdate="20220131T074527Z">
        <seg>그럼 여러분은  <bpt i="0" x="0">&lt;c0&gt;</bpt>Nat<ept i="0">&lt;/c0&gt;</ept>의 리스트를 다음과 같이 생성할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Theorem Proving in Lean 4</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T072719Z" creationid="tlqk35" creationdate="20220130T072719Z">
        <seg>린 4로 하는 정리 증명</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Theorem Proving in Lean 4 - Theorem Proving in Lean 4</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T072701Z" creationid="tlqk35" creationdate="20220130T072701Z">
        <seg>Theorem Proving in Lean 4 - 린 4로 하는 정리 증명</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>There are a few more things to notice here.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T042320Z" creationid="tlqk3" creationdate="20220131T042320Z">
        <seg>여기서 몇 개 더 짚고가야 할 것이 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>There are a few pragmatic differences between definitions and theorems, however.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T145743Z" creationid="tlqk3" creationdate="20220211T145743Z">
        <seg>하지만 정의와 정리 사이에 약간의 실용적 차이는 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>There are at least two ways of thinking about propositions as types.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T141524Z" creationid="tlqk3" creationdate="20220211T140629Z">
        <seg>유형으로써 명제에 대해 생각할 수 있는 최소한 두 가지 방법이 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>There are currently two ways to use Lean.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T101528Z" creationid="tlqk35" creationdate="20220130T093925Z">
        <seg>현재 Lean을 사용하는 두 가지 방식이 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>There is a fine line between brevity and obfuscation, and omitting information in this way can sometimes make a proof harder to read.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T170456Z" creationid="tlqk3" creationdate="20220211T170456Z">
        <seg>간결함과 가독성 사이에 미세찬 차이가 있고 이런 식으로 정보를 생략하는 것은 때때로 증명을 읽기 더 어렵게 만들 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>There is only one anonymous namespace at the root level.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T071304Z" creationid="tlqk3" creationdate="20220131T071304Z">
        <seg>root 계층에서만 익명 이름 공간이 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>These angle brackets are obtained by typing <bpt i="0" x="0">&lt;c0&gt;</bpt>\&lt;<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>\&gt;<ept i="1">&lt;/c1&gt;</ept>, respectively.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T165754Z" creationid="tlqk3" creationdate="20220211T165754Z">
        <seg>이 꺽긴 괄호는 <bpt i="0" x="0">&lt;c0&gt;</bpt>\&lt;<ept i="0">&lt;/c0&gt;</ept>과 <bpt i="1" x="1">&lt;c1&gt;</bpt>\&gt;<ept i="1">&lt;/c1&gt;</ept>을 각각 치는 것으로 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>These are the left and right <bpt i="6" x="6">&lt;e6&gt;</bpt>or-introduction<ept i="6">&lt;/e6&gt;</ept> rules.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T171256Z" creationid="tlqk3" creationdate="20220211T171256Z">
        <seg>이들은 왼쪽과 오른쪽 <bpt i="6" x="6">&lt;e6&gt;</bpt>or-도입<ept i="6">&lt;/e6&gt;</ept> 규칙입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>These aspects of Lean are explored in a companion tutorial to this one, <bpt i="1" x="1">&lt;a1&gt;</bpt>Programming in Lean 4<ept i="1">&lt;/a1&gt;</ept>, though computational aspects of the system will make an appearance here.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T101555Z" creationid="tlqk35" creationdate="20220130T092009Z">
        <seg>Lean의 이러한 측면은 이 교재의 동반 교재인 <bpt i="1" x="1">&lt;a1&gt;</bpt>Programming in Lean<ept i="1">&lt;/a1&gt;</ept>에서 더 찾아볼 수 있다. 그렇지만 여기에서도 린의 계산적인 측면을 찾아봅니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>These can include ordinary mathematical theorems, as well as claims that pieces of hardware or software, network protocols, and mechanical and hybrid systems meet their specifications.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T084437Z" creationid="tlqk35" creationdate="20220130T084437Z">
        <seg>이 주장들은 평범한 수학적 정리뿐만 아니라 하드웨어와 소프트웨어, 네트워크 프로토콜, 역학적 복합적 시스템이 그들의 명세를 만족하는지에 대한 주장도 포함될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>These require classical reasoning.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T152204Z" creationid="tlqk3" creationdate="20220211T152204Z">
        <seg>이것은 고전 추론 규칙이 필요합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>These require classical reasoning:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T153610Z" creationid="tlqk3" creationdate="20220211T153610Z">
        <seg>이것은 고전 추론 규칙이 필요합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>These types vary depending on the first argument, <bpt i="10" x="10">&lt;c10&gt;</bpt>α<ept i="10">&lt;/c10&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T073321Z" creationid="tlqk3" creationdate="20220131T073321Z">
        <seg>그래서 이 유형은 첫번째 인수 <bpt i="10" x="10">&lt;c10&gt;</bpt>α<ept i="10">&lt;/c10&gt;</ept>.에 따라 달라집니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>They all take values in <bpt i="0" x="0">&lt;c0&gt;</bpt>Prop<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T160401Z" creationid="tlqk3" creationdate="20220211T160401Z">
        <seg>이들은 <bpt i="0" x="0">&lt;c0&gt;</bpt>Prop<ept i="0">&lt;/c0&gt;</ept>형의 모든 값을 받습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>They are commonly known as the right and left <bpt i="5" x="5">&lt;e5&gt;</bpt>and-elimination<ept i="5">&lt;/e5&gt;</ept> rules.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T164403Z" creationid="tlqk3" creationdate="20220211T164403Z">
        <seg>이들은 흔히 오른쪽과 왼쪽 <bpt i="5" x="5">&lt;e5&gt;</bpt>and-제거<ept i="5">&lt;/e5&gt;</ept> 규칙으로 알려져 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>They are considered "the same" by Lean's type checker, and Lean does its best to recognize and support these identifications.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T061011Z" creationid="tlqk3" creationdate="20220131T061011Z">
        <seg>이런 것은 린의 유형 검사기가 "같은"것으로 봅니다. 그리고 린은 유형을 인식하고 대조하는데 최선을 다합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Think about what is going on here.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220222T144801Z" creationid="tlqk35" creationdate="20220222T144801Z">
        <seg>무슨 일이 생긴 건지 생각해보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Think about what these expressions mean.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T053646Z" creationid="tlqk3" creationdate="20220131T053646Z">
        <seg>이 표현식의 의미에 대해 생각해보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Think of <bpt i="0" x="0">&lt;c0&gt;</bpt>Type 0<ept i="0">&lt;/c0&gt;</ept> as a universe of "small" or "ordinary" types.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T050149Z" creationid="tlqk3" creationdate="20220131T050149Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Type 0<ept i="0">&lt;/c0&gt;</ept>는 "작은" 또는 "평범한" 유형들의 세계라고 생각해보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Think of this as the function from <bpt i="6" x="6">&lt;c6&gt;</bpt>α<ept i="6">&lt;/c6&gt;</ept> to <bpt i="7" x="7">&lt;c7&gt;</bpt>β<ept i="7">&lt;/c7&gt;</ept> which maps any value <bpt i="8" x="8">&lt;c8&gt;</bpt>x<ept i="8">&lt;/c8&gt;</ept> to the value <bpt i="9" x="9">&lt;c9&gt;</bpt>t<ept i="9">&lt;/c9&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T053104Z" creationid="tlqk3" creationdate="20220131T053104Z">
        <seg>이를  임의의 값 x에서 값 t로 대응시키는 <bpt i="6" x="6">&lt;c6&gt;</bpt>α<ept i="6">&lt;/c6&gt;</ept>에서 <bpt i="7" x="7">&lt;c7&gt;</bpt>β<ept i="7">&lt;/c7&gt;</ept>까지의 함수로 생각해보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This approach would provide us with a reasonable way of building assertions and proofs.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T103613Z" creationid="tlqk3" creationdate="20220211T103613Z">
        <seg>이런 접근은 주장과 증명을 만드는 합리적인 방법을 우리에게 줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This book is designed to teach you to develop and verify proofs in Lean.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T101428Z" creationid="tlqk35" creationdate="20220130T094507Z">
        <seg>이 책은 Lean에서 증명을 검증하고 세울 수 있도록 당신을 가르치게끔 설계되었습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This clarifies your intention, and Lean will flag an error if the right-hand side of the definition does not have a matching type.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T064755Z" creationid="tlqk3" creationdate="20220131T064755Z">
        <seg>이것은 당신의 의도를 명확히 만들고 Lean은 정의의 우변에 일치하는 유형이 아닌 경우 에러를 표시할 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This definition of <bpt i="0" x="0">&lt;c0&gt;</bpt>ident<ept i="0">&lt;/c0&gt;</ept> here has the same effect as the one above.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T075518Z" creationid="tlqk3" creationdate="20220131T075518Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>ident<ept i="0">&lt;/c0&gt;</ept>의 이 정의는 여기서 위의 것과 같이 같은 효과를 갖습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This explains the type annotation of the function <bpt i="4" x="4">&lt;c4&gt;</bpt>List<ept i="4">&lt;/c4&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T051040Z" creationid="tlqk3" creationdate="20220131T051040Z">
        <seg>이는 <bpt i="4" x="4">&lt;c4&gt;</bpt>List<ept i="4">&lt;/c4&gt;</ept>함수의 유형 표기를 설명합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This gives you a way of creating pairs of natural numbers.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T043916Z" creationid="tlqk3" creationdate="20220131T043916Z">
        <seg>이는 여러분에게 자연수의 쌍을 만들 수 있는 방법을 줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This gives you a way of extracting its two components.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T044112Z" creationid="tlqk3" creationdate="20220131T044112Z">
        <seg>이는 여러분에게 순서쌍의 두 성분을 추출하는 방법을 줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This instructs Lean's elaborator to use the value <bpt i="3" x="3">&lt;c3&gt;</bpt>T<ept i="3">&lt;/c3&gt;</ept> as the type of <bpt i="4" x="4">&lt;c4&gt;</bpt>e<ept i="4">&lt;/c4&gt;</ept> when trying to resolve implicit arguments.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T075906Z" creationid="tlqk3" creationdate="20220131T075906Z">
        <seg>이것은 린의 협력기가 암시적 인수를 해결하려고 시도할 때 <bpt i="4" x="4">&lt;c4&gt;</bpt>e<ept i="4">&lt;/c4&gt;</ept>의 유형으로 <bpt i="3" x="3">&lt;c3&gt;</bpt>T<ept i="3">&lt;/c3&gt;</ept>값을 사용하라고 지시합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This is a central feature of dependent type theory: terms carry a lot of information, and often some of that information can be inferred from the context.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T074920Z" creationid="tlqk3" creationdate="20220131T074920Z">
        <seg>이는 의존 유형론의 핵심 특징입니다. 항은 많은 정보를 전달하고 종종 그 정보의 몇은  맥락으로부터 추론될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This is a good place to introduce another device Lean offers to help structure long proofs, namely, the <bpt i="0" x="0">&lt;c0&gt;</bpt>have<ept i="0">&lt;/c0&gt;</ept> construct, which introduces an auxiliary subgoal in a proof.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T175150Z" creationid="tlqk3" creationdate="20220211T174539Z">
        <seg>이곳은 린이 긴 증명을 구조화하도록 돕는 또다른 장치를 도입하기에 적절합니다. 주로  <bpt i="0" x="0">&lt;c0&gt;</bpt>have<ept i="0">&lt;/c0&gt;</ept> 생성자인데 이는 증명의 보조적인 세부목표를 도입합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This is an instance of a <bpt i="0" x="0">&lt;e0&gt;</bpt>dependent function type<ept i="0">&lt;/e0&gt;</ept>, or <bpt i="1" x="1">&lt;e1&gt;</bpt>dependent arrow type<ept i="1">&lt;/e1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T073442Z" creationid="tlqk3" creationdate="20220131T073442Z">
        <seg>이것은 <bpt i="0" x="0">&lt;e0&gt;</bpt>의존적 함수 유형<ept i="0">&lt;/e0&gt;</ept> 또는 <bpt i="1" x="1">&lt;e1&gt;</bpt>의존적 방향 유형<ept i="1">&lt;/e1&gt;</ept>의 개체입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This is done by putting the arguments in curly braces, as follows:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T075059Z" creationid="tlqk3" creationdate="20220131T075059Z">
        <seg>이것은 다음과 같이 인수를 중괄호 안에 두는 것으로 할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This is known as <bpt i="4" x="4">&lt;e4&gt;</bpt>proof irrelevance,<ept i="4">&lt;/e4&gt;</ept> and is consistent with the interpretation in the last paragraph.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T180350Z" creationid="tlqk3" creationdate="20220211T142738Z">
        <seg>이것은 <bpt i="4" x="4">&lt;e4&gt;</bpt>증명 무연관<ept i="4">&lt;/e4&gt;</ept>으로 알려져 있고 이것은 마지막 문단에서 해석과 일관성이 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This is known as an "implicit argument."</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T075017Z" creationid="tlqk3" creationdate="20220131T075017Z">
        <seg>이것은 "암시적 인자"라고 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This is often useful as well.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T171029Z" creationid="tlqk3" creationdate="20220211T171029Z">
        <seg>이것도 또한 종종 유용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This is similar to the way that computer scientists occasionally blur the distinction between syntax and semantics by saying, at times, that a program "computes" a certain function, and at other times speaking as though the program "is" the function in question.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T145609Z" creationid="tlqk3" creationdate="20220211T144124Z">
        <seg>이것은 컴퓨터 과학자들이 때때로 프로그램이 특정 함수를 "계산"한다고 말함으로써 문법과 의미론의 구분을 모호하게 하는 방식과 유사합니다. 그리고 다른 때에는 프로그램이 문제의 함수인 것처럼 말합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This is the approach followed in the Calculus of Constructions, and hence in Lean as well.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T141437Z" creationid="tlqk3" creationdate="20220211T135637Z">
        <seg>이는 직관주의적 계산법에 따른 접근법입니다. 그리고 이는 린에서도 마찬가지 입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This is the elimination rule.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220222T144127Z" creationid="tlqk35" creationdate="20220222T144127Z">
        <seg>이것은 제거 규칙입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This is the introduction rule.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220222T144002Z" creationid="tlqk35" creationdate="20220222T144002Z">
        <seg>이것은 도입 규칙입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This looks exactly like the definition of the constant function in the last chapter, the only difference being that the arguments are elements of <bpt i="0" x="0">&lt;c0&gt;</bpt>Prop<ept i="0">&lt;/c0&gt;</ept> rather than <bpt i="1" x="1">&lt;c1&gt;</bpt>Type<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T144943Z" creationid="tlqk3" creationdate="20220211T144943Z">
        <seg>이는 지난 장에서 상수함수의 정의와 완전히 동일하게 보입니다. 유일한 차이는 인수는 <bpt i="0" x="0">&lt;c0&gt;</bpt>Prop<ept i="0">&lt;/c0&gt;</ept>의 원소 보다는 <bpt i="1" x="1">&lt;c1&gt;</bpt>Type<ept i="1">&lt;/c1&gt;</ept>의 원소라는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This makes the first argument to <bpt i="0" x="0">&lt;c0&gt;</bpt>ident<ept i="0">&lt;/c0&gt;</ept> implicit.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T075214Z" creationid="tlqk3" creationdate="20220131T075214Z">
        <seg>이 첫 인수는 <bpt i="0" x="0">&lt;c0&gt;</bpt>ident<ept i="0">&lt;/c0&gt;</ept>를 암시적으로 만듭니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This means <bpt i="0" x="0">&lt;c0&gt;</bpt>compose<ept i="0">&lt;/c0&gt;</ept> is a function that takes any two functions as input arguments, so long as those functions each take only one input.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T065230Z" creationid="tlqk3" creationdate="20220131T065230Z">
        <seg>이는 <bpt i="0" x="0">&lt;c0&gt;</bpt>compose<ept i="0">&lt;/c0&gt;</ept>가 하나의 입력만 받는 함수인 경우에만 임의의 두 함수를 입력 인수로 받는 함수임을 의미합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This means <bpt i="2" x="2">&lt;c2&gt;</bpt>compose<ept i="2">&lt;/c2&gt;</ept> can compose just about any 2 functions so long as they each take one parameter, and so long as the type of output of the second matches the input of the first.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T065629Z" creationid="tlqk3" creationdate="20220131T065629Z">
        <seg>이는 <bpt i="2" x="2">&lt;c2&gt;</bpt>compose<ept i="2">&lt;/c2&gt;</ept>가 그들이 입력받는 두 함수 각각이 한 매개변수만 받고 두번째 함수의 출력 유형이 첫번째 함수의 입력 유형과 같은 한 합성할 수 있다는 것을 의미합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This might look more familiar to you if you know how functions work in other programming languages.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T064220Z" creationid="tlqk3" creationdate="20220131T064220Z">
        <seg>다른 프로그래밍언어에서 함수가 어떻게 동작하는지 안다면 이게 여러분에게 더 친숙하게 보일지 모르겠습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This pattern, deriving an arbitrary fact from contradictory hypotheses, is quite common, and is represented by <bpt i="2" x="2">&lt;c2&gt;</bpt>absurd<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T173623Z" creationid="tlqk3" creationdate="20220211T173623Z">
        <seg>모순적인 가정들로부터 어떤 사실을 얻는 이런 패턴은 꽤 흔하고 <bpt i="2" x="2">&lt;c2&gt;</bpt>absurd<ept i="2">&lt;/c2&gt;</ept>로 표현됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This provides a convenient way of accessing functions without opening a namespace.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T170028Z" creationid="tlqk3" creationdate="20220211T170028Z">
        <seg>이는 이름공간을 열지 않고 함수에 접근하는 편리한 방법을 줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This provides a quick and convenient way to begin experimenting with the system.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T101503Z" creationid="tlqk35" creationdate="20220130T093959Z">
        <seg>이는 실험적으로 시스템을 시작하는데 편리하고 빠른 방법을 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This reflects the interpretation of <bpt i="17" x="17">&lt;c17&gt;</bpt>Prop<ept i="17">&lt;/c17&gt;</ept> as the type of propositions rather than data, and it is what makes <bpt i="18" x="18">&lt;c18&gt;</bpt>Prop<ept i="18">&lt;/c18&gt;</ept> <bpt i="19" x="19">&lt;e19&gt;</bpt>impredicative<ept i="19">&lt;/e19&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220222T152721Z" creationid="tlqk35" creationdate="20220222T151144Z">
        <seg>이것은 데이터보다는 명제의 유형으로써 <bpt i="17" x="17">&lt;c17&gt;</bpt>Prop<ept i="17">&lt;/c17&gt;</ept>의 해석을 반영했습니다. 그리고 이것이 <bpt i="18" x="18">&lt;c18&gt;</bpt>Prop<ept i="18">&lt;/c18&gt;</ept>을 <bpt i="19" x="19">&lt;e19&gt;</bpt>impredicative<ept i="19">&lt;/e19&gt;</ept>하게 만드는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This rule is sometimes called <bpt i="2" x="2">&lt;e2&gt;</bpt>ex falso<ept i="2">&lt;/e2&gt;</ept> (short for <bpt i="3" x="3">&lt;e3&gt;</bpt>ex falso sequitur quodlibet<ept i="3">&lt;/e3&gt;</ept>), or the <bpt i="4" x="4">&lt;e4&gt;</bpt>principle of explosion<ept i="4">&lt;/e4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T173207Z" creationid="tlqk3" creationdate="20220211T173207Z">
        <seg>이 규칙은 때때로 <bpt i="2" x="2">&lt;e2&gt;</bpt>ex falso<ept i="2">&lt;/e2&gt;</ept> (라틴어 <bpt i="3" x="3">&lt;e3&gt;</bpt>ex falso sequitur quodlibet<ept i="3">&lt;/e3&gt;</ept>을 줄인 것), 또는 <bpt i="4" x="4">&lt;e4&gt;</bpt>폭발의 원리(principle of explosion)<ept i="4">&lt;/e4&gt;</ept>라고 불립니다..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This sets a very high standard: every rule of inference and every step of a calculation has to be justified by appealing to prior definitions and theorems, all the way down to basic axioms and rules.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T101649Z" creationid="tlqk35" creationdate="20220130T090817Z">
        <seg>이것은 아주 높은 기준을 설정합니다. 모든 추론 규칙과 계산의 모든 계산 과정은 선행된(기초 공리와 규칙으로 거슬러 내려가는) 정의와 정리에 호소하여 정당화되어야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This simple device is extremely useful when it comes to structuring long proofs, since we can use intermediate <bpt i="6" x="6">&lt;c6&gt;</bpt>have<ept i="6">&lt;/c6&gt;</ept>'s as stepping stones leading to the final goal.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T175121Z" creationid="tlqk3" creationdate="20220211T174933Z">
        <seg>이 단순한 장치는 긴 증명을 구조화 해야 할 때 아주 유용합니다. 왜냐하면 우리는 간간히 <bpt i="6" x="6">&lt;c6&gt;</bpt>have<ept i="6">&lt;/c6&gt;</ept>를 최종 목표로 이끄는 주춧돌로써 쓰기 때문입다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This tutorial describes the current version of Lean, known as Lean 4.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T101432Z" creationid="tlqk35" creationdate="20220130T094429Z">
        <seg>이 튜토리얼은 린의 현재 버전(린 4)를 설명합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This tutorial is an open access project maintained on Github.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T100440Z" creationid="tlqk35" creationdate="20220130T100412Z">
        <seg>이 튜토리얼은 깃허브로 관리되어 누구나 접근할 수 있는 프로젝트입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This type depends on <bpt i="7" x="7">&lt;e7&gt;</bpt>two<ept i="7">&lt;/e7&gt;</ept> parameters: the type of the elements in the vector (<bpt i="8" x="8">&lt;c8&gt;</bpt>α : Type<ept i="8">&lt;/c8&gt;</ept>) and the length of the vector <bpt i="9" x="9">&lt;c9&gt;</bpt>n : Nat<ept i="9">&lt;/c9&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T072358Z" creationid="tlqk3" creationdate="20220131T072358Z">
        <seg>이 유형은 <bpt i="7" x="7">&lt;e7&gt;</bpt>두<ept i="7">&lt;/e7&gt;</ept> 매개변수에 의존합니다. 하나는 벡터의 원소의 유형 (<bpt i="8" x="8">&lt;c8&gt;</bpt>α : Type<ept i="8">&lt;/c8&gt;</ept>)이고 또 다른 하나는 벡터의 길이<bpt i="9" x="9">&lt;c9&gt;</bpt>n : Nat<ept i="9">&lt;/c9&gt;</ept>입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This version of the text assumes you’re using Lean 4.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T073829Z" creationid="tlqk35" creationdate="20220130T073829Z">
        <seg>이 교재는 여러분이 린 4를 사용한다고 가정합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Those not inclined to this ideology can view it, rather, as a simple coding trick.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T141550Z" creationid="tlqk3" creationdate="20220211T141048Z">
        <seg>이 이데올로기에 편향되지 않은 사람들은 꽤나 단순한 코딩 트릭으로 볼 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Throughout the text you will find examples of Lean code like the one below:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T101148Z" creationid="tlqk35" creationdate="20220130T095831Z">
        <seg>이 교재에서 여러분은 아래와 같은 린 코드 예제를 보게 될 겁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Thus namespaces give you a way to manage names in your working environment.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T071432Z" creationid="tlqk3" creationdate="20220131T071432Z">
        <seg>따라서 이름공간은 당신의 작업 환경 속에 이름을 관리하는 방법을 줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Thus the proof term above could be written more concisely:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T172004Z" creationid="tlqk3" creationdate="20220211T172004Z">
        <seg>따라서 위의 증명 항을 더 간결하게 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Thus you can view <bpt i="8" x="8">&lt;c8&gt;</bpt>Nat.add<ept i="8">&lt;/c8&gt;</ept> as a function that takes a natural number and returns another function that takes a natural number and returns a natural number.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T043020Z" creationid="tlqk3" creationdate="20220131T043020Z">
        <seg>따라서 여러분은 <bpt i="8" x="8">&lt;c8&gt;</bpt>Nat.add<ept i="8">&lt;/c8&gt;</ept>은 자연수를 받아 자연수를 받고 자연수를 반환하는 또 다른 함수를 반환하는 함수로 볼 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To <bpt i="1" x="1">&lt;e1&gt;</bpt>prove<ept i="1">&lt;/e1&gt;</ept> that assertion, we need to exhibit a term <bpt i="2" x="2">&lt;c2&gt;</bpt>t : p<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T144330Z" creationid="tlqk3" creationdate="20220211T144330Z">
        <seg>주장을 <bpt i="1" x="1">&lt;e1&gt;</bpt>증명<ept i="1">&lt;/e1&gt;</ept>하는 것은 <bpt i="2" x="2">&lt;c2&gt;</bpt>t : p<ept i="2">&lt;/c2&gt;</ept>의 항으로 나타낼 필요가 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To define polymorphic constants, Lean allows you to declare universe variables explicitly using the <bpt i="0" x="0">&lt;c0&gt;</bpt>universe<ept i="0">&lt;/c0&gt;</ept> command:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T051828Z" creationid="tlqk3" creationdate="20220131T051828Z">
        <seg>다형적인 상수를 정의하기 위해 린은 여러분이 세계 변수를 <bpt i="0" x="0">&lt;c0&gt;</bpt>universe<ept i="0">&lt;/c0&gt;</ept> 명령을 명시적으로 사용하여 선언할 수 있게 했습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To each proposition <bpt i="0" x="0">&lt;c0&gt;</bpt>p<ept i="0">&lt;/c0&gt;</ept> we associate a type that is empty if <bpt i="1" x="1">&lt;c1&gt;</bpt>p<ept i="1">&lt;/c1&gt;</ept> is false and has a single element, say <bpt i="2" x="2">&lt;c2&gt;</bpt>*<ept i="2">&lt;/c2&gt;</ept>, if <bpt i="3" x="3">&lt;c3&gt;</bpt>p<ept i="3">&lt;/c3&gt;</ept> is true.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T141638Z" creationid="tlqk3" creationdate="20220211T141241Z">
        <seg>각 명제 <bpt i="0" x="0">&lt;c0&gt;</bpt>p<ept i="0">&lt;/c0&gt;</ept>에 대해, 우리는 <bpt i="1" x="1">&lt;c1&gt;</bpt>p<ept i="1">&lt;/c1&gt;</ept>이 거짓이면 원소가 없고, <bpt i="3" x="3">&lt;c3&gt;</bpt>p<ept i="3">&lt;/c3&gt;</ept>가 참이면 한 원소(예: <bpt i="2" x="2">&lt;c2&gt;</bpt>*<ept i="2">&lt;/c2&gt;</ept>)가 있는 유형을 연관시킵니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To formally express a mathematical assertion in the language of dependent type theory, we need to exhibit a term <bpt i="0" x="0">&lt;c0&gt;</bpt>p : Prop<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T144236Z" creationid="tlqk3" creationdate="20220211T144236Z">
        <seg>의존 유형론의 언어로 수학적 주장을 형식적으로 표현하기 위해 <bpt i="0" x="0">&lt;c0&gt;</bpt>p : Prop<ept i="0">&lt;/c0&gt;</ept>에 대한 항으로 나타낼 필요가 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To get used to using universal quantifiers, you should try some of the exercises at the end of this section.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220222T145810Z" creationid="tlqk35" creationdate="20220222T145810Z">
        <seg>전칭 한정기호 사용에 익숙해지기 위해서 여러분은 이 섹션 끝의 연습문제들을 풀어보아야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To some who take a constructive view of logic and mathematics, this is a faithful rendering of what it means to be a proposition: a proposition <bpt i="0" x="0">&lt;c0&gt;</bpt>p<ept i="0">&lt;/c0&gt;</ept> represents a sort of data type, namely, a specification of the type of data that constitutes a proof.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T141535Z" creationid="tlqk3" creationdate="20220211T140913Z">
        <seg>논리와 수학에 직관주의적 관점을 갖는 누군가에게 이것은 명제가 되는 것의 의미를 충실하게 표현합니다. 명제 <bpt i="0" x="0">&lt;c0&gt;</bpt>p<ept i="0">&lt;/c0&gt;</ept>은 일종의 데이터 유형을 나타냅니다. 주로 증명을 만드는 데이터 유형의 명세입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To start with, we can avoid writing the term <bpt i="0" x="0">&lt;c0&gt;</bpt>Proof<ept i="0">&lt;/c0&gt;</ept> repeatedly by conflating <bpt i="1" x="1">&lt;c1&gt;</bpt>Proof p<ept i="1">&lt;/c1&gt;</ept> with <bpt i="2" x="2">&lt;c2&gt;</bpt>p<ept i="2">&lt;/c2&gt;</ept> itself.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T141401Z" creationid="tlqk3" creationdate="20220211T134750Z">
        <seg>그렇기 위해 우리는 <bpt i="1" x="1">&lt;c1&gt;</bpt>Proof p<ept i="1">&lt;/c1&gt;</ept>를 <bpt i="2" x="2">&lt;c2&gt;</bpt>p<ept i="2">&lt;/c2&gt;</ept>를 같이 쓰는 것으로 <bpt i="0" x="0">&lt;c0&gt;</bpt>Proof<ept i="0">&lt;/c0&gt;</ept>에 대한 반복적인 사용을 피할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To start with, you will learn the logical system that Lean is based on, a version of <bpt i="0" x="0">&lt;e0&gt;</bpt>dependent type theory<ept i="0">&lt;/e0&gt;</ept> that is powerful enough to prove almost any conventional mathematical theorem, and expressive enough to do it in a natural way.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T101418Z" creationid="tlqk35" creationdate="20220130T094944Z">
        <seg>먼저 여러분은 Lean이 기초하고 있는 논리 체계 즉 거의 모든 기존의 수학적 정리를 증명할 수 있을 만큼 강력하고 그것을 자연스럽게 할 수 있을 만큼 충분히 표현력이 뛰어난 <bpt i="0" x="0">&lt;e0&gt;</bpt>의존유형론<ept i="0">&lt;/e0&gt;</ept> 버전을 배웁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To the kernel type checker, there is no difference between the two.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T145700Z" creationid="tlqk3" creationdate="20220211T145700Z">
        <seg>커널 유형 확인기에서 둘 사이의 차이는 없습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To use this principle, you have to open the classical namespace.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T175827Z" creationid="tlqk3" creationdate="20220211T175827Z">
        <seg>이 원리를 사용하기 위해서 여러분은 classical 이름공간을 열어야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Toggle Table of Contents</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T073245Z" creationid="tlqk35" creationdate="20220130T073245Z">
        <seg>목차 토글</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>True</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T155959Z" creationid="tlqk3" creationdate="20220211T155959Z">
        <seg>참</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Type inference is an important part of Lean:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T064612Z" creationid="tlqk3" creationdate="20220131T064612Z">
        <seg>유형 추론은 Lean의 중요한 기능입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Types as objects</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T044137Z" creationid="tlqk3" creationdate="20220131T044137Z">
        <seg>대상의 유형</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Typically, the expression <bpt i="4" x="4">&lt;c4&gt;</bpt>p<ept i="4">&lt;/c4&gt;</ept> will depend on <bpt i="5" x="5">&lt;c5&gt;</bpt>x : α<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220222T143019Z" creationid="tlqk35" creationdate="20220222T143019Z">
        <seg>일반적으로 표현식 <bpt i="4" x="4">&lt;c4&gt;</bpt>p<ept i="4">&lt;/c4&gt;</ept>는 <bpt i="5" x="5">&lt;c5&gt;</bpt>x : α<ept i="5">&lt;/c5&gt;</ept>에 의존할 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Unicode</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T153956Z" creationid="tlqk3" creationdate="20220211T153956Z">
        <seg>Unicode(유니코드)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Unlike <bpt i="2" x="2">&lt;c2&gt;</bpt>section<ept i="2">&lt;/c2&gt;</ept>, namespaces require a name.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T071246Z" creationid="tlqk3" creationdate="20220131T071246Z">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>section<ept i="2">&lt;/c2&gt;</ept>과는 달리, 이름공간은 이름이 필요합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Variables and Sections</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T070419Z" creationid="tlqk3" creationdate="20220131T070419Z">
        <seg>변수와 섹션(Variables and Sections)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Variables can also be specified as implicit when they are declared with the <bpt i="0" x="0">&lt;c0&gt;</bpt>variable<ept i="0">&lt;/c0&gt;</ept> command:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T075441Z" creationid="tlqk3" creationdate="20220131T075441Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>variable<ept i="0">&lt;/c0&gt;</ept> 명령으로 선언될 때 변수도 암시적으로 구체화될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We are grateful to Ulrik Buchholz, Kevin Buzzard, Mario Carneiro, Nathan Carter, Eduardo Cavazos, Amine Chaieb, Joe Corneli, William DeMeo, Marcus Klaas de Vries, Ben Dyer, Gabriel Ebner, Anthony Hart, Simon Hudon, Sean Leather, Assia Mahboubi, Gihan Marasingha, Patrick Massot, Christopher John Mazey, Sebastian Ullrich, Floris van Doorn, Daniel Velleman, Théo Zimmerman, Paul Chisholm, and Chris Lovett for their contributions.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T100602Z" creationid="tlqk35" creationdate="20220130T100602Z">
        <seg>우리는 Ulrik Buchholz, Kevin Buzzard, Mario Carneiro, Nathan Carter, Eduardo Cavazos, Amine Chaieb, Joe Corneli, William DeMeo, Marcus Klaas de Vries, Ben Dyer, Gabriel Ebner, Anthony Hart, Simon Hudon, Sean Leather, Assia Mahboubi, Gihan Marasingha, Patrick Massot, Christopher John Mazey, Sebastian Ullrich, Floris van Doorn, Daniel Velleman, Théo Zimmerman, Paul Chisholm, and Chris Lovett에게 그들의 공헌에 대해 감사드립니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We can also use this device in function definitions:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T075142Z" creationid="tlqk3" creationdate="20220131T075142Z">
        <seg>우리는 함수 정의에서도 이 기능을 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We can now prove <bpt i="0" x="0">&lt;c0&gt;</bpt>p ∧ q → q ∧ p<ept i="0">&lt;/c0&gt;</ept> with the following proof term.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T164519Z" creationid="tlqk3" creationdate="20220211T164519Z">
        <seg>이제 우리는 <bpt i="0" x="0">&lt;c0&gt;</bpt>p ∧ q → q ∧ p<ept i="0">&lt;/c0&gt;</ept>를 따르는 증명 항으로 증명할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We can read this as the assertion "for every pair of propositions <bpt i="2" x="2">&lt;c2&gt;</bpt>p q<ept i="2">&lt;/c2&gt;</ept>, we have <bpt i="3" x="3">&lt;c3&gt;</bpt>p → q → p<ept i="3">&lt;/c3&gt;</ept>." For example, we can move all parameters to the right of the colon:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T154613Z" creationid="tlqk3" creationdate="20220211T154613Z">
        <seg>우리는 이를 "모든 명제쌍  <bpt i="2" x="2">&lt;c2&gt;</bpt>p q<ept i="2">&lt;/c2&gt;</ept>에 대해 <bpt i="3" x="3">&lt;c3&gt;</bpt>p → q → p<ept i="3">&lt;/c3&gt;</ept>이다."라고 주장한다고 읽을 수 있다. 예를 들어, 우리는 모든 매개변수들을 콜론의 오른쪽으로 옮길 수 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We can then read <bpt i="5" x="5">&lt;c5&gt;</bpt>t : p<ept i="5">&lt;/c5&gt;</ept> as the assertion that <bpt i="6" x="6">&lt;c6&gt;</bpt>t<ept i="6">&lt;/c6&gt;</ept> is a proof of <bpt i="7" x="7">&lt;c7&gt;</bpt>p<ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T141411Z" creationid="tlqk3" creationdate="20220211T135043Z">
        <seg>우리는<bpt i="5" x="5">&lt;c5&gt;</bpt>t : p<ept i="5">&lt;/c5&gt;</ept>를 <bpt i="6" x="6">&lt;c6&gt;</bpt>t<ept i="6">&lt;/c6&gt;</ept>는 <bpt i="7" x="7">&lt;c7&gt;</bpt>p<ept i="7">&lt;/c7&gt;</ept>의 증명이라는 주장으로써 읽을 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We can therefore rewrite the sample proof above conveniently as follows:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T170242Z" creationid="tlqk3" creationdate="20220211T170242Z">
        <seg>우리는 다음과 같이 위의 예시 증명을 간단히 줄여 쓸  수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We can use the anonymous constructor notation to construct a proof of <bpt i="0" x="0">&lt;c0&gt;</bpt>p ↔ q<ept i="0">&lt;/c0&gt;</ept> from proofs of the forward and backward directions, and we can also use <bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept> notation with <bpt i="2" x="2">&lt;c2&gt;</bpt>mp<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>mpr<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T174330Z" creationid="tlqk3" creationdate="20220211T174330Z">
        <seg>우리는 앞과 뒷방향 증명으로부터 <bpt i="0" x="0">&lt;c0&gt;</bpt>p ↔ q<ept i="0">&lt;/c0&gt;</ept>의 증명을 구성하기 위해 익명 생성자 표기를 사용할 수 있습니다. 그리고 우리는 <bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept>와  <bpt i="2" x="2">&lt;c2&gt;</bpt>mp<ept i="2">&lt;/c2&gt;</ept>과 <bpt i="3" x="3">&lt;c3&gt;</bpt>mpr<ept i="3">&lt;/c3&gt;</ept>을 사용한 표기를 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We could render this as follows:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T103444Z" creationid="tlqk3" creationdate="20220211T103444Z">
        <seg>이를 다음과 같이 얻을 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We could represent this as follows:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T102807Z" creationid="tlqk3" creationdate="20220211T102807Z">
        <seg>이를 다음과 같이 나타낼 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We could then introduce, for each element <bpt i="0" x="0">&lt;c0&gt;</bpt>p : Prop<ept i="0">&lt;/c0&gt;</ept>, another type <bpt i="1" x="1">&lt;c1&gt;</bpt>Proof p<ept i="1">&lt;/c1&gt;</ept>, for the type of proofs of <bpt i="2" x="2">&lt;c2&gt;</bpt>p<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T102357Z" creationid="tlqk3" creationdate="20220211T102247Z">
        <seg>그러면 우리는 각각의 원소 <bpt i="0" x="0">&lt;c0&gt;</bpt>p : Prop<ept i="0">&lt;/c0&gt;</ept>와 또 다른 유형인 <bpt i="1" x="1">&lt;c1&gt;</bpt>Proof p<ept i="1">&lt;/c1&gt;</ept>을 <bpt i="2" x="2">&lt;c2&gt;</bpt>p<ept i="2">&lt;/c2&gt;</ept>의 증명 유형으로 가져올 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We have chosen a nontraditional name here only to avoid a clash of names.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T075422Z" creationid="tlqk3" creationdate="20220131T075408Z">
        <seg>우리는 여기서 이름의 충돌을 방지하기 위해 비관습적인 이름을 선택할 뿐이었습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We recommend running the examples and experimenting with the code on your own as you work through the chapters that follow.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T101118Z" creationid="tlqk35" creationdate="20220130T100311Z">
        <seg>우리는 여러분이 장을 따라 공부하면서 스스로 예제를 실행해보고 코드를 실험해보는 것을 추천합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We will see in <bpt i="0" x="0">&lt;a0&gt;</bpt>Chapter Structures and Records<ept i="0">&lt;/a0&gt;</ept> that certain types in Lean are <bpt i="1" x="1">&lt;e1&gt;</bpt>structures<ept i="1">&lt;/e1&gt;</ept>, which is to say, the type is defined with a single canonical <bpt i="2" x="2">&lt;e2&gt;</bpt>constructor<ept i="2">&lt;/e2&gt;</ept> which builds an element of the type from a sequence of suitable arguments.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T165305Z" creationid="tlqk3" creationdate="20220211T165305Z">
        <seg><bpt i="0" x="0">&lt;a0&gt;</bpt>구조체와 레코드 장<ept i="0">&lt;/a0&gt;</ept>에서 보겠지만 린의 어떤 유형은 <bpt i="1" x="1">&lt;e1&gt;</bpt>구조체<ept i="1">&lt;/e1&gt;</ept>입니다. 그 말은 유형이 하나의 적절한 인수의 배열로부터 유형의 원소를 만드는 정식 <bpt i="2" x="2">&lt;e2&gt;</bpt>생성자<ept i="2">&lt;/e2&gt;</ept>로 정의된다는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We will see later that there <bpt i="0" x="0">&lt;e0&gt;</bpt>are<ept i="0">&lt;/e0&gt;</ept> situations in constructive logic where principles like excluded middle and double-negation elimination are permissible, and Lean supports the use of classical reasoning in such contexts without relying on excluded middle.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T162750Z" creationid="tlqk3" creationdate="20220211T153827Z">
        <seg>우리는 나중에 <bpt i="0" x="0">&lt;e0&gt;</bpt>배중률과 이중 부정 제거와 같은 원칙이 허용되는 직관주의적 논리 <ept i="0">&lt;/e0&gt;</ept> 상황이 있음을 나중에 보게 될 것입니다. 그리고 린은 그런 맥락에서 배중률에 의존하지 않는 고전논리의 사용을 지원합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>What makes dependent type theory dependent?</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T071926Z" creationid="tlqk3" creationdate="20220131T071926Z">
        <seg>무엇이 의존 유형론을 의존적이게 만드는가?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>What makes simple type theory powerful is that you can build new types out of others.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T040403Z" creationid="tlqk3" creationdate="20220131T040403Z">
        <seg>단순 유형론을 강력하게 만드는 것은 기본형 외의 여러분만의 새로운 유형을 만들 수 있다는 점입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>What type should <bpt i="1" x="1">&lt;c1&gt;</bpt>cons<ept i="1">&lt;/c1&gt;</ept> have?</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T072513Z" creationid="tlqk3" creationdate="20220131T072513Z">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>cons<ept i="1">&lt;/c1&gt;</ept>는 어떤 유형을 가져야 할까요?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When <bpt i="6" x="6">&lt;c6&gt;</bpt>β<ept i="6">&lt;/c6&gt;</ept> doesn't depend on <bpt i="7" x="7">&lt;c7&gt;</bpt>a<ept i="7">&lt;/c7&gt;</ept>, <bpt i="8" x="8">&lt;c8&gt;</bpt>(a : α) → β<ept i="8">&lt;/c8&gt;</ept> is no different from the type <bpt i="9" x="9">&lt;c9&gt;</bpt>α → β<ept i="9">&lt;/c9&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T073930Z" creationid="tlqk3" creationdate="20220131T073930Z">
        <seg> <bpt i="6" x="6">&lt;c6&gt;</bpt>β<ept i="6">&lt;/c6&gt;</ept>가  <bpt i="7" x="7">&lt;c7&gt;</bpt>a<ept i="7">&lt;/c7&gt;</ept>에 의존하지 않을 때, <bpt i="8" x="8">&lt;c8&gt;</bpt>(a : α) → β<ept i="8">&lt;/c8&gt;</ept>는 유형 <bpt i="9" x="9">&lt;c9&gt;</bpt>α → β<ept i="9">&lt;/c9&gt;</ept>유형과 다르지 않습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When a function takes an argument that can generally be inferred from context, Lean allows you to specify that this argument should, by default, be left implicit.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T075050Z" creationid="tlqk3" creationdate="20220131T075050Z">
        <seg>함수가 일반적으로 맥락으로부터 추론할 수 있는 인수를 받을 때, Lean은 여러분이 이런 인수가 암시적이어야 함을 명시하도록 기본적으로 허용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When declared in this way, a variable stays in scope until the end of the file you are working on.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T070743Z" creationid="tlqk3" creationdate="20220131T070743Z">
        <seg>이 방식으로 선언되었을 때, 변수는 여러분이 작업하는 파일 끝까지를 범위로 가질 겁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When the section is closed, the variables go out of scope, and become nothing more than a distant memory.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T070906Z" creationid="tlqk3" creationdate="20220131T070840Z">
        <seg>섹션이 닫히게 될 때, 변수들은 범위를 벗어나게 됩니다. 그리고 구분된 메모리 외에 아무것도 없게 됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When the value of <bpt i="2" x="2">&lt;c2&gt;</bpt>β<ept i="2">&lt;/c2&gt;</ept> depends on <bpt i="3" x="3">&lt;c3&gt;</bpt>a<ept i="3">&lt;/c3&gt;</ept> (as does, for example, the expression <bpt i="4" x="4">&lt;c4&gt;</bpt>β a<ept i="4">&lt;/c4&gt;</ept> in the previous paragraph), <bpt i="5" x="5">&lt;c5&gt;</bpt>(a : α) → β<ept i="5">&lt;/c5&gt;</ept> denotes a dependent function type.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T073840Z" creationid="tlqk3" creationdate="20220131T073840Z">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>β<ept i="2">&lt;/c2&gt;</ept>의 값이 <bpt i="3" x="3">&lt;c3&gt;</bpt>a<ept i="3">&lt;/c3&gt;</ept>에 의존할 때(예를 들어 앞 단락에서 식 <bpt i="4" x="4">&lt;c4&gt;</bpt>β a<ept i="4">&lt;/c4&gt;</ept>처럼), <bpt i="5" x="5">&lt;c5&gt;</bpt>(a : α) → β<ept i="5">&lt;/c5&gt;</ept>는 의존적 함수 유형을 나타냅니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When we generalize <bpt i="0" x="0">&lt;c0&gt;</bpt>t1<ept i="0">&lt;/c0&gt;</ept> in such a way, we can then apply it to different pairs of propositions, to obtain different instances of the general theorem.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T155657Z" creationid="tlqk3" creationdate="20220211T155657Z">
        <seg>우리가 <bpt i="0" x="0">&lt;c0&gt;</bpt>t1<ept i="0">&lt;/c0&gt;</ept>을 그런 식으로 일반화할 때, 그럼 우리는 일반 정리의 다른 예를 얻기 위해 다른 명제쌍에 대해서도 적용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When we instantiate <bpt i="0" x="0">&lt;c0&gt;</bpt>trans_r<ept i="0">&lt;/c0&gt;</ept> at the values <bpt i="1" x="1">&lt;c1&gt;</bpt>a b c<ept i="1">&lt;/c1&gt;</ept>, we end up with a proof of <bpt i="2" x="2">&lt;c2&gt;</bpt>r a b → r b c → r a c<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220222T144937Z" creationid="tlqk35" creationdate="20220222T144937Z">
        <seg>우리가  <bpt i="0" x="0">&lt;c0&gt;</bpt>trans_r<ept i="0">&lt;/c0&gt;</ept>을 값 <bpt i="1" x="1">&lt;c1&gt;</bpt>a b c<ept i="1">&lt;/c1&gt;</ept>에 대해 개체화할 때, 우리는 <bpt i="2" x="2">&lt;c2&gt;</bpt>r a b → r b c → r a c<ept i="2">&lt;/c2&gt;</ept>의 증명을 갖게됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When you declare that you are working in the namespace <bpt i="0" x="0">&lt;c0&gt;</bpt>Foo<ept i="0">&lt;/c0&gt;</ept>, every identifier you declare has a full name with prefix "<bpt i="1" x="1">&lt;c1&gt;</bpt>Foo.<ept i="1">&lt;/c1&gt;</ept>".</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T071155Z" creationid="tlqk3" creationdate="20220131T071155Z">
        <seg>이름공간 <bpt i="0" x="0">&lt;c0&gt;</bpt>Foo<ept i="0">&lt;/c0&gt;</ept>에서 작업한다고 여러분이 선언할 때 여러분이 선언한 모든 식별자들은 "<bpt i="1" x="1">&lt;c1&gt;</bpt>Foo.<ept i="1">&lt;/c1&gt;</ept>"를 접미사로 갖습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>With the analogy, however, the proof we have just constructed is similar to a function that swaps the elements of a pair.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T165020Z" creationid="tlqk3" creationdate="20220211T165020Z">
        <seg>하지만 이 비유에도 우리가 막 만든 증명은 순서쌍의 원소를 바꾸는 함수와 비슷합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>With this reduction, there are two ways that a computer can help establish a claim: it can help find a proof in the first place, and it can help verify that a purported proof is correct.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T101749Z" creationid="tlqk35" creationdate="20220130T085502Z">
        <seg>이러한 축소로부터 컴퓨터가 진술을 만드는데 도움을 주는 두 가지 방법이 있습니다. 처음부터 증명을 찾는 걸 돕는 것과 다른 하나는 제시한 증명이 옳은지 식별하도록 돕게 하는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Working with Propositions as Types</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T144510Z" creationid="tlqk3" creationdate="20220211T144510Z">
        <seg>유형으로써 명제로 작업하기</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Writing <bpt i="0" x="0">&lt;c0&gt;</bpt>suffices hq : q<ept i="0">&lt;/c0&gt;</ept> leaves us with two goals.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T175327Z" creationid="tlqk3" creationdate="20220211T175327Z">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>suffices hq : q<ept i="0">&lt;/c0&gt;</ept>을 쓰는 것은 우리에게 두 목표를 남깁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can also declare new constants for types:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T045329Z" creationid="tlqk3" creationdate="20220131T045329Z">
        <seg>여러분은 유형들에 대해 새 상수를 선언할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can also define a function that takes another function as input.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T065054Z" creationid="tlqk3" creationdate="20220131T065054Z">
        <seg>여러분은 또 다른 함수를 입력으로 받는 함수를 정의할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can also pass types as parameters:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T054337Z" creationid="tlqk3" creationdate="20220131T054337Z">
        <seg>여러분은 매개변수로 유형도 전달할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can also use the ASCII alternative <bpt i="4" x="4">&lt;c4&gt;</bpt>-&gt;<ept i="4">&lt;/c4&gt;</ept>, so the expressions <bpt i="5" x="5">&lt;c5&gt;</bpt>Nat -&gt; Nat<ept i="5">&lt;/c5&gt;</ept> and <bpt i="6" x="6">&lt;c6&gt;</bpt>Nat → Nat<ept i="6">&lt;/c6&gt;</ept> mean the same thing.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T041808Z" creationid="tlqk3" creationdate="20220131T041808Z">
        <seg>여러분은 ASCII 대체 표현으로 <bpt i="4" x="4">&lt;c4&gt;</bpt>-&gt;<ept i="4">&lt;/c4&gt;</ept>을 사용할 수 있습니다. 그래서 표현식 <bpt i="5" x="5">&lt;c5&gt;</bpt>Nat -&gt; Nat<ept i="5">&lt;/c5&gt;</ept>과 <bpt i="6" x="6">&lt;c6&gt;</bpt>Nat → Nat<ept i="6">&lt;/c6&gt;</ept>은 같은 식을 의미합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can avoid the universe command by providing the universe parameters when defining F.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T052215Z" creationid="tlqk3" creationdate="20220131T052215Z">
        <seg>여러분은 F를 정의할 때 universe 매개변수를 제공하는 것으로 universe 명령을 쓰지 않을 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can combine multiple assignments by chaining <bpt i="0" x="0">&lt;c0&gt;</bpt>let<ept i="0">&lt;/c0&gt;</ept> statements:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T065947Z" creationid="tlqk3" creationdate="20220131T065947Z">
        <seg>여러분은 다수의 할당을 <bpt i="0" x="0">&lt;c0&gt;</bpt>let<ept i="0">&lt;/c0&gt;</ept> 구문으로 연결함으로써 결합할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can declare variables of any type, not just <bpt i="0" x="0">&lt;c0&gt;</bpt>Type<ept i="0">&lt;/c0&gt;</ept> itself:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T070531Z" creationid="tlqk3" creationdate="20220131T070531Z">
        <seg>여러분은 <bpt i="0" x="0">&lt;c0&gt;</bpt>Type<ept i="0">&lt;/c0&gt;</ept> 그 자체뿐만 아니라 임의의 유형의 변수를 선언할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can enter the unicode arrow <bpt i="0" x="0">&lt;c0&gt;</bpt>→<ept i="0">&lt;/c0&gt;</ept> by typing <bpt i="1" x="1">&lt;c1&gt;</bpt>\to<ept i="1">&lt;/c1&gt;</ept> or <bpt i="2" x="2">&lt;c2&gt;</bpt>\r<ept i="2">&lt;/c2&gt;</ept> or <bpt i="3" x="3">&lt;c3&gt;</bpt>\-&gt;<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T041629Z" creationid="tlqk3" creationdate="20220131T041629Z">
        <seg>여러분은 유니코드 화살표 <bpt i="0" x="0">&lt;c0&gt;</bpt>→<ept i="0">&lt;/c0&gt;</ept>를 <bpt i="1" x="1">&lt;c1&gt;</bpt>\to<ept i="1">&lt;/c1&gt;</ept>을 치거나 or <bpt i="2" x="2">&lt;c2&gt;</bpt>\r<ept i="2">&lt;/c2&gt;</ept>또는 <bpt i="3" x="3">&lt;c3&gt;</bpt>\-&gt;<ept i="3">&lt;/c3&gt;</ept>으로 입력할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can enter these particular ones with <bpt i="12" x="12">&lt;c12&gt;</bpt>\a<ept i="12">&lt;/c12&gt;</ept>, <bpt i="13" x="13">&lt;c13&gt;</bpt>\b<ept i="13">&lt;/c13&gt;</ept>, and <bpt i="14" x="14">&lt;c14&gt;</bpt>\g<ept i="14">&lt;/c14&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T042254Z" creationid="tlqk3" creationdate="20220131T042254Z">
        <seg>여러분은 이들 중 특정한 것은 <bpt i="12" x="12">&lt;c12&gt;</bpt>\a<ept i="12">&lt;/c12&gt;</ept>, <bpt i="13" x="13">&lt;c13&gt;</bpt>\b<ept i="13">&lt;/c13&gt;</ept>과 <bpt i="14" x="14">&lt;c14&gt;</bpt>\g<ept i="14">&lt;/c14&gt;</ept>으로 입력할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can evaluate a lambda function by passing the required parameters:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T052533Z" creationid="tlqk3" creationdate="20220131T052533Z">
        <seg>여러분은 필요한 매개변수를 람다 함수에 넘겨줌으로써 값을 평가할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can omit the type declarations when Lean has enough information to infer it.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T064604Z" creationid="tlqk3" creationdate="20220131T064604Z">
        <seg>Lean이 유형을 추론하기에 충분한 정보를 갖고있을 때 여러분은 유형 선언을 생략할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can pass functions as parameters and by giving them names <bpt i="0" x="0">&lt;c0&gt;</bpt>f<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>g<ept i="1">&lt;/c1&gt;</ept> you can then use those functions in the implementation:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T054237Z" creationid="tlqk3" creationdate="20220131T054237Z">
        <seg>여러분은 매개변수로 함수의 이름  <bpt i="0" x="0">&lt;c0&gt;</bpt>f<ept i="0">&lt;/c0&gt;</ept>과 <bpt i="1" x="1">&lt;c1&gt;</bpt>g<ept i="1">&lt;/c1&gt;</ept> 을 주는 것으로 함수를 전달할 수 있습니다.  그러면 구현에서 이들 함수를 사용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can probably guess what this one will do.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T065048Z" creationid="tlqk3" creationdate="20220131T065048Z">
        <seg>여러분은 이 정의가 아마 뭘 할 지 추측할 수 있을 거예요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can see that each one of the expressions above is an object of type <bpt i="0" x="0">&lt;c0&gt;</bpt>Type<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T045245Z" creationid="tlqk3" creationdate="20220131T045245Z">
        <seg>여러분도 보다시피 위 각각의 표현식은 <bpt i="0" x="0">&lt;c0&gt;</bpt>Type<ept i="0">&lt;/c0&gt;</ept> 유형입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can then construct a proof by incrementally filling in these placeholders.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T153357Z" creationid="tlqk3" creationdate="20220211T153357Z">
        <seg>그럼 여러분은 이 자리 차지자들을 점차 재우는 것으로 증명을 구성할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can then invoke this function using:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T064408Z" creationid="tlqk3" creationdate="20220131T064408Z">
        <seg>여러분은 이 함수를 다음과 같이 불러낼 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can therefore proceed as though <bpt i="1" x="1">&lt;c1&gt;</bpt>α<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>β<ept i="2">&lt;/c2&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt>γ<ept i="3">&lt;/c3&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>g<ept i="4">&lt;/c4&gt;</ept>, <bpt i="5" x="5">&lt;c5&gt;</bpt>f<ept i="5">&lt;/c5&gt;</ept>, <bpt i="6" x="6">&lt;c6&gt;</bpt>h<ept i="6">&lt;/c6&gt;</ept>, and <bpt i="7" x="7">&lt;c7&gt;</bpt>x<ept i="7">&lt;/c7&gt;</ept> are fixed objects when you write your definitions, and let Lean abstract the definitions for you automatically.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T070726Z" creationid="tlqk3" creationdate="20220131T070726Z">
        <seg>그러므로 여러분은 여러분의 정의를 작성할 때  <bpt i="1" x="1">&lt;c1&gt;</bpt>α<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>β<ept i="2">&lt;/c2&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt>γ<ept i="3">&lt;/c3&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>g<ept i="4">&lt;/c4&gt;</ept>, <bpt i="5" x="5">&lt;c5&gt;</bpt>f<ept i="5">&lt;/c5&gt;</ept>, <bpt i="6" x="6">&lt;c6&gt;</bpt>h<ept i="6">&lt;/c6&gt;</ept>, <bpt i="7" x="7">&lt;c7&gt;</bpt>x<ept i="7">&lt;/c7&gt;</ept>가 고정된 대상임에도 사용할 수 있습니다. 그리고 lean이 여러분을 위해 자동으로 정의를 축약할 수 있게 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can think of the inhabitant of <bpt i="9" x="9">&lt;c9&gt;</bpt>p<ept i="9">&lt;/c9&gt;</ept> as being the "fact that <bpt i="10" x="10">&lt;c10&gt;</bpt>p<ept i="10">&lt;/c10&gt;</ept> is true." A proof of <bpt i="11" x="11">&lt;c11&gt;</bpt>p → q<ept i="11">&lt;/c11&gt;</ept> uses "the fact that <bpt i="12" x="12">&lt;c12&gt;</bpt>p<ept i="12">&lt;/c12&gt;</ept> is true" to obtain "the fact that <bpt i="13" x="13">&lt;c13&gt;</bpt>q<ept i="13">&lt;/c13&gt;</ept> is true."</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220211T142418Z" creationid="tlqk3" creationdate="20220211T141821Z">
        <seg><bpt i="9" x="9">&lt;c9&gt;</bpt>p<ept i="9">&lt;/c9&gt;</ept>의 머무름은 "<bpt i="10" x="10">&lt;c10&gt;</bpt>p<ept i="10">&lt;/c10&gt;</ept>가 참이라는 사실"이라 생각할 수 있습니다. <bpt i="11" x="11">&lt;c11&gt;</bpt>p → q<ept i="11">&lt;/c11&gt;</ept>의 증명은 "<bpt i="12" x="12">&lt;c12&gt;</bpt>p<ept i="12">&lt;/c12&gt;</ept>가 참이라는 사실"을 "<bpt i="13" x="13">&lt;c13&gt;</bpt>q<ept i="13">&lt;/c13&gt;</ept>이 참이라는 사실"을 얻기위해 사용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can type things into the editor and modify the examples, and Lean will check the results and provide feedback continuously as you type.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T101142Z" creationid="tlqk35" creationdate="20220130T100220Z">
        <seg>여러분은 편집기에 무언가를 치거나 예제를 수정할 수 있습니다. 그리고 린은 여러분이 치는 동안 지속적으로 결과를 확인하고 피드백을 제공할 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can use <bpt i="8" x="8">&lt;c8&gt;</bpt>⟨a, b⟩<ept i="8">&lt;/c8&gt;</ept> or <bpt i="9" x="9">&lt;c9&gt;</bpt>Sigma.mk a b<ept i="9">&lt;/c9&gt;</ept> to create a dependent pair.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T074339Z" creationid="tlqk3" creationdate="20220131T074339Z">
        <seg>여러분은 <bpt i="8" x="8">&lt;c8&gt;</bpt>⟨a, b⟩<ept i="8">&lt;/c8&gt;</ept> 또는 <bpt i="9" x="9">&lt;c9&gt;</bpt>Sigma.mk a b<ept i="9">&lt;/c9&gt;</ept>를 종속적 쌍을 만드는데 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can use other more interesting expressions inside a <bpt i="0" x="0">&lt;c0&gt;</bpt>def<ept i="0">&lt;/c0&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T065031Z" creationid="tlqk3" creationdate="20220131T065031Z">
        <seg>여러분은 다른 더 흥미로운 식을 <bpt i="0" x="0">&lt;c0&gt;</bpt>def<ept i="0">&lt;/c0&gt;</ept> 안에 사용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can use the command <bpt i="0" x="0">&lt;c0&gt;</bpt>#eval<ept i="0">&lt;/c0&gt;</ept> to execute expressions, and it is the preferred way of testing your functions.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T064041Z" creationid="tlqk3" creationdate="20220131T063915Z">
        <seg>여러분은 <bpt i="0" x="0">&lt;c0&gt;</bpt>#eval<ept i="0">&lt;/c0&gt;</ept> 명령을 사용해 식을 실행할 수 있습니다. 그리고 이것은 당신의 함수를 시험하는 선호되는 방식입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can, in general, leave off the type annotation and let Lean infer it for you.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T053901Z" creationid="tlqk3" creationdate="20220131T053901Z">
        <seg>일반적으로 여러분도 유형 표기를 빼고 린에게 유형을 추론하게 둘 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You do not have to indent the lines within a section.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T070936Z" creationid="tlqk3" creationdate="20220131T070903Z">
        <seg>섹션 안에서 줄에 들여쓰기를 하거나 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You have actually come up against one of the most subtle aspects of Lean's typing system.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T045943Z" creationid="tlqk3" creationdate="20220131T045943Z">
        <seg>여러분은 린의 유형화 시스템의 가장 미묘한 면 중 하나를 마주쳤습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You have already seen a nice example of this: the type <bpt i="0" x="0">&lt;c0&gt;</bpt>List α<ept i="0">&lt;/c0&gt;</ept> depends on the argument <bpt i="1" x="1">&lt;c1&gt;</bpt>α<ept i="1">&lt;/c1&gt;</ept>, and this dependence is what distinguishes <bpt i="2" x="2">&lt;c2&gt;</bpt>List Nat<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>List Bool<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T072123Z" creationid="tlqk3" creationdate="20220131T072123Z">
        <seg>여러분은 이것에 대한 멋진 예제를 보았습니다. 유형  <bpt i="0" x="0">&lt;c0&gt;</bpt>List α<ept i="0">&lt;/c0&gt;</ept> 는 인수 <bpt i="1" x="1">&lt;c1&gt;</bpt>α<ept i="1">&lt;/c1&gt;</ept>에 의존합니다. 여기서  <bpt i="2" x="2">&lt;c2&gt;</bpt>List Nat<ept i="2">&lt;/c2&gt;</ept>과 <bpt i="3" x="3">&lt;c3&gt;</bpt>List Bool<ept i="3">&lt;/c3&gt;</ept>을 구분하는 것은 이 의존입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You have seen that if you have <bpt i="0" x="0">&lt;c0&gt;</bpt>m : Nat<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>n : Nat<ept i="1">&lt;/c1&gt;</ept>, then <bpt i="2" x="2">&lt;c2&gt;</bpt>(m, n)<ept i="2">&lt;/c2&gt;</ept> denotes the ordered pair of <bpt i="3" x="3">&lt;c3&gt;</bpt>m<ept i="3">&lt;/c3&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt>n<ept i="4">&lt;/c4&gt;</ept> which is of type <bpt i="5" x="5">&lt;c5&gt;</bpt>Nat × Nat<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T043848Z" creationid="tlqk3" creationdate="20220131T043848Z">
        <seg>여러분은 <bpt i="0" x="0">&lt;c0&gt;</bpt>m : Nat<ept i="0">&lt;/c0&gt;</ept>과  <bpt i="1" x="1">&lt;c1&gt;</bpt>n : Nat<ept i="1">&lt;/c1&gt;</ept>이면, <bpt i="2" x="2">&lt;c2&gt;</bpt>(m, n)<ept i="2">&lt;/c2&gt;</ept>은 <bpt i="5" x="5">&lt;c5&gt;</bpt>Nat × Nat<ept i="5">&lt;/c5&gt;</ept>유형인 <bpt i="3" x="3">&lt;c3&gt;</bpt>m<ept i="3">&lt;/c3&gt;</ept>과 <bpt i="4" x="4">&lt;c4&gt;</bpt>n<ept i="4">&lt;/c4&gt;</ept>의 순서쌍을 가리킨다는 것을 보았습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You should try declaring some constants and type checking some expressions on your own.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T040158Z" creationid="tlqk3" creationdate="20220131T040158Z">
        <seg>여러분은 스스로 몇몇 상수를 선언하고 몇 가지 식의 유형을 확인해보길 바랍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You will generally use lower-case Greek letters like <bpt i="9" x="9">&lt;c9&gt;</bpt>α<ept i="9">&lt;/c9&gt;</ept>, <bpt i="10" x="10">&lt;c10&gt;</bpt>β<ept i="10">&lt;/c10&gt;</ept>, and <bpt i="11" x="11">&lt;c11&gt;</bpt>γ<ept i="11">&lt;/c11&gt;</ept> to range over types.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T042202Z" creationid="tlqk3" creationdate="20220131T042202Z">
        <seg>여러분은 유형을 포괄하기 위해  <bpt i="9" x="9">&lt;c9&gt;</bpt>α<ept i="9">&lt;/c9&gt;</ept>, <bpt i="10" x="10">&lt;c10&gt;</bpt>β<ept i="10">&lt;/c10&gt;</ept>, <bpt i="11" x="11">&lt;c11&gt;</bpt>γ<ept i="11">&lt;/c11&gt;</ept>같은 그리스 소문자 자주 사용할 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You will learn various methods to support this in <bpt i="0" x="0">&lt;a0&gt;</bpt>dependent type theory<ept i="0">&lt;/a0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T101219Z" creationid="tlqk35" creationdate="20220130T095251Z">
        <seg>여러분은 <bpt i="0" x="0">&lt;a0&gt;</bpt>의존 유형론<ept i="0">&lt;/a0&gt;</ept>에서 이를 지원하는 다양한 방법에 대해 배웁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You will see later how these terms are evaluated.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220131T060552Z" creationid="tlqk3" creationdate="20220131T060552Z">
        <seg>여러분은 나중에 이 항들이 어떻게 평가되는지 볼 겁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>by Jeremy Avigad, Leonardo de Moura, Soonho Kong and Sebastian Ullrich, with contributions from the Lean Community</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220130T073756Z" creationid="tlqk35" creationdate="20220130T073756Z">
        <seg>Jeremy Avigad, Leonardo de Moura, Soonho Kong and Sebastian Ullrich과 린 커뮤니티의 기여자들 저</seg>
      </tuv>
    </tu>
<!-- Alternative translations -->
  </body>
</tmx>
