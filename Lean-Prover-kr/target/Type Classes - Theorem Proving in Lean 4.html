<!DOCTYPE html>
<!-- saved from url=(0071)https://leanprover.github.io/theorem_proving_in_lean4/type_classes.html -->
<html lang="en" class="js sidebar-visible light"><head><meta http-equiv="content-type" content="text/html; charset=UTF-8">
        <!-- Book generated using mdBook -->
        
        <title>Type Classes - Theorem Proving in Lean 4</title>
        
        


        <!-- Custom HTML head -->
        


        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="rgba(0, 0, 0, 0)">

        
        <link rel="icon" href="https://leanprover.github.io/theorem_proving_in_lean4/favicon.svg">
        
        
        <link rel="shortcut icon" href="https://leanprover.github.io/theorem_proving_in_lean4/favicon.png">
        
        <link rel="stylesheet" href="./Type Classes - Theorem Proving in Lean 4_files/variables.css">
        <link rel="stylesheet" href="./Type Classes - Theorem Proving in Lean 4_files/general.css">
        <link rel="stylesheet" href="./Type Classes - Theorem Proving in Lean 4_files/chrome.css">
        
        <link rel="stylesheet" href="./Type Classes - Theorem Proving in Lean 4_files/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="./Type Classes - Theorem Proving in Lean 4_files/font-awesome.css">
        
        <link rel="stylesheet" href="./Type Classes - Theorem Proving in Lean 4_files/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="./Type Classes - Theorem Proving in Lean 4_files/highlight.css">
        <link rel="stylesheet" href="./Type Classes - Theorem Proving in Lean 4_files/tomorrow-night.css" disabled="">
        <link rel="stylesheet" href="./Type Classes - Theorem Proving in Lean 4_files/ayu-highlight.css" disabled="">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents" aria-hidden="false">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="https://leanprover.github.io/theorem_proving_in_lean4/title_page.html" tabindex="0">린 4로 하는 정리 증명</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/introduction.html" tabindex="0"><strong aria-hidden="true">1.</strong> 소개(Introduction)</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/dependent_type_theory.html" tabindex="0"><strong aria-hidden="true">2.</strong> 의존 유형론(Dependent Type Theory)</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/propositions_and_proofs.html" tabindex="0"><strong aria-hidden="true">3.</strong> 명제와 증명(Propositions and Proofs)</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html" tabindex="0"><strong aria-hidden="true">4.</strong> 한정기호와 동등성(Quantifiers and Equality)</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/tactics.html" tabindex="0"><strong aria-hidden="true">5.</strong> 전략(Tactics)</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/interacting_with_lean.html" tabindex="0"><strong aria-hidden="true">6.</strong> 린과 상호작용하기(Interacting with Lean)</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/inductive_types.html" tabindex="0"><strong aria-hidden="true">7.</strong> 귀납형(Inductive Types)</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html" tabindex="0"><strong aria-hidden="true">8.</strong> 귀납과 재귀(Induction and Recursion)</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/structures_and_records.html" tabindex="0"><strong aria-hidden="true">9.</strong> 구조체와 레코드(Structures and Records)</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/type_classes.html" class="active" tabindex="0"><strong aria-hidden="true">10.</strong> 유형 계층(Type Classes)</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/conv.html" tabindex="0"><strong aria-hidden="true">11.</strong> 전략 모드로 전환(The Conversion Tactic Mode)</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/axioms_and_computation.html" tabindex="0"><strong aria-hidden="true">12.</strong> 공리계와 계산(Axioms and Computation)</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar" style="top: 0px;">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="목차 토글" aria-label="Toggle Table of Contents" aria-controls="sidebar" aria-expanded="true">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="테마 바꾸기" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">밝게(기본)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">녹슨 색</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">검은색</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">짙푸른색</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">짙은 검은색</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="탐색. (단축기: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">린 4로 하는 정리 증명</h1>

                    <div class="right-buttons">
                        
                        <a href="https://leanprover.github.io/theorem_proving_in_lean4/print.html" title="책 인쇄하기" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/leanprover/theorem_proving_in_lean4" title="깃 저장소" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" placeholder="이 책을 찾아보기 ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/type_classes.html#type-classes" id="type-classes">Type classes</a></h1>
<p>Type classes were introduced as a principled way of enabling
ad-hoc polymorphism in functional programming languages. We first observe that it
would be easy to implement an ad-hoc polymorphic function (such as addition) if the
function simply took the type-specific implementation of addition as an argument
and then called that implementation on the remaining arguments. For example,
suppose we declare a structure in Lean to hold implementations of addition</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="숨겨진 선 보이기" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="boring"><span class="hljs-keyword">namespace</span> Ex
</span><span class="hljs-theorem"><span class="hljs-keyword">structure</span> <span class="hljs-title">A</span><span class="hljs-title">d</span><span class="hljs-title">d</span> <span class="hljs-params">(a : <span class="hljs-built_in">Type</span>)</span></span> <span class="hljs-keyword">where</span>
  add : a -&gt; a -&gt; a

<span class="hljs-keyword">#check</span> @Add.add
<span class="hljs-comment">-- Add.add : {a : Type} → Add a → a → a → a</span>
<span class="boring"><span class="hljs-keyword">end</span> Ex
</span></code></pre>
<p>In the above Lean code, the field <code class="hljs">add</code> has type
<code class="hljs">Add.add : {α : Type} → Add α → α → α → α</code>
where the curly braces around the type <code class="hljs">a</code> mean that it is an implicit argument.
We could implement <code class="hljs">double</code> by</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="숨겨진 선 보이기" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="boring"><span class="hljs-keyword">namespace</span> Ex
</span><span class="boring"><span class="hljs-theorem"><span class="hljs-keyword">structure</span> <span class="hljs-title">A</span><span class="hljs-title">d</span><span class="hljs-title">d</span> <span class="hljs-params">(a : <span class="hljs-built_in">Type</span>)</span></span> <span class="hljs-keyword">where</span>
</span><span class="boring"> add : a -&gt; a -&gt; a
</span><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span><span class="hljs-title">o</span><span class="hljs-title">u</span><span class="hljs-title">b</span><span class="hljs-title">l</span><span class="hljs-title">e</span> <span class="hljs-params">(s : Add a)</span> <span class="hljs-params">(x : a)</span> <span class="hljs-symbol">:</span></span> a :=
  s.add x x

<span class="hljs-keyword">#eval</span> double { add := Nat.add } <span class="hljs-number">10</span>
<span class="hljs-comment">-- 20</span>

<span class="hljs-keyword">#eval</span> double { add := Nat.mul } <span class="hljs-number">10</span>
<span class="hljs-comment">-- 100</span>

<span class="hljs-keyword">#eval</span> double { add := Int.add } <span class="hljs-number">10</span>
<span class="hljs-comment">-- 20</span>

<span class="boring"><span class="hljs-keyword">end</span> Ex
</span></code></pre>
<p>Note that you can double a natural number <code class="hljs">n</code> by <code class="hljs">double { add := Nat.add } n</code>.
Of course, it would be highly cumbersome for users to manually pass the
implementations around in this way.
Indeed, it would defeat most of the potential benefits of ad-hoc
polymorphism.</p>
<p>The main idea behind type classes is to make arguments such as <code class="hljs">Add a</code> implicit,
and to use a database of user-defined instances to synthesize the desired instances
automatically through a process known as typeclass resolution. In Lean, by changing
<code class="hljs">structure</code> to <code class="hljs">class</code> in the example above, the type of <code class="hljs">Add.add</code> becomes</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="숨겨진 선 보이기" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="boring"><span class="hljs-keyword">namespace</span> Ex
</span><span class="hljs-theorem"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span><span class="hljs-title">d</span><span class="hljs-title">d</span> <span class="hljs-params">(a : <span class="hljs-built_in">Type</span>)</span></span> <span class="hljs-keyword">where</span>
  add : a -&gt; a -&gt; a

<span class="hljs-keyword">#check</span> @Add.add
<span class="hljs-comment">-- Add.add : {a : Type} → [self : Add a] → a → a → a</span>
<span class="boring"><span class="hljs-keyword">end</span> Ex
</span></code></pre>
<p>where the square brackets indicate that the argument of type <code class="hljs">Add a</code> is <em>instance implicit</em>,
i.e. that it should be synthesized using typeclass resolution. This version of
<code class="hljs">add</code> is the Lean analogue of the Haskell term <code class="hljs">add :: Add a =&gt; a -&gt; a -&gt; a</code>.
Similarly, we can register an instance by</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="숨겨진 선 보이기" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="boring"><span class="hljs-keyword">namespace</span> Ex
</span><span class="boring"><span class="hljs-theorem"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span><span class="hljs-title">d</span><span class="hljs-title">d</span> <span class="hljs-params">(a : <span class="hljs-built_in">Type</span>)</span></span> <span class="hljs-keyword">where</span>
</span><span class="boring"> add : a -&gt; a -&gt; a
</span><span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> Add Nat <span class="hljs-keyword">where</span>
  add := Nat.add

<span class="boring"><span class="hljs-keyword">end</span> Ex
</span></code></pre>
<p>Then for <code class="hljs">n : Nat</code> and <code class="hljs">m : Nat</code>, the term <code class="hljs">Add.add n m</code> triggers typeclass resolution with the goal
of <code class="hljs">Add Nat</code>, and typeclass resolution will synthesize the instance above. In
general, instances may depend on other instances in complicated ways. For example,
you can declare an (anonymous) instance stating that if <code class="hljs">a</code> has addition, then <code class="hljs">Array a</code>
has addition:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-params">[Add a]</span> <span class="hljs-symbol">:</span></span> Add (Array a) <span class="hljs-keyword">where</span>
  add x y := Array.zipWith x y (. + .)

<span class="hljs-keyword">#eval</span> Add.add #[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>] #[<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]
<span class="hljs-comment">-- #[4, 6]</span>

<span class="hljs-keyword">#eval</span> #[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>] + #[<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]
<span class="hljs-comment">-- #[4, 6]</span>
</code></pre>
<p>Note that <code class="hljs">x + y</code> is notation for <code class="hljs">Add.add x y</code> in Lean.</p>
<p>The example above demonstrates how type classes are used to overload notation.
Now, we explore another application. We often need an arbitrary element of a given type.
Recall that types may not have any elements in Lean.
It often happens that we would like a definition to return an arbitrary element in a "corner case."
For example, we may like the expression <code class="hljs">head xs</code> to be of type <code class="hljs">a</code> when <code class="hljs">xs</code> is of type <code class="hljs">List a</code>.
Similarly, many theorems hold under the additional assumption that a type is not empty.
For example, if <code class="hljs">a</code> is a type, <code class="hljs">exists x : a, x = x</code> is true only if <code class="hljs">a</code> is not empty.
The standard library defines a type class <code class="hljs">Inhabited</code> to enable type class inference to infer a
"default" or "arbitrary" element of an inhabited type.
Let us start with the first step of the program above, declaring an appropriate class:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="숨겨진 선 보이기" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="boring"><span class="hljs-keyword">namespace</span> Ex
</span><span class="hljs-theorem"><span class="hljs-keyword">class</span> <span class="hljs-title">I</span><span class="hljs-title">n</span><span class="hljs-title">h</span><span class="hljs-title">a</span><span class="hljs-title">b</span><span class="hljs-title">i</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">d</span> <span class="hljs-params">(a : <span class="hljs-built_in">Type</span> u)</span></span> <span class="hljs-keyword">where</span>
  default : a

<span class="hljs-keyword">#check</span> @Inhabited.default
<span class="hljs-comment">-- Inhabited.default : {a : Type u} → [self : Inhabited a] → a</span>
<span class="boring"><span class="hljs-keyword">end</span> Ex
</span></code></pre>
<p>Note <code class="hljs">Inhabited.default</code> doesn't have any explicit argument.</p>
<p>An element of the class <code class="hljs">Inhabited a</code> is simply an expression of the form <code class="hljs">Inhabited.mk x</code>, for some element <code class="hljs">x : a</code>.
The projection <code class="hljs">Inhabited.default</code> will allow us to "extract" such an element of <code class="hljs">a</code> from an element of <code class="hljs">Inhabited a</code>.
Now we populate the class with some instances:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="숨겨진 선 보이기" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="boring"><span class="hljs-keyword">namespace</span> Ex
</span><span class="boring"><span class="hljs-theorem"><span class="hljs-keyword">class</span> <span class="hljs-title">I</span><span class="hljs-title">n</span><span class="hljs-title">h</span><span class="hljs-title">a</span><span class="hljs-title">b</span><span class="hljs-title">i</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">d</span> <span class="hljs-params">(a : <span class="hljs-built_in">Type</span> _)</span></span> <span class="hljs-keyword">where</span>
</span><span class="boring"> default : a
</span><span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> Inhabited Bool <span class="hljs-keyword">where</span>
  default := <span class="hljs-literal">true</span>

<span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> Inhabited Nat <span class="hljs-keyword">where</span>
  default := <span class="hljs-number">0</span>

<span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> Inhabited Unit <span class="hljs-keyword">where</span>
  default := ()

<span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> Inhabited <span class="hljs-built_in">Prop</span> <span class="hljs-keyword">where</span>
  default := True

<span class="hljs-keyword">#eval</span> (Inhabited.default : Nat)
<span class="hljs-comment">-- 0</span>

<span class="hljs-keyword">#eval</span> (Inhabited.default : Bool)
<span class="hljs-comment">-- true</span>
<span class="boring"><span class="hljs-keyword">end</span> Ex
</span></code></pre>
<p>You can use the command <code class="hljs">export</code> to create the alias <code class="hljs">default</code> for <code class="hljs">Inhabited.default</code></p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="숨겨진 선 보이기" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="boring"><span class="hljs-keyword">namespace</span> Ex
</span><span class="boring"><span class="hljs-theorem"><span class="hljs-keyword">class</span> <span class="hljs-title">I</span><span class="hljs-title">n</span><span class="hljs-title">h</span><span class="hljs-title">a</span><span class="hljs-title">b</span><span class="hljs-title">i</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">d</span> <span class="hljs-params">(a : <span class="hljs-built_in">Type</span> _)</span></span> <span class="hljs-keyword">where</span>
</span><span class="boring"> default : a
</span><span class="boring"><span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> Inhabited Bool <span class="hljs-keyword">where</span>
</span><span class="boring"> default := <span class="hljs-literal">true</span>
</span><span class="boring"><span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> Inhabited Nat <span class="hljs-keyword">where</span>
</span><span class="boring"> default := <span class="hljs-number">0</span>
</span><span class="boring"><span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> Inhabited Unit <span class="hljs-keyword">where</span>
</span><span class="boring"> default := ()
</span><span class="boring"><span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> Inhabited <span class="hljs-built_in">Prop</span> <span class="hljs-keyword">where</span>
</span><span class="boring"> default := True
</span><span class="hljs-keyword">export</span> Inhabited (default)

<span class="hljs-keyword">#eval</span> (default : Nat)
<span class="hljs-comment">-- 0</span>

<span class="hljs-keyword">#eval</span> (default : Bool)
<span class="hljs-comment">-- true</span>
<span class="boring"><span class="hljs-keyword">end</span> Ex
</span></code></pre>
<p>Sometimes we want to think of the default element of a type as being an <em>arbitrary</em> element, whose specific value should not play a role in our proofs.
For that purpose, we can write <code class="hljs">arbitrary</code> instead of <code class="hljs">default</code>. We define <code class="hljs">arbitrary</code> as an <em>opaque</em> constant.
Opaque constants are never unfolded by the type checker.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="숨겨진 선 보이기" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="boring"><span class="hljs-keyword">namespace</span> Ex
</span><span class="boring"><span class="hljs-keyword">export</span> Inhabited (default)
</span><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">d</span><span class="hljs-title">e</span><span class="hljs-title">f</span><span class="hljs-title">N</span><span class="hljs-title">a</span><span class="hljs-title">t</span><span class="hljs-title">E</span><span class="hljs-title">q0</span> <span class="hljs-symbol">:</span></span> (default : Nat) = <span class="hljs-number">0</span> :=
  <span class="hljs-built_in">rfl</span>

<span class="hljs-keyword">constant</span> arbitrary [Inhabited a] : a :=
  Inhabited.default

<span class="hljs-comment">-- theorem arbitraryNatEq0 : (arbitrary : Nat) = 0 :=</span>
<span class="hljs-comment">--   rfl</span>
<span class="hljs-comment">/-
error: type mismatch
  rfl
has type
  arbitrary = arbitrary
but is expected to have type
  arbitrary = 0
-/</span>
<span class="boring"><span class="hljs-keyword">end</span> Ex
</span></code></pre>
<p>The theorem <code class="hljs">defNatEq0</code> type checks because the type checker can unfold <code class="hljs">(default : Nat)</code> and reduce it to <code class="hljs">0</code>. This is not the case in the theorem <code class="hljs">arbitraryNatEq0</code> because <code class="hljs">arbitrary</code> is an opaque constant.</p>
<h2><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/type_classes.html#chaining-instances" id="chaining-instances">Chaining Instances</a></h2>
<p>If that were the extent of type class inference, it would not be all that impressive;
it would be simply a mechanism of storing a list of instances for the elaborator to find in a lookup table.
What makes type class inference powerful is that one can <em>chain</em> instances. That is,
an instance declaration can in turn depend on an implicit instance of a type class.
This causes class inference to chain through instances recursively, backtracking when necessary, in a Prolog-like search.</p>
<p>For example, the following definition shows that if two types <code class="hljs">a</code> and <code class="hljs">b</code> are inhabited, then so is their product:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-params">[Inhabited a]</span> <span class="hljs-params">[Inhabited b]</span> <span class="hljs-symbol">:</span></span> Inhabited (a × b) <span class="hljs-keyword">where</span>
  default := (arbitrary, arbitrary)
</code></pre>
<p>With this added to the earlier instance declarations, type class instance can infer, for example, a default element of <code class="hljs">Nat × Bool</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="숨겨진 선 보이기" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="boring"><span class="hljs-keyword">namespace</span> Ex
</span><span class="boring"><span class="hljs-theorem"><span class="hljs-keyword">class</span> <span class="hljs-title">I</span><span class="hljs-title">n</span><span class="hljs-title">h</span><span class="hljs-title">a</span><span class="hljs-title">b</span><span class="hljs-title">i</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">d</span> <span class="hljs-params">(a : <span class="hljs-built_in">Type</span> u)</span></span> <span class="hljs-keyword">where</span>
</span><span class="boring"> default : a
</span><span class="boring"><span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> Inhabited Bool <span class="hljs-keyword">where</span>
</span><span class="boring"> default := <span class="hljs-literal">true</span>
</span><span class="boring"><span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> Inhabited Nat <span class="hljs-keyword">where</span>
</span><span class="boring"> default := <span class="hljs-number">0</span>
</span><span class="boring"><span class="hljs-keyword">constant</span> arbitrary [Inhabited a] : a :=
</span><span class="boring"> Inhabited.default
</span><span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-params">[Inhabited a]</span> <span class="hljs-params">[Inhabited b]</span> <span class="hljs-symbol">:</span></span> Inhabited (a × b) <span class="hljs-keyword">where</span>
  default := (arbitrary, arbitrary)

<span class="hljs-keyword">#eval</span> (arbitrary : Nat × Bool)
<span class="hljs-comment">-- (0, true)</span>
<span class="boring"><span class="hljs-keyword">end</span> Ex
</span></code></pre>
<p>Similarly, we can inhabit type function with suitable constant functions:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-params">[Inhabited b]</span> <span class="hljs-symbol">:</span></span> Inhabited (a -&gt; b) <span class="hljs-keyword">where</span>
  default := <span class="hljs-keyword">fun</span> _ =&gt; arbitrary
</code></pre>
<p>As an exercise, try defining default instances for other types, such as <code class="hljs">List</code> and <code class="hljs">Sum</code> types.</p>
<p>The Lean standard library contains the definition <code class="hljs">inferInstance</code>. It has type <code class="hljs">{α : Sort u} → [i : α] → α</code>,
and is useful for triggering the type class resolution procedure when the expected type is an instance.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> (inferInstance : Inhabited Nat) <span class="hljs-comment">-- Inhabited Nat</span>

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-title">o</span><span class="hljs-title">o</span> <span class="hljs-symbol">:</span></span> Inhabited (Nat × Nat) :=
  inferInstance

<span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">e</span><span class="hljs-title">x</span> <span class="hljs-symbol">:</span></span> foo.default = (arbitrary, arbitrary) :=
  <span class="hljs-built_in">rfl</span>
</code></pre>
<p>You can use the command <code class="hljs">#print</code> to inspect how simple <code class="hljs">inferInstance</code> is.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#print</span> inferInstance
</code></pre>
<h2><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/type_classes.html#tostring" id="tostring">ToString</a></h2>
<p>The polymorphic method <code class="hljs">toString</code> has type <code class="hljs">{α : Type u} → [ToString α] → α → String</code>. You implement the instance
for your own types and use chaining to convert complex values into strings. Lean comes with <code class="hljs">ToString</code> instances
for most builtin types.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">structure</span> <span class="hljs-title">P</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">s</span><span class="hljs-title">o</span><span class="hljs-title">n</span></span> <span class="hljs-keyword">where</span>
  name : String
  age  : Nat

<span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> ToString Person <span class="hljs-keyword">where</span>
  toString p := p.name ++ <span class="hljs-string">"@"</span> ++ toString p.age

<span class="hljs-keyword">#eval</span> toString { name := <span class="hljs-string">"Leo"</span>, age := <span class="hljs-number">542</span> : Person }
<span class="hljs-keyword">#eval</span> toString ({ name := <span class="hljs-string">"Daniel"</span>, age := <span class="hljs-number">18</span> : Person }, <span class="hljs-string">"hello"</span>)
</code></pre>
<h2><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/type_classes.html#numerals" id="numerals">Numerals</a></h2>
<p>Numerals are polymorphic in Lean. You can use a numeral (e.g., <code class="hljs">2</code>) to denote an element of any type that implements
the type class <code class="hljs">OfNat</code>.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">structure</span> <span class="hljs-title">R</span><span class="hljs-title">a</span><span class="hljs-title">t</span><span class="hljs-title">i</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">a</span><span class="hljs-title">l</span></span> <span class="hljs-keyword">where</span>
  num : Int
  den : Nat
  inv : den ≠ <span class="hljs-number">0</span>

<span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> OfNat Rational n <span class="hljs-keyword">where</span>
  ofNat := { num := n, den := <span class="hljs-number">1</span>, inv := <span class="hljs-keyword">by</span> decide }

<span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> ToString Rational <span class="hljs-keyword">where</span>
  toString r := s!<span class="hljs-string">"{r.num}/{r.den}"</span>

<span class="hljs-keyword">#eval</span> (<span class="hljs-number">2</span> : Rational) <span class="hljs-comment">-- 2/1</span>

<span class="hljs-keyword">#check</span> (<span class="hljs-number">2</span> : Rational) <span class="hljs-comment">-- Rational</span>
<span class="hljs-keyword">#check</span> (<span class="hljs-number">2</span> : Nat)      <span class="hljs-comment">-- Nat</span>
</code></pre>
<p>Lean elaborates the terms <code class="hljs">(2 : Nat)</code> and <code class="hljs">(2 : Rational)</code> as
<code class="hljs">OfNat.ofNat Nat 2 (instOfNatNat 2)</code> and
<code class="hljs">OfNat.ofNat Rational 2 (instOfNatRational 2)</code> respectively.
We say the numerals <code class="hljs">2</code> occurring in the elaborated terms are <em>raw</em> natural numbers.
You can input the raw natural number <code class="hljs">2</code> using the macro <code class="hljs">nat_lit 2</code>.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> nat_lit <span class="hljs-number">2</span>  <span class="hljs-comment">-- Nat</span>
</code></pre>
<p>Raw natural numbers are <em>not</em> polymorphic.</p>
<p>The <code class="hljs">OfNat</code> instance is parametric on the numeral. So, you can define instances for particular numerals.
The second argument is often a variable as in the example above, or a <em>raw</em> natural number.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">class</span> <span class="hljs-title">M</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">o</span><span class="hljs-title">i</span><span class="hljs-title">d</span> <span class="hljs-params">(α : <span class="hljs-built_in">Type</span> u)</span></span> <span class="hljs-keyword">where</span>
  unit : α
  op   : α → α → α

<span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-params">[s : Monoid α]</span> <span class="hljs-symbol">:</span></span> OfNat α (nat_lit <span class="hljs-number">1</span>) <span class="hljs-keyword">where</span>
  ofNat := s.unit

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">g</span><span class="hljs-title">e</span><span class="hljs-title">t</span><span class="hljs-title">U</span><span class="hljs-title">n</span><span class="hljs-title">i</span><span class="hljs-title">t</span> <span class="hljs-params">[Monoid α]</span> <span class="hljs-symbol">:</span></span> α :=
  <span class="hljs-number">1</span>
</code></pre>
<h2><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/type_classes.html#output-parameters" id="output-parameters">Output parameters</a></h2>
<p>By default, Lean only tries to synthesize an instance <code class="hljs">Inhabited T</code> when the term <code class="hljs">T</code> is known and does not
contain missing parts. The following command produces the error
"failed to create type class instance for <code class="hljs">Inhabited (Nat × ?m.1499)</code>" because the type has a missing part (i.e., the <code class="hljs">_</code>).</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check_failure</span> (inferInstance : Inhabited (Nat × _))
</code></pre>
<p>You can view the parameter of the type class <code class="hljs">Inhabited</code> as an <em>input</em> value for the type class synthesizer.
When a type class has multiple parameters, you can mark some of them as output parameters.
Lean will start type class synthesizer even when these parameters have missing parts.
In the following example, we use output parameters to define a <em>heterogeneous</em> polymorphic
multiplication.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="숨겨진 선 보이기" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="boring"><span class="hljs-keyword">namespace</span> Ex
</span><span class="hljs-theorem"><span class="hljs-keyword">class</span> <span class="hljs-title">H</span><span class="hljs-title">M</span><span class="hljs-title">u</span><span class="hljs-title">l</span> <span class="hljs-params">(α : <span class="hljs-built_in">Type</span> u)</span> <span class="hljs-params">(β : <span class="hljs-built_in">Type</span> v)</span> <span class="hljs-params">(γ : outParam (<span class="hljs-built_in">Type</span> w)</span>)</span> <span class="hljs-keyword">where</span>
  hMul : α → β → γ

<span class="hljs-keyword">export</span> HMul (hMul)

<span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> HMul Nat Nat Nat <span class="hljs-keyword">where</span>
  hMul := Nat.mul

<span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> HMul Nat (Array Nat) (Array Nat) <span class="hljs-keyword">where</span>
  hMul a bs := bs.map (<span class="hljs-keyword">fun</span> b =&gt; hMul a b)

<span class="hljs-keyword">#eval</span> hMul <span class="hljs-number">4</span> <span class="hljs-number">3</span>           <span class="hljs-comment">-- 12</span>
<span class="hljs-keyword">#eval</span> hMul <span class="hljs-number">4</span> #[<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]  <span class="hljs-comment">-- #[8, 12, 16]</span>
<span class="boring"><span class="hljs-keyword">end</span> Ex
</span></code></pre>
<p>The parameters <code class="hljs">α</code> and <code class="hljs">β</code> are considered input parameters and <code class="hljs">γ</code> an output one.
Given an application <code class="hljs">hMul a b</code>, after types of <code class="hljs">a</code> and <code class="hljs">b</code> are known, the type class
synthesizer is invoked, and the resulting type is obtained from the output parameter <code class="hljs">γ</code>.
In the example above, we defined two instances. The first one is the homogeneous
multiplication for natural numbers. The second is the scalar multiplication for arrays.
Note that you chain instances and generalize the second instance.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="숨겨진 선 보이기" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="boring"><span class="hljs-keyword">namespace</span> Ex
</span><span class="hljs-theorem"><span class="hljs-keyword">class</span> <span class="hljs-title">H</span><span class="hljs-title">M</span><span class="hljs-title">u</span><span class="hljs-title">l</span> <span class="hljs-params">(α : <span class="hljs-built_in">Type</span> u)</span> <span class="hljs-params">(β : <span class="hljs-built_in">Type</span> v)</span> <span class="hljs-params">(γ : outParam (<span class="hljs-built_in">Type</span> w)</span>)</span> <span class="hljs-keyword">where</span>
  hMul : α → β → γ

<span class="hljs-keyword">export</span> HMul (hMul)

<span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> HMul Nat Nat Nat <span class="hljs-keyword">where</span>
  hMul := Nat.mul

<span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> HMul Int Int Int <span class="hljs-keyword">where</span>
  hMul := Int.mul

<span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-params">[HMul α β γ]</span> <span class="hljs-symbol">:</span></span> HMul α (Array β) (Array γ) <span class="hljs-keyword">where</span>
  hMul a bs := bs.map (<span class="hljs-keyword">fun</span> b =&gt; hMul a b)

<span class="hljs-keyword">#eval</span> hMul <span class="hljs-number">4</span> <span class="hljs-number">3</span>                    <span class="hljs-comment">-- 12</span>
<span class="hljs-keyword">#eval</span> hMul <span class="hljs-number">4</span> #[<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]           <span class="hljs-comment">-- #[8, 12, 16]</span>
<span class="hljs-keyword">#eval</span> hMul (-<span class="hljs-number">2</span>) #[<span class="hljs-number">3</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">4</span>]       <span class="hljs-comment">-- #[-6, 2, -8]</span>
<span class="hljs-keyword">#eval</span> hMul <span class="hljs-number">2</span> #[#[<span class="hljs-number">2</span>, <span class="hljs-number">3</span>], #[<span class="hljs-number">0</span>, <span class="hljs-number">4</span>]]  <span class="hljs-comment">-- #[#[4, 6], #[0, 8]]</span>
<span class="boring"><span class="hljs-keyword">end</span> Ex
</span></code></pre>
<p>You can use our new scalar array multiplication instance on arrays of type <code class="hljs">Array β</code>
with a scalar of type <code class="hljs">α</code> whenever you have an instance <code class="hljs">HMul α β γ</code>.
In the last <code class="hljs">#eval</code>, note that the instance was used twice on an array of arrays.</p>
<h2><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/type_classes.html#default-instances" id="default-instances">Default instances</a></h2>
<p>In the class <code class="hljs">HMul</code>, the parameters <code class="hljs">α</code> and <code class="hljs">β</code> are treated as input values.
Thus, type class synthesis only starts after these two types are known. This may often
be too restrictive.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="숨겨진 선 보이기" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="boring"><span class="hljs-keyword">namespace</span> Ex
</span><span class="hljs-theorem"><span class="hljs-keyword">class</span> <span class="hljs-title">H</span><span class="hljs-title">M</span><span class="hljs-title">u</span><span class="hljs-title">l</span> <span class="hljs-params">(α : <span class="hljs-built_in">Type</span> u)</span> <span class="hljs-params">(β : <span class="hljs-built_in">Type</span> v)</span> <span class="hljs-params">(γ : outParam (<span class="hljs-built_in">Type</span> w)</span>)</span> <span class="hljs-keyword">where</span>
  hMul : α → β → γ

<span class="hljs-keyword">export</span> HMul (hMul)

<span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> HMul Int Int Int <span class="hljs-keyword">where</span>
  hMul := Int.mul

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">x</span><span class="hljs-title">s</span> <span class="hljs-symbol">:</span></span> List Int := [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]

<span class="hljs-comment">-- Error "failed to create type class instance for HMul Int ?m.1767 (?m.1797 x)"</span>
<span class="hljs-keyword">#check_failure</span> <span class="hljs-keyword">fun</span> y =&gt; xs.map (<span class="hljs-keyword">fun</span> x =&gt; hMul x y)
<span class="boring"><span class="hljs-keyword">end</span> Ex
</span></code></pre>
<p>The instance <code class="hljs">HMul</code> is not synthesized by Lean because the type of <code class="hljs">y</code> has not been provided.
However, it is natural to assume that the type of <code class="hljs">y</code> and <code class="hljs">x</code> should be the same in
this kind of situation. We can achieve exactly that using <em>default instances</em>.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="숨겨진 선 보이기" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="boring"><span class="hljs-keyword">namespace</span> Ex
</span><span class="hljs-theorem"><span class="hljs-keyword">class</span> <span class="hljs-title">H</span><span class="hljs-title">M</span><span class="hljs-title">u</span><span class="hljs-title">l</span> <span class="hljs-params">(α : <span class="hljs-built_in">Type</span> u)</span> <span class="hljs-params">(β : <span class="hljs-built_in">Type</span> v)</span> <span class="hljs-params">(γ : outParam (<span class="hljs-built_in">Type</span> w)</span>)</span> <span class="hljs-keyword">where</span>
  hMul : α → β → γ

<span class="hljs-keyword">export</span> HMul (hMul)

<span class="hljs-meta">@[defaultInstance]</span>
<span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> HMul Int Int Int <span class="hljs-keyword">where</span>
  hMul := Int.mul

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">x</span><span class="hljs-title">s</span> <span class="hljs-symbol">:</span></span> List Int := [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]

<span class="hljs-keyword">#check</span> <span class="hljs-keyword">fun</span> y =&gt; xs.map (<span class="hljs-keyword">fun</span> x =&gt; hMul x y)  <span class="hljs-comment">-- Int -&gt; List Int</span>
<span class="boring"><span class="hljs-keyword">end</span> Ex
</span></code></pre>
<p>By tagging the instance above with the attribute <code class="hljs">defaultInstance</code>, we are instructing Lean
to use this instance on pending type class synthesis problems.
The actual Lean implementation defines homogeneous and heterogeneous classes for arithmetical operators.
Moreover, <code class="hljs">a+b</code>, <code class="hljs">a*b</code>, <code class="hljs">a-b</code>, <code class="hljs">a/b</code>, and <code class="hljs">a%b</code> are notations for the heterogeneous versions.
The instance <code class="hljs">OfNat Nat n</code> is the default instance for the <code class="hljs">OfNat</code> class. This is why the numeral
<code class="hljs">2</code> has type <code class="hljs">Nat</code> when the expected type is not known. You can define default instances with higher
priority to override the builtin ones.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">structure</span> <span class="hljs-title">R</span><span class="hljs-title">a</span><span class="hljs-title">t</span><span class="hljs-title">i</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">a</span><span class="hljs-title">l</span></span> <span class="hljs-keyword">where</span>
  num : Int
  den : Nat
  inv : den ≠ <span class="hljs-number">0</span>

<span class="hljs-meta">@[defaultInstance 1]</span>
<span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> OfNat Rational n <span class="hljs-keyword">where</span>
  ofNat := { num := n, den := <span class="hljs-number">1</span>, inv := <span class="hljs-keyword">by</span> decide }

<span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> ToString Rational <span class="hljs-keyword">where</span>
  toString r := s!<span class="hljs-string">"{r.num}/{r.den}"</span>

<span class="hljs-keyword">#check</span> <span class="hljs-number">2</span> <span class="hljs-comment">-- Rational</span>
</code></pre>
<p>Priorities are also useful to control the interaction between different default instances.
For example, suppose <code class="hljs">xs</code> has type <code class="hljs">α</code>, when elaboration <code class="hljs">xs.map (fun x =&gt; 2 * x)</code>, we want the homogeneous instance for multiplication
to have higher priority than the default instance for <code class="hljs">OfNat</code>. This is particularly important when we have implemented only the instance
<code class="hljs">HMul α α α</code>, and did not implement <code class="hljs">HMul Nat α α</code>.
Now, we reveal how the notation <code class="hljs">a*b</code> is defined in Lean.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="숨겨진 선 보이기" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="boring"><span class="hljs-keyword">namespace</span> Ex
</span><span class="hljs-theorem"><span class="hljs-keyword">class</span> <span class="hljs-title">O</span><span class="hljs-title">f</span><span class="hljs-title">N</span><span class="hljs-title">a</span><span class="hljs-title">t</span> <span class="hljs-params">(α : <span class="hljs-built_in">Type</span> u)</span> <span class="hljs-params">(n : Nat)</span></span> <span class="hljs-keyword">where</span>
  ofNat : α

<span class="hljs-meta">@[defaultInstance]</span>
<span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-params">(n : Nat)</span> <span class="hljs-symbol">:</span></span> OfNat Nat n <span class="hljs-keyword">where</span>
  ofNat := n

<span class="hljs-theorem"><span class="hljs-keyword">class</span> <span class="hljs-title">H</span><span class="hljs-title">M</span><span class="hljs-title">u</span><span class="hljs-title">l</span> <span class="hljs-params">(α : <span class="hljs-built_in">Type</span> u)</span> <span class="hljs-params">(β : <span class="hljs-built_in">Type</span> v)</span> <span class="hljs-params">(γ : outParam (<span class="hljs-built_in">Type</span> w)</span>)</span> <span class="hljs-keyword">where</span>
  hMul : α → β → γ

<span class="hljs-theorem"><span class="hljs-keyword">class</span> <span class="hljs-title">M</span><span class="hljs-title">u</span><span class="hljs-title">l</span> <span class="hljs-params">(α : <span class="hljs-built_in">Type</span> u)</span></span> <span class="hljs-keyword">where</span>
  mul : α → α → α

<span class="hljs-meta">@[defaultInstance 10]</span>
<span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-params">[Mul α]</span> <span class="hljs-symbol">:</span></span> HMul α α α <span class="hljs-keyword">where</span>
  hMul a b := Mul.mul a b

<span class="hljs-keyword">infixl</span>:<span class="hljs-number">70</span> <span class="hljs-string">" * "</span>  =&gt; HMul.hMul
<span class="boring"><span class="hljs-keyword">end</span> Ex
</span></code></pre>
<p>The <code class="hljs">Mul</code> class is convenient for types that only implement the homogeneous multiplication.</p>
<h2><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/type_classes.html#local-instances" id="local-instances">Local Instances</a></h2>
<p>Type classes are implemented using attributes in Lean. Thus, you can
use the <code class="hljs">local</code> modifier to indicate that they only have effect until
the current <code class="hljs">section</code> or <code class="hljs">namespace</code> is closed, or until the end
of the current file.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">structure</span> <span class="hljs-title">P</span><span class="hljs-title">o</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">t</span></span> <span class="hljs-keyword">where</span>
  x : Nat
  y : Nat

<span class="hljs-keyword">section</span>

<span class="hljs-keyword">local</span> <span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> Add Point <span class="hljs-keyword">where</span>
  add a b := { x := a.x + b.x, y := a.y + b.y }

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span><span class="hljs-title">o</span><span class="hljs-title">u</span><span class="hljs-title">b</span><span class="hljs-title">l</span><span class="hljs-title">e</span> <span class="hljs-params">(p : Point)</span> <span class="hljs-symbol">:</span></span>=
  p + p

<span class="hljs-keyword">end</span> <span class="hljs-comment">-- instance `Add Point` is not active anymore</span>

<span class="hljs-comment">-- def triple (p : Point) :=</span>
<span class="hljs-comment">--  p + p + p  -- Error: failed to sythesize instance</span>
</code></pre>
<p>You can also temporarily disable an instance using the <code class="hljs">attribute</code> command
until the current <code class="hljs">section</code> or <code class="hljs">namespace</code> is closed, or until the end
of the current file.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">structure</span> <span class="hljs-title">P</span><span class="hljs-title">o</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">t</span></span> <span class="hljs-keyword">where</span>
  x : Nat
  y : Nat

<span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-title">a</span><span class="hljs-title">d</span><span class="hljs-title">d</span><span class="hljs-title">P</span><span class="hljs-title">o</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">t</span> <span class="hljs-symbol">:</span></span> Add Point <span class="hljs-keyword">where</span>
  add a b := { x := a.x + b.x, y := a.y + b.y }

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span><span class="hljs-title">o</span><span class="hljs-title">u</span><span class="hljs-title">b</span><span class="hljs-title">l</span><span class="hljs-title">e</span> <span class="hljs-params">(p : Point)</span> <span class="hljs-symbol">:</span></span>=
  p + p

<span class="hljs-keyword">attribute</span> [-<span class="hljs-theorem"><span class="hljs-keyword">instance</span>] <span class="hljs-title">a</span><span class="hljs-title">d</span><span class="hljs-title">d</span><span class="hljs-title">P</span><span class="hljs-title">o</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">t</span>

-- <span class="hljs-title">d</span><span class="hljs-title">e</span><span class="hljs-title">f</span> <span class="hljs-title">t</span><span class="hljs-title">r</span><span class="hljs-title">i</span><span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">e</span> <span class="hljs-params">(p : Point)</span> <span class="hljs-symbol">:</span></span>=
<span class="hljs-comment">--  p + p + p  -- Error: failed to sythesize instance</span>
</code></pre>
<p>We recommend you only use this command to diagnose problems.</p>
<h2><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/type_classes.html#scoped-instances" id="scoped-instances">Scoped Instances</a></h2>
<p>You can also declare scoped instances in namespaces. This kind of instance is
only active when you are inside of the namespace or open the namespace.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">structure</span> <span class="hljs-title">P</span><span class="hljs-title">o</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">t</span></span> <span class="hljs-keyword">where</span>
  x : Nat
  y : Nat

<span class="hljs-keyword">namespace</span> Point

<span class="hljs-keyword">scoped</span> <span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> Add Point <span class="hljs-keyword">where</span>
  add a b := { x := a.x + b.x, y := a.y + b.y }

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span><span class="hljs-title">o</span><span class="hljs-title">u</span><span class="hljs-title">b</span><span class="hljs-title">l</span><span class="hljs-title">e</span> <span class="hljs-params">(p : Point)</span> <span class="hljs-symbol">:</span></span>=
  p + p

<span class="hljs-keyword">end</span> Point
<span class="hljs-comment">-- instance `Add Point` is not active anymore</span>

<span class="hljs-comment">-- #check fun (p : Point) =&gt; p + p + p  -- Error</span>

<span class="hljs-keyword">namespace</span> Point
<span class="hljs-comment">-- instance `Add Point` is active again</span>
<span class="hljs-keyword">#check</span> <span class="hljs-keyword">fun</span> (p : Point) =&gt; p + p + p

<span class="hljs-keyword">end</span> Point

<span class="hljs-keyword">open</span> Point <span class="hljs-comment">-- activates instance `Add Point`</span>
<span class="hljs-keyword">#check</span> <span class="hljs-keyword">fun</span> (p : Point) =&gt; p + p + p
</code></pre>
<p>You can use the command <code class="hljs">open scoped &lt;namespace&gt;</code> to activate scoped attributes but will
not "open" the names from the namespace.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">structure</span> <span class="hljs-title">P</span><span class="hljs-title">o</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">t</span></span> <span class="hljs-keyword">where</span>
  x : Nat
  y : Nat

<span class="hljs-keyword">namespace</span> Point

<span class="hljs-keyword">scoped</span> <span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> Add Point <span class="hljs-keyword">where</span>
  add a b := { x := a.x + b.x, y := a.y + b.y }

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span><span class="hljs-title">o</span><span class="hljs-title">u</span><span class="hljs-title">b</span><span class="hljs-title">l</span><span class="hljs-title">e</span> <span class="hljs-params">(p : Point)</span> <span class="hljs-symbol">:</span></span>=
  p + p

<span class="hljs-keyword">end</span> Point

<span class="hljs-keyword">open</span> <span class="hljs-keyword">scoped</span> Point <span class="hljs-comment">-- activates instance `Add Point`</span>
<span class="hljs-keyword">#check</span> <span class="hljs-keyword">fun</span> (p : Point) =&gt; p + p + p

<span class="hljs-comment">-- #check fun (p : Point) =&gt; double p -- Error: unknown identifier 'double'</span>
</code></pre>
<h2><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/type_classes.html#decidable-propositions" id="decidable-propositions">Decidable Propositions</a></h2>
<p>Let us consider another example of a type class defined in the
standard library, namely the type class of <code class="hljs">Decidable</code>
propositions. Roughly speaking, an element of <code class="hljs">Prop</code> is said to be
decidable if we can decide whether it is true or false. The
distinction is only useful in constructive mathematics; classically,
every proposition is decidable. But if we use the classical principle,
say, to define a function by cases, that function will not be
computable. Algorithmically speaking, the <code class="hljs">Decidable</code> type class can
be used to infer a procedure that effectively determines whether or
not the proposition is true. As a result, the type class supports such
computational definitions when they are possible while at the same
time allowing a smooth transition to the use of classical definitions
and classical reasoning.</p>
<p>In the standard library, <code class="hljs">Decidable</code> is defined formally as follows:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="숨겨진 선 보이기" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="boring"><span class="hljs-keyword">namespace</span> Hidden
</span><span class="hljs-theorem"><span class="hljs-keyword">class</span> <span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">d</span><span class="hljs-title">u</span><span class="hljs-title">c</span><span class="hljs-title">t</span><span class="hljs-title">i</span><span class="hljs-title">v</span><span class="hljs-title">e</span> <span class="hljs-title">D</span><span class="hljs-title">e</span><span class="hljs-title">c</span><span class="hljs-title">i</span><span class="hljs-title">d</span><span class="hljs-title">a</span><span class="hljs-title">b</span><span class="hljs-title">l</span><span class="hljs-title">e</span> <span class="hljs-params">(p : <span class="hljs-built_in">Prop</span>)</span></span> <span class="hljs-keyword">where</span>
  | isFalse (h : ¬p) : Decidable p
  | isTrue  (h : p)  : Decidable p
<span class="boring"><span class="hljs-keyword">end</span> Hidden
</span></code></pre>
<p>Logically speaking, having an element <code class="hljs">t : Decidable p</code> is stronger
than having an element <code class="hljs">t : p ∨ ¬p</code>; it enables us to define values
of an arbitrary type depending on the truth value of <code class="hljs">p</code>. For
example, for the expression <code class="hljs">if p then a else b</code> to make sense, we
need to know that <code class="hljs">p</code> is decidable. That expression is syntactic
sugar for <code class="hljs">ite p a b</code>, where <code class="hljs">ite</code> is defined as follows:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="숨겨진 선 보이기" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="boring"><span class="hljs-keyword">namespace</span> Hidden
</span><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">i</span><span class="hljs-title">t</span><span class="hljs-title">e</span> <span class="hljs-params">{α : <span class="hljs-built_in">Sort</span> u}</span> <span class="hljs-params">(c : <span class="hljs-built_in">Prop</span>)</span> <span class="hljs-params">[h : Decidable c]</span> <span class="hljs-params">(t e : α)</span> <span class="hljs-symbol">:</span></span> α :=
  Decidable.casesOn (motive := <span class="hljs-keyword">fun</span> _ =&gt; α) h (<span class="hljs-keyword">fun</span> _ =&gt; e) (<span class="hljs-keyword">fun</span> _ =&gt; t)
<span class="boring"><span class="hljs-keyword">end</span> Hidden
</span></code></pre>
<p>The standard library also contains a variant of <code class="hljs">ite</code> called
<code class="hljs">dite</code>, the dependent if-then-else expression. It is defined as
follows:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="숨겨진 선 보이기" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="boring"><span class="hljs-keyword">namespace</span> Hidden
</span><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span><span class="hljs-title">i</span><span class="hljs-title">t</span><span class="hljs-title">e</span> <span class="hljs-params">{α : <span class="hljs-built_in">Sort</span> u}</span> <span class="hljs-params">(c : <span class="hljs-built_in">Prop</span>)</span> <span class="hljs-params">[h : Decidable c]</span> <span class="hljs-params">(t : c → α)</span> <span class="hljs-params">(e : Not c → α)</span> <span class="hljs-symbol">:</span></span> α :=
  Decidable.casesOn (motive := <span class="hljs-keyword">fun</span> _ =&gt; α) h e t
<span class="boring"><span class="hljs-keyword">end</span> Hidden
</span></code></pre>
<p>That is, in <code class="hljs">dite c t e</code>, we can assume <code class="hljs">hc : c</code> in the "then"
branch, and <code class="hljs">hnc : ¬ c</code> in the "else" branch. To make <code class="hljs">dite</code> more
convenient to use, Lean allows us to write <code class="hljs">if h : c then t else e</code>
instead of <code class="hljs">dite c (λ h : c, t) (λ h : ¬ c, e)</code>.</p>
<p>Without classical logic, we cannot prove that every proposition is
decidable. But we can prove that <em>certain</em> propositions are
decidable. For example, we can prove the decidability of basic
operations like equality and comparisons on the natural numbers and
the integers. Moreover, decidability is preserved under propositional
connectives:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> @instDecidableAnd
  <span class="hljs-comment">-- {p q : Prop} → [Decidable p] → [Decidable q] → Decidable (And p q)</span>

<span class="hljs-keyword">#check</span> @instDecidableOr
<span class="hljs-keyword">#check</span> @instDecidableNot
<span class="hljs-keyword">#check</span> @instDecidableArrow
</code></pre>
<p>Thus we can carry out definitions by cases on decidable predicates on
the natural numbers:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">s</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">p</span> <span class="hljs-params">(a b x : Nat)</span> <span class="hljs-symbol">:</span></span> Nat :=
  <span class="hljs-keyword">if</span> x &lt; a ∨ x &gt; b <span class="hljs-keyword">then</span> <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">1</span>

<span class="hljs-keyword">set_option</span> pp.explicit <span class="hljs-literal">true</span>
<span class="hljs-keyword">#print</span> step
</code></pre>
<p>Turning on implicit arguments shows that the elaborator has inferred
the decidability of the proposition <code class="hljs">x &lt; a ∨ x &gt; b</code>, simply by
applying appropriate instances.</p>
<p>With the classical axioms, we can prove that every proposition is
decidable. You can import the classical axioms and make the generic
instance of decidability available by opening the <code class="hljs">Classical</code> namespace.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">open</span> Classical
</code></pre>
<p>Thereafter <code class="hljs">decidable p</code> has an instance for every <code class="hljs">p</code>.
Thus all theorems in the library
that rely on decidability assumptions are freely available when you
want to reason classically. In <a href="https://leanprover.github.io/theorem_proving_in_lean4/axioms_and_computation.html">Chapter Axioms and Computation</a>,
we will see that using the law of the
excluded middle to define functions can prevent them from being used
computationally. Thus, the standard library assigns a low priority to
the <code class="hljs">propDecidable</code> instance.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="숨겨진 선 보이기" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="boring"><span class="hljs-keyword">namespace</span> Hidden
</span><span class="hljs-keyword">open</span> Classical
<span class="hljs-keyword">noncomputable</span> <span class="hljs-keyword">scoped</span>
<span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-params">(priority := low)</span> <span class="hljs-title">p</span><span class="hljs-title">r</span><span class="hljs-title">o</span><span class="hljs-title">p</span><span class="hljs-title">D</span><span class="hljs-title">e</span><span class="hljs-title">c</span><span class="hljs-title">i</span><span class="hljs-title">d</span><span class="hljs-title">a</span><span class="hljs-title">b</span><span class="hljs-title">l</span><span class="hljs-title">e</span> <span class="hljs-params">(a : <span class="hljs-built_in">Prop</span>)</span> <span class="hljs-symbol">:</span></span> Decidable a :=
  choice &lt;| <span class="hljs-keyword">match</span> em a <span class="hljs-keyword">with</span>
    | Or.inl h =&gt; ⟨isTrue h⟩
    | Or.inr h =&gt; ⟨isFalse h⟩
<span class="boring"><span class="hljs-keyword">end</span> Hidden
</span></code></pre>
<p>The guarantees that Lean will favor other instances and fall back on
<code class="hljs">propDecidable</code> only after other attempts to infer decidability have
failed.</p>
<p>The <code class="hljs">Decidable</code> type class also provides a bit of small-scale
automation for proving theorems. The standard library introduces the
tactic <code class="hljs">decide</code> that uses the <code class="hljs">Decidable</code> instance to solve simple goals.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> : <span class="hljs-number">10</span> &lt; <span class="hljs-number">5</span> ∨ <span class="hljs-number">1</span> &gt; <span class="hljs-number">0</span> := <span class="hljs-keyword">by</span>
  decide

<span class="hljs-keyword">example</span> : ¬ (True ∧ False) := <span class="hljs-keyword">by</span>
  decide

<span class="hljs-keyword">example</span> : <span class="hljs-number">10</span> * <span class="hljs-number">20</span> = <span class="hljs-number">200</span> := <span class="hljs-keyword">by</span>
  decide

<span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">e</span><span class="hljs-title">x</span> <span class="hljs-symbol">:</span></span> True ∧ <span class="hljs-number">2</span> = <span class="hljs-number">1</span>+<span class="hljs-number">1</span> := <span class="hljs-keyword">by</span>
  decide

<span class="hljs-keyword">#print</span> ex
<span class="hljs-comment">-- theorem ex : True ∧ 2 = 1 + 1 :=</span>
<span class="hljs-comment">-- of_decide_eq_true (Eq.refl true)</span>

<span class="hljs-keyword">#check</span> @of_decide_eq_true
<span class="hljs-comment">-- ∀ {p : Prop} [Decidable p], decide p = true → p</span>

<span class="hljs-keyword">#check</span> @decide
<span class="hljs-comment">-- (p : Prop) → [Decidable p] → Bool</span>
</code></pre>
<p>They work as follows. The expression <code class="hljs">decide p</code> tries to infer a
decision procedure for <code class="hljs">p</code>, and, if it is successful, evaluates to
either <code class="hljs">true</code> or <code class="hljs">false</code>. In particular, if <code class="hljs">p</code> is a true closed
expression, <code class="hljs">decide p</code> will reduce definitionally to the Boolean <code class="hljs">true</code>.
On the assumption that <code class="hljs">decide p = true</code> holds, <code class="hljs">of_decide_eq_true</code>
produces a proof of <code class="hljs">p</code>. The tactic <code class="hljs">decide</code> puts it all together: to
prove a target <code class="hljs">p</code>. By the previous observations,
<code class="hljs">decide</code> will succeed any time the inferred decision procedure
for <code class="hljs">c</code> has enough information to evaluate, definitionally, to the <code class="hljs">isTrue</code> case.</p>
<h2><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/type_classes.html#managing-type-class-inference" id="managing-type-class-inference">Managing Type Class Inference</a></h2>
<p>If you are ever in a situation where you need to supply an expression
that Lean can infer by type class inference, you can ask Lean to carry
out the inference using <code class="hljs">inferInstance</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-title">o</span><span class="hljs-title">o</span> <span class="hljs-symbol">:</span></span> Add Nat := inferInstance
<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">b</span><span class="hljs-title">a</span><span class="hljs-title">r</span> <span class="hljs-symbol">:</span></span> Inhabited (Nat → Nat) := inferInstance

<span class="hljs-keyword">#check</span> @inferInstance
<span class="hljs-comment">-- {α : Sort u} → [α] → α</span>
</code></pre>
<p>In fact, you can use Lean's <code class="hljs">(t : T)</code> notation to specify the class whose instance you are looking for,
in a concise manner:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> (inferInstance : Add Nat)
</code></pre>
<p>You can also use the auxiliary definition <code class="hljs">inferInstanceAs</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> inferInstanceAs (Add Nat)

<span class="hljs-keyword">#check</span> @inferInstanceAs
<span class="hljs-comment">-- (α : Sort u) → [α] → α</span>
</code></pre>
<p>Sometimes Lean can't find an instance because the class is buried
under a definition. For example, Lean cannot
find an instance of <code class="hljs">Inhabited (Set α)</code>. We can declare one
explicitly:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">
<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">S</span><span class="hljs-title">e</span><span class="hljs-title">t</span> <span class="hljs-params">(α : <span class="hljs-built_in">Type</span> u)</span> <span class="hljs-symbol">:</span></span>= α → <span class="hljs-built_in">Prop</span>

<span class="hljs-comment">-- fails</span>
<span class="hljs-comment">-- example : Inhabited (Set α) :=</span>
<span class="hljs-comment">--  inferInstance</span>

<span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> Inhabited (Set α) :=
  inferInstanceAs (Inhabited (α → <span class="hljs-built_in">Prop</span>))
</code></pre>
<p>At times, you may find that the type class inference fails to find an
expected instance, or, worse, falls into an infinite loop and times
out. To help debug in these situations, Lean enables you to request a
trace of the search:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="hljs">set_option trace.Meta.synthInstance true
</code></pre>
<p>If you are using VS Code, you can read the results by hovering over
the relevant theorem or definition, or opening the messages window
with <code class="hljs">Ctrl-Shift-Enter</code>. In Emacs, you can use <code class="hljs">C-c C-x</code> to run an
independent Lean process on your file, and the output buffer will show
a trace every time the type class resolution procedure is subsequently
triggered.</p>
<p>You can also limit the search using the following options:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="hljs">set_option synthInstance.maxHeartbeats 10000
set_option synthInstance.maxSize 400
</code></pre>
<p>Option <code class="hljs">synthInstance.maxHeartbeats</code> specifies the maximum amount of
heartbeats per typeclass resolution problem. A heartbeat is number of
(small) memory allocations (in thousands), 0 means there is no limit.
Option <code class="hljs">synthInstance.maxSize</code> is the maximum number of instances used
to construct a solution in the type class instance synthesis procedure</p>
<p>Remember also that in both the VS Code and Emacs editor modes, tab
completion works in <code class="hljs">set_option</code>, to help you find suitable options.</p>
<p>As noted above, the type class instances in a given context represent
a Prolog-like program, which gives rise to a backtracking search. Both
the efficiency of the program and the solutions that are found can
depend on the order in which the system tries the instance. Instances
which are declared last are tried first. Moreover, if instances are
declared in other modules, the order in which they are tried depends
on the order in which namespaces are opened. Instances declared in
namespaces which are opened later are tried earlier.</p>
<p>You can change the order that type classes instances are tried by
assigning them a <em>priority</em>. When an instance is declared, it is
assigned a default priority value. You can assign other priorities
when defining an instance. The following example illustrates how this
is done:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">class</span> <span class="hljs-title">F</span><span class="hljs-title">o</span><span class="hljs-title">o</span></span> <span class="hljs-keyword">where</span>
  a : Nat
  b : Nat

<span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-params">(priority := default+1)</span> <span class="hljs-title">i1</span> <span class="hljs-symbol">:</span></span> Foo <span class="hljs-keyword">where</span>
  a := <span class="hljs-number">1</span>
  b := <span class="hljs-number">1</span>

<span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-title">i2</span> <span class="hljs-symbol">:</span></span> Foo <span class="hljs-keyword">where</span>
  a := <span class="hljs-number">2</span>
  b := <span class="hljs-number">2</span>

<span class="hljs-keyword">example</span> : Foo.a = <span class="hljs-number">1</span> :=
  <span class="hljs-built_in">rfl</span>

<span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-params">(priority := default+2)</span> <span class="hljs-title">i3</span> <span class="hljs-symbol">:</span></span> Foo <span class="hljs-keyword">where</span>
  a := <span class="hljs-number">3</span>
  b := <span class="hljs-number">3</span>

<span class="hljs-keyword">example</span> : Foo.a = <span class="hljs-number">3</span> :=
  <span class="hljs-built_in">rfl</span>
</code></pre>
<!--
TODO: we may change the coercion mechanism
.. _coercions_using_type_classes:

Coercions using Type Classes
----------------------------

The most basic type of coercion maps elements of one type to another. For example, a coercion from ``nat`` to ``int`` allows us to view any element ``n : nat`` as an element of ``int``. But some coercions depend on parameters; for example, for any type ``α``, we can view any element ``l : list α`` as an element of ``set α``, namely, the set of elements occurring in the list. The corresponding coercion is defined on the "family" of types ``list α``, parameterized by ``α``.

Lean allows us to declare three kinds of coercions:

-  from a family of types to another family of types
-  from a family of types to the class of sorts
-  from a family of types to the class of function types

The first kind of coercion allows us to view any element of a member of the source family as an element of a corresponding member of the target family. The second kind of coercion allows us to view any element of a member of the source family as a type. The third kind of coercion allows us to view any element of the source family as a function. Let us consider each of these in turn.

In Lean, coercions are implemented on top of the type class resolution framework. We define a coercion from ``α`` to ``β`` by declaring an instance of ``has_coe α β``. For example, we can define a coercion from ``bool`` to ``Prop`` as follows:

.. code-block:: lean

    instance bool_to_Prop : has_coe bool Prop :=
    ⟨λ b, b = tt⟩

This enables us to use boolean terms in if-then-else expressions:

.. code-block:: lean

    instance bool_to_Prop : has_coe bool Prop :=
    ⟨λ b, b = tt⟩
    -- BEGIN
    #reduce if tt then 3 else 5
    #reduce if ff then 3 else 5
    -- END

We can define a coercion from ``list α`` to ``set α`` as follows:

.. code-block:: lean

    def list.to_set {α : Type*} : list α → set α
    | []     := ∅
    | (h::t) := {h} ∪ list.to_set t

    instance list_to_set_coe (α : Type*) :
      has_coe (list α) (set α) :=
    ⟨list.to_set⟩

    def s : set nat  := {1, 2}
    def l : list nat := [3, 4]

    #check s ∪ l -- set nat

Coercions are only considered if the given and expected types do not contain metavariables at elaboration time. In the following example, when we elaborate the union operator, the type of ``[3, 2]`` is ``list ?m``, and a coercion will not be considered since it contains metavariables.

.. code-block:: lean

    def list.to_set {α : Type*} : list α → set α
    | []     := ∅
    | (h::t) := {h} ∪ list.to_set t

    instance list_to_set_coe (α : Type*) :
      has_coe (list α) (set α) :=
    ⟨list.to_set⟩

    def s : set nat  := {1, 2}

    -- BEGIN
    /- The following #check command produces an error. -/
    -- #check s ∪ [3, 2]
    -- END

We can work around this issue by using a type ascription.

.. code-block:: lean

    def list.to_set {α : Type*} : list α → set α
    | []     := ∅
    | (h::t) := {h} ∪ list.to_set t

    instance list_to_set_coe (α : Type*) :
      has_coe (list α) (set α) :=
    ⟨list.to_set⟩

    def s : set nat  := {1, 2}

    -- BEGIN
    #check s ∪ [(3:nat), 2]
    -- or
    #check s ∪ ([3, 2] : list nat)
    -- END

In the examples above, you may have noticed the symbol ``↑`` produced by the ``#check`` commands. It is the lift operator, ``↑t`` is notation for ``coe t``. We can use this operator to force a coercion to be introduced in a particular place. It is also helpful to make our intent clear, and work around limitations of the coercion resolution system.

.. code-block:: lean

    def list.to_set {α : Type*} : list α → set α
    | []     := ∅
    | (h::t) := {h} ∪ list.to_set t

    instance list_to_set_coe (α : Type*) :
      has_coe (list α) (set α) :=
    ⟨list.to_set⟩

    def s : set nat  := {1, 2}

    -- BEGIN
    #check s ∪ ↑[3, 2]

    variables n m : nat
    variable i : int
    #check i + ↑n + ↑m
    #check i + ↑(n + m)
    #check ↑n + i
    -- END

In the first two examples, the coercions are not strictly necessary since Lean will insert implicit nat → int coercions. However, ``#check n + i`` would raise an error, because the expected type of ``i`` is nat in order to match the type of n, and no int → nat coercion exists). In the third example, we therefore insert an explicit ``↑`` to coerce ``n`` to ``int``.

The standard library defines a coercion from subtype ``{x : α // p x}`` to ``α`` as follows:

.. code-block:: lean

    namespace hidden
    -- BEGIN
    instance coe_subtype {α : Type*} {p : α → Prop} :
      has_coe {x // p x} α :=
    ⟨λ s, subtype.val s⟩
    -- END
    end hidden

Lean will also chain coercions as necessary. Actually, the type class ``has_coe_t`` is the transitive closure of ``has_coe``. You may have noticed that the type of ``coe`` depends on ``has_lift_t``, the transitive closure of the type class ``has_lift``, instead of ``has_coe_t``. Every instance of ``has_coe_t`` is also an instance of ``has_lift_t``, but the elaborator only introduces automatically instances of ``has_coe_t``. That is, to be able to coerce using an instance of ``has_lift_t``, we must use the operator ``↑``. In the standard library, we have the following instance:

.. code-block:: lean

    namespace hidden
    universes u v

    instance lift_list {a : Type u} {b : Type v} [has_lift_t a b] :
      has_lift (list a) (list b) :=
    ⟨λ l, list.map (@coe a b _) l⟩

    variables s : list nat
    variables r : list int
    #check ↑s ++ r

    end hidden

It is not an instance of ``has_coe`` because lists are frequently used for writing programs, and we do not want a linear-time operation to be silently introduced by Lean, and potentially mask mistakes performed by the user. By forcing the user to write ``↑``, she is making her intent clear to Lean.

Let us now consider the second kind of coercion. By the *class of sorts*, we mean the collection of universes ``Type u``. A coercion of the second kind is of the form

.. code-block:: text

    c : Π x1 : A1, ..., xn : An, F x1 ... xn → Type u

where ``F`` is a family of types as above. This allows us to write ``s : t`` whenever ``t`` is of type ``F a1 ... an``. In other words, the coercion allows us to view the elements of ``F a1 ... an`` as types. This is very useful when defining algebraic structures in which one component, the carrier of the structure, is a ``Type``. For example, we can define a semigroup as follows:

.. code-block:: lean

    universe u

    structure Semigroup : Type (u+1) :=
    (carrier : Type u)
    (mul : carrier → carrier → carrier)
    (mul_assoc : ∀ a b c : carrier,
                   mul (mul a b) c = mul a (mul b c))

    instance Semigroup_has_mul (S : Semigroup) :
      has_mul (S.carrier) :=
    ⟨S.mul⟩

In other words, a semigroup consists of a type, ``carrier``, and a multiplication, ``mul``, with the property that the multiplication is associative. The ``instance`` command allows us to write ``a * b`` instead of ``Semigroup.mul S a b`` whenever we have ``a b : S.carrier``; notice that Lean can infer the argument ``S`` from the types of ``a`` and ``b``. The function ``Semigroup.carrier`` maps the class ``Semigroup`` to the sort ``Type u``:

.. code-block:: lean

    universe u

    structure Semigroup : Type (u+1) :=
    (carrier : Type u)
    (mul : carrier → carrier → carrier)
    (mul_assoc : ∀ a b c : carrier,
                   mul (mul a b) c = mul a (mul b c))

    instance Semigroup_has_mul (S : Semigroup) : has_mul (S.carrier) :=
    ⟨S.mul⟩
    -- BEGIN
    #check Semigroup.carrier
    -- END

If we declare this function to be a coercion, then whenever we have a semigroup ``S : Semigroup``, we can write ``a : S`` instead of ``a : S.carrier``:

.. code-block:: lean

    universe u

    structure Semigroup : Type (u+1) :=
    (carrier : Type u)
    (mul : carrier → carrier → carrier)
    (mul_assoc : ∀ a b c : carrier, mul (mul a b) c = mul a (mul b c))

    instance Semigroup_has_mul (S : Semigroup) : has_mul (S.carrier) :=
    ⟨S.mul⟩

    -- BEGIN
    instance Semigroup_to_sort : has_coe_to_sort Semigroup :=
    {S := Type u, coe := λ S, S.carrier}

    example (S : Semigroup) (a b c : S) :
      (a * b) * c = a * (b * c) :=
    Semigroup.mul_assoc _ a b c
    -- END

It is the coercion that makes it possible to write ``(a b c : S)``. Note that, we define an instance of ``has_coe_to_sort Semigroup`` instead of ``has_coe Semigroup Type``. The reason is that when Lean needs a coercion to sort, it only knows it needs a type, but, in general, the universe is not known. The field ``S`` in the class ``has_coe_to_sort`` is used to specify the universe we are coercing too.

By the *class of function types*, we mean the collection of Pi types ``Π z : B, C``. The third kind of coercion has the form

.. code-block:: text

    c : Π x1 : A1, ..., xn : An, y : F x1 ... xn, Π z : B, C

where ``F`` is again a family of types and ``B`` and ``C`` can depend on ``x1, ..., xn, y``. This makes it possible to write ``t s`` whenever ``t`` is an element of ``F a1 ... an``. In other words, the coercion enables us to view elements of ``F a1 ... an`` as functions. Continuing the example above, we can define the notion of a morphism between semigroups ``S1`` and ``S2``. That is, a function from the carrier of ``S1`` to the carrier of ``S2`` (note the implicit coercion) that respects the multiplication. The projection ``morphism.mor`` takes a morphism to the underlying function:

.. code-block:: lean

    universe u

    structure Semigroup : Type (u+1) :=
    (carrier : Type u)
    (mul : carrier → carrier → carrier)
    (mul_assoc : ∀ a b c : carrier, mul (mul a b) c = mul a (mul b c))

    instance Semigroup_has_mul (S : Semigroup) : has_mul (S.carrier) :=
    ⟨S.mul⟩

    -- BEGIN
    instance Semigroup_to_sort : has_coe_to_sort Semigroup :=
    {S := _, coe := λ S, S.carrier}

    structure morphism (S1 S2 : Semigroup) :=
    (mor : S1 → S2)
    (resp_mul : ∀ a b : S1, mor (a * b) = (mor a) * (mor b))

    #check @morphism.mor
    -- END

As a result, it is a prime candidate for the third type of coercion.

.. code-block:: lean

    universe u

    structure Semigroup : Type (u+1) :=
    (carrier : Type u)
    (mul : carrier → carrier → carrier)
    (mul_assoc : ∀ a b c : carrier, mul (mul a b) c = mul a (mul b c))

    instance Semigroup_has_mul (S : Semigroup) : has_mul (S.carrier) :=
    ⟨S.mul⟩


    instance Semigroup_to_sort : has_coe_to_sort Semigroup :=
    {S := _, coe := λ S, S.carrier}

    structure morphism (S1 S2 : Semigroup) :=
    (mor : S1 → S2)
    (resp_mul : ∀ a b : S1, mor (a * b) = (mor a) * (mor b))

    -- BEGIN
    instance morphism_to_fun (S1 S2 : Semigroup) :
      has_coe_to_fun (morphism S1 S2) :=
    { F   := λ _, S1 → S2,
      coe := λ m, m.mor }

    lemma resp_mul {S1 S2 : Semigroup}
        (f : morphism S1 S2) (a b : S1) :
      f (a * b) = f a * f b :=
    f.resp_mul a b

    example (S1 S2 : Semigroup) (f : morphism S1 S2) (a : S1) :
      f (a * a * a) = f a * f a * f a :=
    calc
      f (a * a * a) = f (a * a) * f a : by rw [resp_mul f]
                ... = f a * f a * f a : by rw [resp_mul f]
    -- END

With the coercion in place, we can write ``f (a * a * a)`` instead of ``morphism.mor f (a * a * a)``. When the ``morphism``, ``f``, is used where a function is expected, Lean inserts the coercion. Similar to ``has_coe_to_sort``, we have yet another class ``has_coe_to_fun`` for this class of coercions. The field ``F`` is used to specify the function type we are coercing to. This type may depend on the type we are coercing from.

Finally, ``⇑f`` and ``↥S`` are notations for ``coe_fn f`` and ``coe_sort S``. They are the coercion operators for the function and sort classes.

We can instruct Lean's pretty-printer to hide the operators ``↑`` and ``⇑`` with ``set_option``.

.. code-block:: lean

    universe u

    structure Semigroup : Type (u+1) :=
    (carrier : Type u)
    (mul : carrier → carrier → carrier)
    (mul_assoc : ∀ a b c : carrier, mul (mul a b) c = mul a (mul b c))

    instance Semigroup_has_mul (S : Semigroup) : has_mul (S.carrier) :=
    ⟨S.mul⟩

    instance Semigroup_to_sort : has_coe_to_sort Semigroup :=
    {S := _, coe := λ S, S.carrier}

    structure morphism (S1 S2 : Semigroup) :=
    (mor : S1 → S2)
    (resp_mul : ∀ a b : S1, mor (a * b) = (mor a) * (mor b))

    instance morphism_to_fun (S1 S2 : Semigroup) : has_coe_to_fun (morphism S1 S2) :=
    { F   := λ _, S1 → S2,
      coe := λ m, m.mor }

    lemma resp_mul {S1 S2 : Semigroup} (f : morphism S1 S2) (a b : S1) : f (a * b) = f a * f b :=
    f.resp_mul a b

    -- BEGIN
    theorem test (S1 S2 : Semigroup)
        (f : morphism S1 S2) (a : S1) :
      f (a * a * a) = f a * f a * f a :=
    calc
      f (a * a * a) = f (a * a) * f a : by rw [resp_mul f]
                ... = f a * f a * f a : by rw [resp_mul f]

    #check @test
    set_option pp.coercions false
    #check @test
    -- END
-->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="https://leanprover.github.io/theorem_proving_in_lean4/structures_and_records.html" class="mobile-nav-chapters previous" title="이전 장" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="https://leanprover.github.io/theorem_proving_in_lean4/conv.html" class="mobile-nav-chapters next" title="다음 장" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="https://leanprover.github.io/theorem_proving_in_lean4/structures_and_records.html" class="nav-chapters previous" title="이전 장" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="https://leanprover.github.io/theorem_proving_in_lean4/conv.html" class="nav-chapters next" title="다음 장" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="./Type Classes - Theorem Proving in Lean 4_files/elasticlunr.min.js.다운로드" type="text/javascript" charset="utf-8"></script>
        <script src="./Type Classes - Theorem Proving in Lean 4_files/mark.min.js.다운로드" type="text/javascript" charset="utf-8"></script>
        <script src="./Type Classes - Theorem Proving in Lean 4_files/searcher.js.다운로드" type="text/javascript" charset="utf-8"></script>
        

        <script src="./Type Classes - Theorem Proving in Lean 4_files/clipboard.min.js.다운로드" type="text/javascript" charset="utf-8"></script>
        <script src="./Type Classes - Theorem Proving in Lean 4_files/highlight.js.다운로드" type="text/javascript" charset="utf-8"></script>
        <script src="./Type Classes - Theorem Proving in Lean 4_files/book.js.다운로드" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    

</body></html>