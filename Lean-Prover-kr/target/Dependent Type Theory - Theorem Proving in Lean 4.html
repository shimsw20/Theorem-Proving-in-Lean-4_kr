<!DOCTYPE html>
<!-- saved from url=(0080)https://leanprover.github.io/theorem_proving_in_lean4/dependent_type_theory.html -->
<html lang="en" class="js sidebar-visible light"><head><meta http-equiv="content-type" content="text/html; charset=UTF-8">
        <!-- Book generated using mdBook -->
        
        <title>의존 유형론 - 린4로 하는 정리 증명</title>
        
        


        <!-- Custom HTML head -->
        


        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="rgba(0, 0, 0, 0)">

        
        <link rel="icon" href="https://leanprover.github.io/theorem_proving_in_lean4/favicon.svg">
        
        
        <link rel="shortcut icon" href="https://leanprover.github.io/theorem_proving_in_lean4/favicon.png">
        
        <link rel="stylesheet" href="./Dependent Type Theory - Theorem Proving in Lean 4_files/variables.css">
        <link rel="stylesheet" href="./Dependent Type Theory - Theorem Proving in Lean 4_files/general.css">
        <link rel="stylesheet" href="./Dependent Type Theory - Theorem Proving in Lean 4_files/chrome.css">
        
        <link rel="stylesheet" href="./Dependent Type Theory - Theorem Proving in Lean 4_files/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="./Dependent Type Theory - Theorem Proving in Lean 4_files/font-awesome.css">
        
        <link rel="stylesheet" href="./Dependent Type Theory - Theorem Proving in Lean 4_files/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="./Dependent Type Theory - Theorem Proving in Lean 4_files/highlight.css">
        <link rel="stylesheet" href="./Dependent Type Theory - Theorem Proving in Lean 4_files/tomorrow-night.css" disabled="">
        <link rel="stylesheet" href="./Dependent Type Theory - Theorem Proving in Lean 4_files/ayu-highlight.css" disabled="">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents" aria-hidden="false">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="https://leanprover.github.io/theorem_proving_in_lean4/title_page.html" tabindex="0">린 4로 하는 정리 증명</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/introduction.html" tabindex="0"><strong aria-hidden="true">1.</strong> 소개(Introduction)</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/dependent_type_theory.html" class="active" tabindex="0"><strong aria-hidden="true">2.</strong> 의존 유형론(Dependent Type Theory)</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/propositions_and_proofs.html" tabindex="0"><strong aria-hidden="true">3.</strong> 명제와 증명(Propositions and Proofs)</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html" tabindex="0"><strong aria-hidden="true">4.</strong> 한정기호와 동등성(Quantifiers and Equality)</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/tactics.html" tabindex="0"><strong aria-hidden="true">5.</strong> 전략(Tactics)</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/interacting_with_lean.html" tabindex="0"><strong aria-hidden="true">6.</strong> 린과 상호작용하기(Interacting with Lean)</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/inductive_types.html" tabindex="0"><strong aria-hidden="true">7.</strong> 귀납형(Inductive Types)</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html" tabindex="0"><strong aria-hidden="true">8.</strong> 귀납과 재귀(Induction and Recursion)</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/structures_and_records.html" tabindex="0"><strong aria-hidden="true">9.</strong> 구조체와 레코드(Structures and Records)</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/type_classes.html" tabindex="0"><strong aria-hidden="true">10.</strong> 유형 계층(Type Classes)</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/conv.html" tabindex="0"><strong aria-hidden="true">11.</strong> 전략 모드로 전환(The Conversion Tactic Mode)</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/axioms_and_computation.html" tabindex="0"><strong aria-hidden="true">12.</strong> 공리계와 계산(Axioms and Computation)</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar" style="top: 0px;">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="목차 토글" aria-label="Toggle Table of Contents" aria-controls="sidebar" aria-expanded="true">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="테마 바꾸기" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">밝게(기본)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">녹슨 색</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">검은색</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">짙푸른색</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">짙은 검은색</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="탐색. (단축기: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">린 4로 하는 정리 증명</h1>

                    <div class="right-buttons">
                        
                        <a href="https://leanprover.github.io/theorem_proving_in_lean4/print.html" title="책 인쇄하기" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/leanprover/theorem_proving_in_lean4" title="깃 저장소" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" placeholder="이 책을 찾아보기 ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/dependent_type_theory.html#dependent-type-theory" id="dependent-type-theory">의존 유형론</a></h1>
<p>의존 유형론은 여러분이 복잡한 수학적 진술을 표현할 수 있게 하고, 복잡한 하드웨어와 소프트웨어 명제를 작성할 수 있게 하며 이 둘에 대해 자연스럽고 일관성있게 추론할 수 있게 하는 강력하고 표현력 있는 언어입니다. 린은  <em>직관주의 계산법</em>이라고 하는 가산적인 비축적적 세계(Universe)와 유도형이 있는 의존 유형론 버전을 기반합니다. 2장의 끝에서 여러분은 이것의 의미하는 바의 대부분을 이해하게 될 겁니다.</p>
<h2><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/dependent_type_theory.html#simple-type-theory" id="simple-type-theory">단순 유형론(Simple Type Theory)</a></h2>
<p>'유형론'은 그것의 이름을 모든 표현은 연관된 <em>유형</em>을 가지고 있다는 사실로부터 갖게 되었습니다. 예를들어 어떤 맥락에서 <code class="hljs">x + 0</code>은 자연수를 가리키고  <code class="hljs">f</code>은 자연수에 대한 함수를 지칭합니다. 엄밀한 정의를 좋아하는 이들에게 린의 자연수는 부호없는 임의 정밀도의 정수입니다.</p>
<p>린에서 여러분이 객체를 어떻게 선언하고 그들의 유형을 확인할 수 있는지 몇 가지 예제가 있습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-comment">/- 몇 가지 상수를 정의합니다. -/</span>

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span> <span class="hljs-symbol">:</span></span> Nat := <span class="hljs-number">1</span>       <span class="hljs-comment">-- m is a natural number</span>
<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">n</span> <span class="hljs-symbol">:</span></span> Nat := <span class="hljs-number">0</span>
<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">b1</span> <span class="hljs-symbol">:</span></span> Bool := <span class="hljs-literal">true</span>  <span class="hljs-comment">-- b1 is a Boolean</span>
<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">b2</span> <span class="hljs-symbol">:</span></span> Bool := <span class="hljs-literal">false</span>

<span class="hljs-comment">/- 그들의 유형을 확인합니다. -/</span>

<span class="hljs-keyword">#check</span> m            <span class="hljs-comment">-- output: Nat</span>
<span class="hljs-keyword">#check</span> n
<span class="hljs-keyword">#check</span> n + <span class="hljs-number">0</span>        <span class="hljs-comment">-- Nat</span>
<span class="hljs-keyword">#check</span> m * (n + <span class="hljs-number">0</span>)  <span class="hljs-comment">-- Nat</span>
<span class="hljs-keyword">#check</span> b1           <span class="hljs-comment">-- Bool</span>
<span class="hljs-keyword">#check</span> b1 &amp;&amp; b2     <span class="hljs-comment">-- "&amp;&amp;" is the Boolean and</span>
<span class="hljs-keyword">#check</span> b1 || b2     <span class="hljs-comment">-- Boolean or</span>
<span class="hljs-keyword">#check</span> <span class="hljs-literal">true</span>         <span class="hljs-comment">-- Boolean "true"</span>

<span class="hljs-comment">/- Evaluate -/</span>

<span class="hljs-keyword">#eval</span> <span class="hljs-number">5</span> * <span class="hljs-number">4</span>         <span class="hljs-comment">-- 20</span>
<span class="hljs-keyword">#eval</span> m + <span class="hljs-number">2</span>         <span class="hljs-comment">-- 3</span>
<span class="hljs-keyword">#eval</span> b1 &amp;&amp; b2      <span class="hljs-comment">-- false</span>
</code></pre>
<p> <code class="hljs">/-</code>과 <code class="hljs">-/</code> 사이의 모든 글은 린에게 무시하라고 가리키는 주석을 만듭니다. 마찬가지로 두 개의 대시 <code class="hljs">--</code>는 이 줄의 나머지는 주석을 포함함을 나타내고 이 또한 무시됩니다. 주석 블록은 중첩될 수 있으며 대부분의 프로그래밍 언어처럼 코드 조각을 "주석 처리"할 수 있게 합니다.</p>
<p><code class="hljs">def</code>는 작업 환경에 새로운 상수기호를 선언합니다. 위 예제에서 <code class="hljs">def m : Nat := 1</code>는 <code class="hljs">1</code>을 값으로 갖는 새로운 상수 <code class="hljs">m</code>을 <code class="hljs">Nat</code>유형으로 정의합니다. <code class="hljs">#check</code> 명령은 린에게 그것의 유형을 보고하도록 요청합니다. 린에서 시스템에게 정보를 불러오는 보조 명령은 주로 해시(#) 기호로 시작합니다. <code class="hljs">#eval</code> 명령은 린에게 제시된 표현의 값을 평가하도록 요청합니다. 여러분은 스스로 몇몇 상수를 선언하고 몇 가지 식의 유형을 확인해보길 바랍니다. 이처럼 새로운 대상을 선언하는 것은 시스템을 실험해보는 좋은 방식입니다.</p>
<p>단순 유형론을 강력하게 만드는 것은 기본형 외의 여러분만의 새로운 유형을 만들 수 있다는 점입니다. 예를 들어 <code class="hljs">a</code>와 <code class="hljs">b</code>가 유형이라면 <code class="hljs">a -&gt; b</code>는 <code class="hljs">a</code> 에서 <code class="hljs">b</code>로 가는 함수 유형을 나타냅니다. 그리고 <code class="hljs">a × b</code> 는 <code class="hljs">a</code>의 원소와 <code class="hljs">b</code>의 원소로 이뤄진 쌍을 원소로 갖는 유형을 나타냅니다. 이것을 <em>카테시안 곱</em>이라 합니다. <code class="hljs">×</code>은 유니코드 기호임을 보세요. 분별있는 유니코드의 사용은 가독성을 개선합니다. 그리고 현대의 모든 편집기는 그것의 사용을 지원합니다. 린의 표준 라이브러리에서 여러분은 유형을 나타내는데 그리스 문자를 자주 보게 됩니다. 그리고 유니코드 기호 <code class="hljs">→</code> 은 <code class="hljs">-&gt;</code>보다 더 간결한 버전입니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> Nat → Nat      <span class="hljs-comment">-- 화살표를 쓰기 위해서 "\to"나 "\r"를 치세요.</span>
<span class="hljs-keyword">#check</span> Nat -&gt; Nat     <span class="hljs-comment">--  ASCII 표기의 대체표현입니다.</span>

<span class="hljs-keyword">#check</span> Nat × Nat      <span class="hljs-comment">-- 곱하기를 쓰기 위해 "\times"를 치세요.</span>
<span class="hljs-keyword">#check</span> Prod Nat Nat   <span class="hljs-comment">-- 대체 표현입니다.</span>

<span class="hljs-keyword">#check</span> Nat → Nat → Nat
<span class="hljs-keyword">#check</span> Nat → (Nat → Nat)  <span class="hljs-comment">--  위와 같은 유형입니다.</span>

<span class="hljs-keyword">#check</span> Nat × Nat → Nat
<span class="hljs-keyword">#check</span> (Nat → Nat) → Nat <span class="hljs-comment">-- "범함수"</span>

<span class="hljs-keyword">#check</span> Nat.succ     <span class="hljs-comment">-- Nat → Nat</span>
<span class="hljs-keyword">#check</span> (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)       <span class="hljs-comment">-- Nat × Nat</span>
<span class="hljs-keyword">#check</span> Nat.add      <span class="hljs-comment">-- Nat → Nat → Nat</span>

<span class="hljs-keyword">#check</span> Nat.succ <span class="hljs-number">2</span>   <span class="hljs-comment">-- Nat</span>
<span class="hljs-keyword">#check</span> Nat.add <span class="hljs-number">3</span>    <span class="hljs-comment">-- Nat → Nat</span>
<span class="hljs-keyword">#check</span> Nat.add <span class="hljs-number">5</span> <span class="hljs-number">2</span>  <span class="hljs-comment">-- Nat</span>
<span class="hljs-keyword">#check</span> (<span class="hljs-number">5</span>, <span class="hljs-number">9</span>).<span class="hljs-number">1</span>     <span class="hljs-comment">-- Nat</span>
<span class="hljs-keyword">#check</span> (<span class="hljs-number">5</span>, <span class="hljs-number">9</span>).<span class="hljs-number">2</span>     <span class="hljs-comment">-- Nat</span>

<span class="hljs-keyword">#eval</span> Nat.succ <span class="hljs-number">2</span>   <span class="hljs-comment">-- 3</span>
<span class="hljs-keyword">#eval</span> Nat.add <span class="hljs-number">5</span> <span class="hljs-number">2</span>  <span class="hljs-comment">-- 7</span>
<span class="hljs-keyword">#eval</span> (<span class="hljs-number">5</span>, <span class="hljs-number">9</span>).<span class="hljs-number">1</span>     <span class="hljs-comment">-- 5</span>
<span class="hljs-keyword">#eval</span> (<span class="hljs-number">5</span>, <span class="hljs-number">9</span>).<span class="hljs-number">2</span>     <span class="hljs-comment">-- 9</span>
</code></pre>
<p>다시 한번 여러분 스스로 몇 가지 예제를 시도해보기 바랍니다.</p>
<p>몇 가지 기본 문법에 대해 살펴봅시다. 여러분은 유니코드 화살표 <code class="hljs">→</code>를 <code class="hljs">\to</code>을 치거나 or <code class="hljs">\r</code>또는 <code class="hljs">\-&gt;</code>으로 입력할 수 있습니다. 여러분은 ASCII 대체 표현으로 <code class="hljs">-&gt;</code>을 사용할 수 있습니다. 그래서 표현식 <code class="hljs">Nat -&gt; Nat</code>과 <code class="hljs">Nat → Nat</code>은 같은 식을 의미합니다. 두 표현식 모두 자연수를 입력으로 받아 자연수를 출력으로 반환하는 함수 유형을 가리킵니다. 카테시안 곱을 나타내는 유니코드 기호 <code class="hljs">×</code>는 <code class="hljs">\times</code>을 입력하여 씁니다. 여러분은 유형을 포괄하기 위해  <code class="hljs">α</code>, <code class="hljs">β</code>, <code class="hljs">γ</code>같은 그리스 소문자 자주 사용할 것입니다. 여러분은 이들 중 특정한 것은 <code class="hljs">\a</code>, <code class="hljs">\b</code>과 <code class="hljs">\g</code>으로 입력할 수 있습니다.</p>
<p>여기서 몇 개 더 짚고가야 할 것이 있습니다. 우선 함수 <code class="hljs">f</code>에 값 <code class="hljs">x</code>의 활용은 <code class="hljs">f x</code> 를 지칭합니다. (예를 들어 <code class="hljs">Nat.succ 2</code>) 둘째로 유형 표현식을 쓸 때 화살표는<em>오른쪽</em> 먼저 결합합니다. 가령<code class="hljs">Nat.add</code>의 유형은 <code class="hljs">Nat → Nat → Nat</code>이고 이는 <code class="hljs">Nat → (Nat → Nat)</code>과 동등합니다. 따라서 여러분은 <code class="hljs">Nat.add</code>은 자연수를 받아 자연수를 받고 자연수를 반환하는 또 다른 함수를 반환하는 함수로 볼 수 있습니다. 유형론에서 보통 <code class="hljs">Nat.add</code>과 같이 쓰는 것이 자연수 쌍을 입력으로 받고 자연수를 출력으로 하는 함수로 쓰는 것보다 더 편리합니다. 예를 들어 이는 여러분에게 함수 <code class="hljs">Nat.add</code>의 "부분 적용"을 허용합니다. 위의 예제에서 <code class="hljs">Nat.add 3</code>는 <code class="hljs">Nat → Nat</code>유형을 가짐을  보였습니다. 즉 <code class="hljs">Nat.add 3</code>은 두번째 인자 <code class="hljs">n</code>을 "기다리는" 함수를 반환하는 것입니다. 이것은 <code class="hljs">Nat.add 3 n</code>로 쓰는 것과 동등합니다.</p>
<!-- Taking a function ``h`` of type ``Nat
× Nat → Nat`` and "redefining" it to look like ``g`` is a process
known as *currying*. -->
<p>여러분은 <code class="hljs">m : Nat</code>과  <code class="hljs">n : Nat</code>이면, <code class="hljs">(m, n)</code>은 <code class="hljs">Nat × Nat</code>유형인 <code class="hljs">m</code>과 <code class="hljs">n</code>의 순서쌍을 가리킨다는 것을 보았습니다. 이는 여러분에게 자연수의 쌍을 만들 수 있는 방법을 줍니다. 바낻로 여러분이 <code class="hljs">p : Nat × Nat</code>을 갖고 있다면 <code class="hljs">p.1 : Nat</code>과 <code class="hljs">p.2 : Nat</code>처럼 쓸 수 있습니다. 이는 여러분에게 순서쌍의 두 성분을 추출하는 방법을 줍니다.</p>
<h2><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/dependent_type_theory.html#types-as-objects" id="types-as-objects">대상의 유형</a></h2>
<p>린의 종속 유형론이 단순 유형론을 확장시키는 한 방법은 ---<code class="hljs">Nat</code>과 <code class="hljs">Bool</code>같은 개체는 그들 그 자체로 대상인 일등 시민 ---으로 두는 것입니다. 이렇게 하는 경우에 대해 그들 각각은 유형을 가져야만 합니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> Nat               <span class="hljs-comment">-- Type</span>
<span class="hljs-keyword">#check</span> Bool              <span class="hljs-comment">-- Type</span>
<span class="hljs-keyword">#check</span> Nat → Bool        <span class="hljs-comment">-- Type</span>
<span class="hljs-keyword">#check</span> Nat × Bool        <span class="hljs-comment">-- Type</span>
<span class="hljs-keyword">#check</span> Nat → Nat         <span class="hljs-comment">-- ...</span>
<span class="hljs-keyword">#check</span> Nat × Nat → Nat
<span class="hljs-keyword">#check</span> Nat → Nat → Nat
<span class="hljs-keyword">#check</span> Nat → (Nat → Nat)
<span class="hljs-keyword">#check</span> Nat → Nat → Bool
<span class="hljs-keyword">#check</span> (Nat → Nat) → Nat
</code></pre>
<p>여러분도 보다시피 위 각각의 표현식은 <code class="hljs">Type</code> 유형입니다. 여러분은 유형들에 대해 새 상수를 선언할 수 있습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> α <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Type</span> := Nat
<span class="hljs-theorem"><span class="hljs-keyword">def</span> β <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Type</span> := Bool
<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">F</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Type</span> → <span class="hljs-built_in">Type</span> := List
<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">G</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Type</span> → <span class="hljs-built_in">Type</span> → <span class="hljs-built_in">Type</span> := Prod

<span class="hljs-keyword">#check</span> α        <span class="hljs-comment">-- Type</span>
<span class="hljs-keyword">#check</span> F α      <span class="hljs-comment">-- Type</span>
<span class="hljs-keyword">#check</span> F Nat    <span class="hljs-comment">-- Type</span>
<span class="hljs-keyword">#check</span> G α      <span class="hljs-comment">-- Type → Type</span>
<span class="hljs-keyword">#check</span> G α β    <span class="hljs-comment">-- Type</span>
<span class="hljs-keyword">#check</span> G α Nat  <span class="hljs-comment">-- Type</span>
</code></pre>
<p>위 예에서 제안한 것처럼 여러분은 이미 주로 카테시안 곱 <code class="hljs">Prod</code>에서 <code class="hljs">Type → Type → Type</code> 유형의 함수의 예를 보았습니다. </p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> α <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Type</span> := Nat
<span class="hljs-theorem"><span class="hljs-keyword">def</span> β <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Type</span> := Bool

<span class="hljs-keyword">#check</span> Prod α β       <span class="hljs-comment">-- Type</span>
<span class="hljs-keyword">#check</span> α × β          <span class="hljs-comment">-- Type</span>

<span class="hljs-keyword">#check</span> Prod Nat Nat   <span class="hljs-comment">-- Type</span>
<span class="hljs-keyword">#check</span> Nat × Nat      <span class="hljs-comment">-- Type</span>
</code></pre>
<p>또 다른 예제가 있습니다. <code class="hljs">α</code>라 하는 임의의 타입에 대해 <code class="hljs">List α</code>의 유형은 <code class="hljs">α</code> 유형을 원소로 하는 리스트 유형을 가리킵니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> α <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Type</span> := Nat

<span class="hljs-keyword">#check</span> List α    <span class="hljs-comment">-- Type</span>
<span class="hljs-keyword">#check</span> List Nat  <span class="hljs-comment">-- Type</span>
</code></pre>
<p>린의 모든 표현식이 유형을 가진다면 <code class="hljs">Type</code> 그 자체는 어떤 유형을 가져야 하는지 궁금한게 당연합니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> <span class="hljs-built_in">Type</span>      <span class="hljs-comment">-- Type 1</span>
</code></pre>
<p>여러분은 린의 유형화 시스템의 가장 미묘한 면 중 하나를 마주쳤습니다. 린의 기저에는 무한한 유형의 계층이 있습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> <span class="hljs-built_in">Type</span>     <span class="hljs-comment">-- Type 1</span>
<span class="hljs-keyword">#check</span> <span class="hljs-built_in">Type</span> <span class="hljs-number">1</span>   <span class="hljs-comment">-- Type 2</span>
<span class="hljs-keyword">#check</span> <span class="hljs-built_in">Type</span> <span class="hljs-number">2</span>   <span class="hljs-comment">-- Type 3</span>
<span class="hljs-keyword">#check</span> <span class="hljs-built_in">Type</span> <span class="hljs-number">3</span>   <span class="hljs-comment">-- Type 4</span>
<span class="hljs-keyword">#check</span> <span class="hljs-built_in">Type</span> <span class="hljs-number">4</span>   <span class="hljs-comment">-- Type 5</span>
</code></pre>
<p><code class="hljs">Type 0</code>는 "작은" 또는 "평범한" 유형들의 세계라고 생각해보세요. <code class="hljs">Type 1</code>는  <code class="hljs">Type 0</code>를 원소로 갖는 유형들의 더 큰 세계이고 <code class="hljs">Type 2</code>는 <code class="hljs">Type 1</code>을 원소로 하는 유형들의 더욱 큰 세계입니다. 모든 자연수 <code class="hljs">n</code>에 대해 <code class="hljs">Type n</code>가 있어서 이런 리스트를 무한히 나열할 수 있습니다. <code class="hljs">Type</code>는 <code class="hljs">Type 0</code>에 대한 약식 표현입니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> <span class="hljs-built_in">Type</span>
<span class="hljs-keyword">#check</span> <span class="hljs-built_in">Type</span> <span class="hljs-number">0</span>
</code></pre>
<p>그러나 몇몇 연산은 유형 세계에 대해 <em>다형적(polymorphic, 구체적인 유형이 다르더다도 비슷한 동작을 바랄 수 있는 성질)</em>일 필요가 있습니다. 예를 들어 <code class="hljs">α</code>가 어떤 유형 세계에 있던간에 <code class="hljs">List α</code>는 임의의 유형 <code class="hljs">α</code>에 대해 의미가 있어야 합니다. 이는 <code class="hljs">List</code>함수의 유형 표기를 설명합니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> List    <span class="hljs-comment">-- Type u_1 → Type u_1</span>
</code></pre>
<p>여기서 <code class="hljs">u_1</code>는 어떤 유형 세계에 대한 변수입니다. <code class="hljs">#check</code> 명령의 출력은 <code class="hljs">α</code>가 <code class="hljs">Type n</code>유형을 갖는 한 <code class="hljs">List α</code>도 <code class="hljs">Type n</code> 유형을 가짐을 의미합니다. 마찬가지로 <code class="hljs">Prod</code> 함수는 다형적입니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> Prod    <span class="hljs-comment">-- Type u_1 → Type u_2 → Type (max u_1 u_2)</span>
</code></pre>
<p>다형적인 상수를 정의하기 위해 린은 여러분이 세계 변수를 <code class="hljs">universe</code> 명령을 명시적으로 사용하여 선언할 수 있게 했습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">universe</span> u

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">F</span> <span class="hljs-params">(α : <span class="hljs-built_in">Type</span> u)</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Type</span> u := Prod α α

<span class="hljs-keyword">#check</span> F    <span class="hljs-comment">-- Type u → Type u</span>
</code></pre>
<p>여러분은 F를 정의할 때 universe 매개변수를 제공하는 것으로 universe 명령을 쓰지 않을 수 있습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">F</span>.<span class="hljs-params">{u}</span> <span class="hljs-params">(α : <span class="hljs-built_in">Type</span> u)</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Type</span> u := Prod α α

<span class="hljs-keyword">#check</span> F    <span class="hljs-comment">-- Type u → Type u</span>
</code></pre>
<h2><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/dependent_type_theory.html#function-abstraction-and-evaluation" id="function-abstraction-and-evaluation">함수 추상화와 함수값의 평가</a></h2>
<p>린은 <code class="hljs">fun</code> (또는 <code class="hljs">λ</code>) 키워드를 제공하여 다음과 같은 표현식으로부터 함수를 만들 수 있게 합니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> <span class="hljs-keyword">fun</span> (x : Nat) =&gt; x + <span class="hljs-number">5</span>   <span class="hljs-comment">-- Nat → Nat</span>
<span class="hljs-keyword">#check</span> λ (x : Nat) =&gt; x + <span class="hljs-number">5</span>     <span class="hljs-comment">-- λ 와 fun 같은 의미를 가집니다.</span>
<span class="hljs-keyword">#check</span> <span class="hljs-keyword">fun</span> x : Nat =&gt; x + <span class="hljs-number">5</span>     <span class="hljs-comment">-- Nat으로 추론됩니다.</span>
<span class="hljs-keyword">#check</span> λ x : Nat =&gt; x + <span class="hljs-number">5</span>       <span class="hljs-comment">-- Nat으로 추론됩니다.</span>
</code></pre>
<p>여러분은 필요한 매개변수를 람다 함수에 넘겨줌으로써 값을 평가할 수 있습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> (λ x : Nat =&gt; x + <span class="hljs-number">5</span>) <span class="hljs-number">10</span>    <span class="hljs-comment">-- 15</span>
</code></pre>
<p>다른 표현식으로부터 함수를 만드는 것은 <em>람다 추상화(lambda abstraction)</em>과정으로 알려져 있습니다. 여러분이 변수 <code class="hljs">x : α</code>를 갖고 있고 표현식 <code class="hljs">t : β</code>을 만들 수 있다 가정합시다. 그러면 표현식<code class="hljs">fun (x : α) =&gt; t</code> 또는 등가적으로 <code class="hljs">λ (x : α) =&gt; t</code>은 <code class="hljs">α → β</code> 유형인 대상입니다. 이를  임의의 값 x에서 값 t로 대응시키는 <code class="hljs">α</code>에서 <code class="hljs">β</code>까지의 함수로 생각해보세요.</p>
<p>여기 추가 예제가 더 있습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> <span class="hljs-keyword">fun</span> x : Nat =&gt; <span class="hljs-keyword">fun</span> y : Bool =&gt; <span class="hljs-keyword">if</span> not y <span class="hljs-keyword">then</span> x + <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> x + <span class="hljs-number">2</span>
<span class="hljs-keyword">#check</span> <span class="hljs-keyword">fun</span> (x : Nat) (y : Bool) =&gt; <span class="hljs-keyword">if</span> not y <span class="hljs-keyword">then</span> x + <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> x + <span class="hljs-number">2</span>
<span class="hljs-keyword">#check</span> <span class="hljs-keyword">fun</span> x y =&gt; <span class="hljs-keyword">if</span> not y <span class="hljs-keyword">then</span> x + <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> x + <span class="hljs-number">2</span>   <span class="hljs-comment">-- Nat → Bool → Nat</span>
</code></pre>
<p>린은 마지막 세 예제를 같은 표현식으로 해석합니다. 마지막 표현식에서 린은 <code class="hljs">x</code>와 <code class="hljs">y</code>의 유형을 표현식 <code class="hljs">if not y then x + 1 else x + 2</code>으로부터 추론합니다.</p>
<p>수학적으로 흔한 함수 연산 예제는 람다 추상화에 대한 것으로 설명될 수 있습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span> <span class="hljs-params">(n : Nat)</span> <span class="hljs-symbol">:</span></span> String := toString n
<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">g</span> <span class="hljs-params">(s : String)</span> <span class="hljs-symbol">:</span></span> Bool := s.length &gt; <span class="hljs-number">0</span>

<span class="hljs-keyword">#check</span> <span class="hljs-keyword">fun</span> x : Nat =&gt; x        <span class="hljs-comment">-- Nat → Nat</span>
<span class="hljs-keyword">#check</span> <span class="hljs-keyword">fun</span> x : Nat =&gt; <span class="hljs-literal">true</span>     <span class="hljs-comment">-- Nat → Bool</span>
<span class="hljs-keyword">#check</span> <span class="hljs-keyword">fun</span> x : Nat =&gt; g (f x)  <span class="hljs-comment">-- Nat → Bool</span>
<span class="hljs-keyword">#check</span> <span class="hljs-keyword">fun</span> x =&gt; g (f x)        <span class="hljs-comment">-- Nat → Bool</span>
</code></pre>
<p>이 표현식의 의미에 대해 생각해보세요. 표현식 <code class="hljs">fun x : Nat =&gt; x</code>은 <code class="hljs">Nat</code>에 대한 항등함수를 의미합니다. 표현식 <code class="hljs">fun x : Nat =&gt; true</code>은 항상  <code class="hljs">true</code>을 반환하는 상수함수를 가리합니다. 그리고 <code class="hljs">fun x : Nat =&gt; g (f x)</code>는 <code class="hljs">f</code>와 <code class="hljs">g</code>의 합성함수를 가리킵니다. 일반적으로 여러분도 유형 표기를 빼고 린에게 유형을 추론하게 둘 수 있습니다. 그래서 여러분은 <code class="hljs">fun x : Nat =&gt; g (f x)</code>대신에 <code class="hljs">fun x =&gt; g (f x)</code>와 같이 쓸 수 있습니다.</p>
<p>여러분은 매개변수로 함수의 이름  <code class="hljs">f</code>과 <code class="hljs">g</code> 을 주는 것으로 함수를 전달할 수 있습니다.  그러면 구현에서 이들 함수를 사용할 수 있습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> <span class="hljs-keyword">fun</span> (g : String → Bool) (f : Nat → String) (x : Nat) =&gt; g (f x)
<span class="hljs-comment">-- (String → Bool) → (Nat → String) → Nat → Bool</span>
</code></pre>
<p>여러분은 매개변수로 유형도 전달할 수 있습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> <span class="hljs-keyword">fun</span> (α β γ : <span class="hljs-built_in">Type</span>) (g : β → γ) (f : α → β) (x : α) =&gt; g (f x)
</code></pre>
<p>마지막 표현식은 세 유형 <code class="hljs">α</code>, <code class="hljs">β</code>, <code class="hljs">γ</code>과 두 함수 <code class="hljs">g : β → γ</code>과 <code class="hljs">f : α → β</code>을 받고 <code class="hljs">g</code>과 <code class="hljs">f</code>의 합성을 반환하는 함수를 나타냅니다. (이 함수의 유형들을 이해하는 것은 아래에서 설명할 의존 곱에 대한 이해가 필요합니다.)</p>
<p>람다 표현식의 일반적인 형태는 <code class="hljs">fun x : α =&gt; t</code>입니다. 여기서 변수 <code class="hljs">x</code>는 "구속변수"입니다. 이는 그것의 "범위"가 표현식  <code class="hljs">t</code> 안으로 제한되는 '자리차지자'일 뿐 입니다. 예를 들어 표현식 <code class="hljs">fun (b : β) (x : α) =&gt; b</code> 속 변수 <code class="hljs">b</code>는 앞서 선언된 상수 <code class="hljs">b</code>와는 아무런 연관이 없습니다. 사실 표현식은  <code class="hljs">fun (u : β) (z : α) =&gt; u</code>처럼 같은 함수를 가리킵니다.</p>
<p>공식적으로 구속 변수의 이름이 바뀌기까지 같은 표현식은 <em>알파 등가(alpha equivalent)</em>라 하고 "같은" 것으로 생각합니다. 린도 이를 등가로 인식합니다.</p>
<p>항 <code class="hljs">t : α → β</code>을 항 <code class="hljs">s : α</code>에 적용하여 표현식 <code class="hljs">t s : β</code>을 얻는 것을 보세요. 이전 예제로 돌아가 명확성을 위해 구속변수의 이름을 바꿉시다. 다음 표현식의 유형을 주목하세요.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> (<span class="hljs-keyword">fun</span> x : Nat =&gt; x) <span class="hljs-number">1</span>     <span class="hljs-comment">-- Nat</span>
<span class="hljs-keyword">#check</span> (<span class="hljs-keyword">fun</span> x : Nat =&gt; <span class="hljs-literal">true</span>) <span class="hljs-number">1</span>  <span class="hljs-comment">-- Bool</span>

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span> <span class="hljs-params">(n : Nat)</span> <span class="hljs-symbol">:</span></span> String := toString n
<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">g</span> <span class="hljs-params">(s : String)</span> <span class="hljs-symbol">:</span></span> Bool := s.length &gt; <span class="hljs-number">0</span>

<span class="hljs-keyword">#check</span>
  (<span class="hljs-keyword">fun</span> (α β γ : <span class="hljs-built_in">Type</span>) (u : β → γ) (v : α → β) (x : α) =&gt; u (v x)) Nat String Bool g f <span class="hljs-number">0</span>
  <span class="hljs-comment">-- Bool</span>
</code></pre>
<p>예상했다시피 표현식<code class="hljs">(fun x : Nat =&gt; x) 1</code> 은 <code class="hljs">Nat</code> 유형을 갖습니다. 사실, 더 중요한건 표현식<code class="hljs">(fun x : Nat =&gt; x)</code>을 <code class="hljs">1</code>에 적용하는 것은 값 <code class="hljs">1</code>을 "반환"하는 겁니다. 그리고 당연히 그럽니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> (<span class="hljs-keyword">fun</span> x : Nat =&gt; x) <span class="hljs-number">1</span>     <span class="hljs-comment">-- 1</span>
<span class="hljs-keyword">#eval</span> (<span class="hljs-keyword">fun</span> x : Nat =&gt; <span class="hljs-literal">true</span>) <span class="hljs-number">1</span>  <span class="hljs-comment">-- true</span>
</code></pre>
<p>여러분은 나중에 이 항들이 어떻게 평가되는지 볼 겁니다. 현재로써는 이게 의존 유형론의 중요한 특징인 것만 알아 두세요. 모든 항은 전산적 거동을 하고 <em>정규화(normalization)</em>의 개념을 지원합니다. 원리적으로 같은 값으로 축약되는 두 항은 <em>정의상으로 동등(definitionally equal)</em>하다고 합니다. 이런 것은 린의 유형 검사기가 "같은"것으로 봅니다. 그리고 린은 유형을 인식하고 대조하는데 최선을 다합니다.</p>
<p>린은 완전한 프로그래밍 언어입니다. 이것은 이진 실행 프로그램을 만드는 컴파일러와 상호작용적인 인터프리터를 갖고 있습니다. 여러분은 <code class="hljs">#eval</code> 명령을 사용해 식을 실행할 수 있습니다. 그리고 이것은 당신의 함수를 시험하는 선호되는 방식입니다.</p>
<!--
Note that `#eval` and
`#reduce` are *not* equivalent. The command `#eval` first compiles
Lean expressions into an intermediate representation (IR) and then
uses an interpreter to execute the generated IR. Some builtin types
(e.g., `Nat`, `String`, `Array`) have a more efficient representation
in the IR. The IR has support for using foreign functions that are
opaque to Lean.

In contrast, the ``#reduce`` command relies on a reduction engine
similar to the one used in Lean's trusted kernel, the part of Lean
that is responsible for checking and verifying the correctness of
expressions and proofs. It is less efficient than ``#eval``, and
treats all foreign functions as opaque constants. You will learn later
that there are some other differences between the two commands.
-->
<h2><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/dependent_type_theory.html#definitions" id="definitions">정의(Definitions)</a></h2>
<p> <code class="hljs">def</code>가 새 이름을 가진 대상을 선언하는 중요한 방식임을 기억하세요.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span><span class="hljs-title">o</span><span class="hljs-title">u</span><span class="hljs-title">b</span><span class="hljs-title">l</span><span class="hljs-title">e</span> <span class="hljs-params">(x : Nat)</span> <span class="hljs-symbol">:</span></span> Nat :=
  x + x
</code></pre>
<p>다른 프로그래밍언어에서 함수가 어떻게 동작하는지 안다면 이게 여러분에게 더 친숙하게 보일지 모르겠습니다. 이름 <code class="hljs">double</code>은 <code class="hljs">Nat</code> 유형의 입력 매개변수 <code class="hljs">x</code>를 받고  호출의 결과로 <code class="hljs">x + x</code>인 함수로 정의되었습니다. 그래서 <code class="hljs">Nat</code> 유형을 반환합니다. 여러분은 이 함수를 다음과 같이 불러낼 수 있습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="숨겨진 선 보이기" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="boring"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span><span class="hljs-title">o</span><span class="hljs-title">u</span><span class="hljs-title">b</span><span class="hljs-title">l</span><span class="hljs-title">e</span> <span class="hljs-params">(x : Nat)</span> <span class="hljs-symbol">:</span></span> Nat :=
</span><span class="boring"> x + x
</span><span class="hljs-keyword">#eval</span> double <span class="hljs-number">3</span>    <span class="hljs-comment">-- 6</span>
</code></pre>
<p>이 경우 여러분은 <code class="hljs">def</code>를 <code class="hljs">lambda</code>와 같은 종류로 생각할 수 있습니다. 다음은 같은 결과를 만듭니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span><span class="hljs-title">o</span><span class="hljs-title">u</span><span class="hljs-title">b</span><span class="hljs-title">l</span><span class="hljs-title">e</span> <span class="hljs-symbol">:</span></span> Nat → Nat :=
  <span class="hljs-keyword">fun</span> x =&gt; x + x

<span class="hljs-keyword">#eval</span> double <span class="hljs-number">3</span>    <span class="hljs-comment">-- 6</span>
</code></pre>
<p>Lean이 유형을 추론하기에 충분한 정보를 갖고있을 때 여러분은 유형 선언을 생략할 수 있습니다. 유형 추론은 Lean의 중요한 기능입니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span><span class="hljs-title">o</span><span class="hljs-title">u</span><span class="hljs-title">b</span><span class="hljs-title">l</span><span class="hljs-title">e</span> <span class="hljs-symbol">:</span></span>=
  <span class="hljs-keyword">fun</span> (x : Nat) =&gt; x + x
</code></pre>
<p>정의의 일반적인 형태는  <code class="hljs">def foo : α := bar</code>입니다. 여기서  <code class="hljs">α</code> 는 식 <code class="hljs">bar</code>로부터 반환되는 유형입니다. Lean은 <code class="hljs">α</code>의 유형을 추론할 수 있습니다. 그러나 이를 명백히 적는 것이 좋습니다. 이것은 당신의 의도를 명확히 만들고 Lean은 정의의 우변에 일치하는 유형이 아닌 경우 에러를 표시할 것입니다.</p>
<p>우변 <code class="hljs">bar</code>는 lambda뿐만 아니라 어떤 식이든 될 수 있습니다. 그래서 <code class="hljs">def</code>는 이 같은 값을 단순히 이름으로 쓸 수 있습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">p</span><span class="hljs-title">i</span> <span class="hljs-symbol">:</span></span>= <span class="hljs-number">3.141592654</span>
</code></pre>
<p><code class="hljs">def</code>는 다수의 입력 매개변수를 받을 수 있습니다. 두 자연수를 더하는 함수를 만들어 봅시다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span><span class="hljs-title">d</span><span class="hljs-title">d</span> <span class="hljs-params">(x y : Nat)</span> <span class="hljs-symbol">:</span></span>=
  x + y

<span class="hljs-keyword">#eval</span> add <span class="hljs-number">3</span> <span class="hljs-number">2</span>               <span class="hljs-comment">-- 5</span>
</code></pre>
<p>매개변수 리스트는 이와 같이 나눠 쓸 수 있습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="숨겨진 선 보이기" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="boring"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span><span class="hljs-title">o</span><span class="hljs-title">u</span><span class="hljs-title">b</span><span class="hljs-title">l</span><span class="hljs-title">e</span> <span class="hljs-params">(x : Nat)</span> <span class="hljs-symbol">:</span></span> Nat :=
</span><span class="boring"> x + x
</span><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span><span class="hljs-title">d</span><span class="hljs-title">d</span> <span class="hljs-params">(x : Nat)</span> <span class="hljs-params">(y : Nat)</span> <span class="hljs-symbol">:</span></span>=
  x + y

<span class="hljs-keyword">#eval</span> add (double <span class="hljs-number">3</span>) (<span class="hljs-number">7</span> + <span class="hljs-number">9</span>)  <span class="hljs-comment">-- 22</span>
</code></pre>
<p>여기서 우리가 <code class="hljs">add</code>의 첫 번째 매개변수를 만들기 위해 <code class="hljs">double</code> 함수를 호출한 것을 보세요.</p>
<p>여러분은 다른 더 흥미로운 식을 <code class="hljs">def</code> 안에 사용할 수 있습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">g</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">a</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">r</span> <span class="hljs-params">(x y : Nat)</span> <span class="hljs-symbol">:</span></span>=
  <span class="hljs-keyword">if</span> x &gt; y <span class="hljs-keyword">then</span> x
  <span class="hljs-keyword">else</span> y
</code></pre>
<p>여러분은 이 정의가 아마 뭘 할 지 추측할 수 있을 거예요.</p>
<p>여러분은 또 다른 함수를 입력으로 받는 함수를 정의할 수 있습니다. 다음은 주어진 함수를 첫번째 호출의 출력을 두번째에 전달하는 것으로 두 번 호출합니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="숨겨진 선 보이기" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="boring"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span><span class="hljs-title">o</span><span class="hljs-title">u</span><span class="hljs-title">b</span><span class="hljs-title">l</span><span class="hljs-title">e</span> <span class="hljs-params">(x : Nat)</span> <span class="hljs-symbol">:</span></span> Nat :=
</span><span class="boring"> x + x
</span><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span><span class="hljs-title">o</span><span class="hljs-title">Tw</span><span class="hljs-title">i</span><span class="hljs-title">c</span><span class="hljs-title">e</span> <span class="hljs-params">(f : Nat → Nat)</span> <span class="hljs-params">(x : Nat)</span> <span class="hljs-symbol">:</span></span> Nat :=
  f (f x)

<span class="hljs-keyword">#eval</span> doTwice double <span class="hljs-number">2</span>   <span class="hljs-comment">-- 8</span>
</code></pre>
<p>이제 약간 더 추상적으로 갑시다. 여러분은 유형 매개변수같은 인수를 지정할 수도 있습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">c</span><span class="hljs-title">o</span><span class="hljs-title">m</span><span class="hljs-title">p</span><span class="hljs-title">o</span><span class="hljs-title">s</span><span class="hljs-title">e</span> <span class="hljs-params">(α β γ : <span class="hljs-built_in">Type</span>)</span> <span class="hljs-params">(g : β → γ)</span> <span class="hljs-params">(f : α → β)</span> <span class="hljs-params">(x : α)</span> <span class="hljs-symbol">:</span></span> γ :=
  g (f x)
</code></pre>
<p>이는 <code class="hljs">compose</code>가 하나의 입력만 받는 함수인 경우에만 임의의 두 함수를 입력 인수로 받는 함수임을 의미합니다.  <code class="hljs">β → γ</code> 와 <code class="hljs">α → β</code>의 유형 대수는 두 번째 함수의 출력 유형이 첫 번째 함수의 입력 유형과 반드시 일치해야 한다는 요구를 같습니다. 이렇지 않다면 두 함수는 합성될 수 없을 것입니다.</p>
<p><code class="hljs">compose</code>는 이는 두 번째 함수(지역적으로 <code class="hljs">f</code>라 하는)을 호출하는데 사용되기도 하는 유형 <code class="hljs">α</code> 를 세 번째 인수로 받습니다. 그리고 두 번째 합수는 그 함수의 결과(유형 <code class="hljs">β</code>의)를 첫 번째 함수(지역적으로 <code class="hljs">g</code>라 하는)의 입력으로 전달합니다. 첫 번째 함수는 유형 <code class="hljs">γ</code> 를 반환하여 이게 <code class="hljs">compose</code> 함수의 반환형이 되게 합니다.</p>
<p><code class="hljs">compose</code>는 또 아주 일반적이어서 임의의 유형 <code class="hljs">α β γ</code>에 대해서도 작동합니다. 이는 <code class="hljs">compose</code>가 그들이 입력받는 두 함수 각각이 한 매개변수만 받고 두번째 함수의 출력 유형이 첫번째 함수의 입력 유형과 같은 한 합성할 수 있다는 것을 의미합니다. 예를 들어</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="숨겨진 선 보이기" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="boring"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">c</span><span class="hljs-title">o</span><span class="hljs-title">m</span><span class="hljs-title">p</span><span class="hljs-title">o</span><span class="hljs-title">s</span><span class="hljs-title">e</span> <span class="hljs-params">(α β γ : <span class="hljs-built_in">Type</span>)</span> <span class="hljs-params">(g : β → γ)</span> <span class="hljs-params">(f : α → β)</span> <span class="hljs-params">(x : α)</span> <span class="hljs-symbol">:</span></span> γ :=
</span><span class="boring"> g (f x)
</span><span class="boring"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span><span class="hljs-title">o</span><span class="hljs-title">u</span><span class="hljs-title">b</span><span class="hljs-title">l</span><span class="hljs-title">e</span> <span class="hljs-params">(x : Nat)</span> <span class="hljs-symbol">:</span></span> Nat :=
</span><span class="boring"> x + x
</span><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">s</span><span class="hljs-title">q</span><span class="hljs-title">u</span><span class="hljs-title">a</span><span class="hljs-title">r</span><span class="hljs-title">e</span> <span class="hljs-params">(x : Nat)</span> <span class="hljs-symbol">:</span></span> Nat :=
  x * x

<span class="hljs-keyword">#eval</span> compose Nat Nat Nat double square <span class="hljs-number">3</span>  <span class="hljs-comment">-- 18</span>
</code></pre>
<h2><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/dependent_type_theory.html#local-definitions" id="local-definitions">지역 정의(Local Definitions)</a></h2>
<p>Lean은 여러분이 <code class="hljs">let</code> 키워드를 사용해 "지역" 정의를 가져올 수 있게 허용합니다. 표현식 <code class="hljs">let a := t1; t2</code> 는 <code class="hljs">t2</code>  속 <code class="hljs">a</code>의 모든 나타남(occurrence)을 <code class="hljs">t1</code>으로 대체한 결과에 대해 정의상으로 같습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> <span class="hljs-keyword">let</span> y := <span class="hljs-number">2</span> + <span class="hljs-number">2</span>; y * y   <span class="hljs-comment">-- Nat</span>
<span class="hljs-keyword">#eval</span>  <span class="hljs-keyword">let</span> y := <span class="hljs-number">2</span> + <span class="hljs-number">2</span>; y * y   <span class="hljs-comment">-- 16</span>

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">tw</span><span class="hljs-title">i</span><span class="hljs-title">c</span><span class="hljs-title">e</span><span class="hljs-title">_</span><span class="hljs-title">d</span><span class="hljs-title">o</span><span class="hljs-title">u</span><span class="hljs-title">b</span><span class="hljs-title">l</span><span class="hljs-title">e</span> <span class="hljs-params">(x : Nat)</span> <span class="hljs-symbol">:</span></span> Nat :=
  <span class="hljs-keyword">let</span> y := x + x; y * y

<span class="hljs-keyword">#eval</span> twice_double <span class="hljs-number">2</span>   <span class="hljs-comment">-- 16</span>
</code></pre>
<p>여기서<code class="hljs">twice_double x</code>도 항  <code class="hljs">(x + x) * (x + x)</code>과 정의상으로 같습니다.</p>
<p>여러분은 다수의 할당을 <code class="hljs">let</code> 구문으로 연결함으로써 결합할 수 있습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> <span class="hljs-keyword">let</span> y := <span class="hljs-number">2</span> + <span class="hljs-number">2</span>; <span class="hljs-keyword">let</span> z := y + y; z * z   <span class="hljs-comment">-- Nat</span>
<span class="hljs-keyword">#eval</span>  <span class="hljs-keyword">let</span> y := <span class="hljs-number">2</span> + <span class="hljs-number">2</span>; <span class="hljs-keyword">let</span> z := y + y; z * z   <span class="hljs-comment">-- 64</span>
</code></pre>
<p>세미콜론<code class="hljs">;</code>은 줄을 분리할 때 사용되므로 생략될 수 있습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">t</span> <span class="hljs-params">(x : Nat)</span> <span class="hljs-symbol">:</span></span> Nat :=
  <span class="hljs-keyword">let</span> y := x + x
  y * y
</code></pre>
<p>표현식 <code class="hljs">let a := t1; t2</code>의 의미는 <code class="hljs">(fun a =&gt; t2) t1</code>의 의미와 아주 비슷함을 주목하세요. 그러나 이 둘은 같지는 않습니다. 첫 번째 표현식에서, 여러분은 <code class="hljs">t2</code>속 <code class="hljs">a</code>의 모든 개체를 <code class="hljs">t1</code>에 대한 문법적 약어로 생각해야 합니다. 두 번째 표현식에서 <code class="hljs">a</code>는 변수이고 표현식 <code class="hljs">fun a =&gt; t2</code>는  <code class="hljs">a</code>의 값과 별개로 의미를 가져야 합니다.  <code class="hljs">let</code> 생성은 약어의 의미로 더 강합니다. 그리고 <code class="hljs">let a := t1; t2</code> 형태의 표현식은 <code class="hljs">(fun a =&gt; t2) t1</code>같이 표현될 수 없는 식이 있습니다. 연습으로 아래 유형 확인에서 <code class="hljs">foo</code>의 정의가 왜 그런지 그러나  <code class="hljs">bar</code>의 정의는 그렇지 않은지 이해하려고 해 보세요.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-title">o</span><span class="hljs-title">o</span> <span class="hljs-symbol">:</span></span>= <span class="hljs-keyword">let</span> a := Nat; <span class="hljs-keyword">fun</span> x : a =&gt; x + <span class="hljs-number">2</span>
<span class="hljs-comment">/-
  def bar := (fun a =&gt; fun x : a =&gt; x + 2) Nat
-/</span>
</code></pre>
<h1><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/dependent_type_theory.html#a-name_variables_and_sectionsavariables-and-sections" id="a-name_variables_and_sectionsavariables-and-sections"></a><a name="_variables_and_sections"></a>변수와 섹션(Variables and Sections)</h1>
<p>다음 세 함수 정의를 생각해보세요.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">c</span><span class="hljs-title">o</span><span class="hljs-title">m</span><span class="hljs-title">p</span><span class="hljs-title">o</span><span class="hljs-title">s</span><span class="hljs-title">e</span> <span class="hljs-params">(α β γ : <span class="hljs-built_in">Type</span>)</span> <span class="hljs-params">(g : β → γ)</span> <span class="hljs-params">(f : α → β)</span> <span class="hljs-params">(x : α)</span> <span class="hljs-symbol">:</span></span> γ :=
  g (f x)

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span><span class="hljs-title">o</span><span class="hljs-title">Tw</span><span class="hljs-title">i</span><span class="hljs-title">c</span><span class="hljs-title">e</span> <span class="hljs-params">(α : <span class="hljs-built_in">Type</span>)</span> <span class="hljs-params">(h : α → α)</span> <span class="hljs-params">(x : α)</span> <span class="hljs-symbol">:</span></span> α :=
  h (h x)

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span><span class="hljs-title">o</span><span class="hljs-title">T</span><span class="hljs-title">h</span><span class="hljs-title">r</span><span class="hljs-title">i</span><span class="hljs-title">c</span><span class="hljs-title">e</span> <span class="hljs-params">(α : <span class="hljs-built_in">Type</span>)</span> <span class="hljs-params">(h : α → α)</span> <span class="hljs-params">(x : α)</span> <span class="hljs-symbol">:</span></span> α :=
  h (h (h x))
</code></pre>
<p>린은 여러분에게 이런 선언을 더 간결하게 보이게 만들도록 <code class="hljs">variable</code> 명령을 제공합니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">variable</span> (α β γ : <span class="hljs-built_in">Type</span>)

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">c</span><span class="hljs-title">o</span><span class="hljs-title">m</span><span class="hljs-title">p</span><span class="hljs-title">o</span><span class="hljs-title">s</span><span class="hljs-title">e</span> <span class="hljs-params">(g : β → γ)</span> <span class="hljs-params">(f : α → β)</span> <span class="hljs-params">(x : α)</span> <span class="hljs-symbol">:</span></span> γ :=
  g (f x)

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span><span class="hljs-title">o</span><span class="hljs-title">Tw</span><span class="hljs-title">i</span><span class="hljs-title">c</span><span class="hljs-title">e</span> <span class="hljs-params">(h : α → α)</span> <span class="hljs-params">(x : α)</span> <span class="hljs-symbol">:</span></span> α :=
  h (h x)

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span><span class="hljs-title">o</span><span class="hljs-title">T</span><span class="hljs-title">h</span><span class="hljs-title">r</span><span class="hljs-title">i</span><span class="hljs-title">c</span><span class="hljs-title">e</span> <span class="hljs-params">(h : α → α)</span> <span class="hljs-params">(x : α)</span> <span class="hljs-symbol">:</span></span> α :=
  h (h (h x))
</code></pre>
<p>여러분은 <code class="hljs">Type</code> 그 자체뿐만 아니라 임의의 유형의 변수를 선언할 수 있습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">variable</span> (α β γ : <span class="hljs-built_in">Type</span>)
<span class="hljs-keyword">variable</span> (g : β → γ) (f : α → β) (h : α → α)
<span class="hljs-keyword">variable</span> (x : α)

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">c</span><span class="hljs-title">o</span><span class="hljs-title">m</span><span class="hljs-title">p</span><span class="hljs-title">o</span><span class="hljs-title">s</span><span class="hljs-title">e</span> <span class="hljs-symbol">:</span></span>= g (f x)
<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span><span class="hljs-title">o</span><span class="hljs-title">Tw</span><span class="hljs-title">i</span><span class="hljs-title">c</span><span class="hljs-title">e</span> <span class="hljs-symbol">:</span></span>= h (h x)
<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span><span class="hljs-title">o</span><span class="hljs-title">T</span><span class="hljs-title">h</span><span class="hljs-title">r</span><span class="hljs-title">i</span><span class="hljs-title">c</span><span class="hljs-title">e</span> <span class="hljs-symbol">:</span></span>= h (h (h x))

<span class="hljs-keyword">#print</span> compose
<span class="hljs-keyword">#print</span> doTwice
<span class="hljs-keyword">#print</span> doThrice
</code></pre>
<p>이것을 출력하는 것은 세 정의 그룹이 정확히 동일한 효과를 가짐을 보여줍니다.</p>
<p> <code class="hljs">variable</code>명령은 Lean에게 선언된 변수를 그들을 이름으로 참조하는 정의의 구속 변수로 삽입하라고 지시합니다. Lean은 정의에서 명시적으로나 암시적으로 사용된 변수를 구분하기에 충분히 똑똑합니다. 그러므로 여러분은 여러분의 정의를 작성할 때  <code class="hljs">α</code>, <code class="hljs">β</code>, <code class="hljs">γ</code>, <code class="hljs">g</code>, <code class="hljs">f</code>, <code class="hljs">h</code>, <code class="hljs">x</code>가 고정된 대상임에도 사용할 수 있습니다. 그리고 lean이 여러분을 위해 자동으로 정의를 축약할 수 있게 합니다.</p>
<p>이 방식으로 선언되었을 때, 변수는 여러분이 작업하는 파일 끝까지를 범위로 가질 겁니다. 그러나 때때로 변수의 범위를 제한하는 것이 유용합니다. 이를 위해 Lean은  <code class="hljs">section</code>의 개념을 제공합니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">section</span> useful
  <span class="hljs-keyword">variable</span> (α β γ : <span class="hljs-built_in">Type</span>)
  <span class="hljs-keyword">variable</span> (g : β → γ) (f : α → β) (h : α → α)
  <span class="hljs-keyword">variable</span> (x : α)

  <span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">c</span><span class="hljs-title">o</span><span class="hljs-title">m</span><span class="hljs-title">p</span><span class="hljs-title">o</span><span class="hljs-title">s</span><span class="hljs-title">e</span> <span class="hljs-symbol">:</span></span>= g (f x)
  <span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span><span class="hljs-title">o</span><span class="hljs-title">Tw</span><span class="hljs-title">i</span><span class="hljs-title">c</span><span class="hljs-title">e</span> <span class="hljs-symbol">:</span></span>= h (h x)
  <span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span><span class="hljs-title">o</span><span class="hljs-title">T</span><span class="hljs-title">h</span><span class="hljs-title">r</span><span class="hljs-title">i</span><span class="hljs-title">c</span><span class="hljs-title">e</span> <span class="hljs-symbol">:</span></span>= h (h (h x))
<span class="hljs-keyword">end</span> useful
</code></pre>
<p>섹션이 닫히게 될 때, 변수들은 범위를 벗어나게 됩니다. 그리고 구분된 메모리 외에 아무것도 없게 됩니다.</p>
<p>섹션 안에서 줄에 들여쓰기를 하거나  섹션에 이름을 줄 필요도 없습니다. 그말은 즉슨, 여러분은 익명의 <code class="hljs">section</code> / <code class="hljs">end</code> 쌍을 사용할 수 있다는 것입니다. 그러나 여러분이 섹션에 이름을 붙이고자 한다면 같은 이름을 사용해 이를 닫아야 합니다. section은 중첩될 수도 있습니다. 이는 여러분에게 새로운 변수를 점진적으로 선언할 수 있게 합니다.</p>
<h1><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/dependent_type_theory.html#a-name_namespacesanamespaces" id="a-name_namespacesanamespaces"></a><a name="_namespaces"></a>이름공간(Namespaces)</h1>
<p>Lean은 여러분에게 정의를 중첩되고 계층적인 <em>namespaces</em>에 묶을 수 있는 능력을 제공합니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">namespace</span> Foo
  <span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span> <span class="hljs-symbol">:</span></span> Nat := <span class="hljs-number">5</span>
  <span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span> <span class="hljs-params">(x : Nat)</span> <span class="hljs-symbol">:</span></span> Nat := x + <span class="hljs-number">7</span>

  <span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-title">a</span> <span class="hljs-symbol">:</span></span> Nat := f a
  <span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-title">f</span><span class="hljs-title">a</span> <span class="hljs-symbol">:</span></span> Nat := f (f a)

  <span class="hljs-keyword">#check</span> a
  <span class="hljs-keyword">#check</span> f
  <span class="hljs-keyword">#check</span> fa
  <span class="hljs-keyword">#check</span> ffa
  <span class="hljs-keyword">#check</span> Foo.fa
<span class="hljs-keyword">end</span> Foo

<span class="hljs-comment">-- #check a  -- error</span>
<span class="hljs-comment">-- #check f  -- error</span>
<span class="hljs-keyword">#check</span> Foo.a
<span class="hljs-keyword">#check</span> Foo.f
<span class="hljs-keyword">#check</span> Foo.fa
<span class="hljs-keyword">#check</span> Foo.ffa

<span class="hljs-keyword">open</span> Foo

<span class="hljs-keyword">#check</span> a
<span class="hljs-keyword">#check</span> f
<span class="hljs-keyword">#check</span> fa
<span class="hljs-keyword">#check</span> Foo.fa
</code></pre>
<p>이름공간 <code class="hljs">Foo</code>에서 작업한다고 여러분이 선언할 때 여러분이 선언한 모든 식별자들은 "<code class="hljs">Foo.</code>"를 접미사로 갖습니다. Within the namespace, you can refer to identifiers by their shorter names, but once you end the namespace, you have to use the longer names. <code class="hljs">section</code>과는 달리, 이름공간은 이름이 필요합니다. root 계층에서만 익명 이름 공간이 있습니다.</p>
<p><code class="hljs">open</code> 명령은 현재 맥락에서 짧은 이름을 가져옵니다. 짧은 식별자로 접근하기 위해서 종종 여러분이 모듈을 가져오기(import) 할 때, 모듈이 담은 다수의 이름공간을 열기 원할 것입니다. 그러나 때로는 당신이 사용할 다른 이름공간과 식별자가 충돌할 때 여러분이 이 정보가 완전히 자격을 갖춘 이름으로 보호되길 원할 것입니다. 따라서 이름공간은 당신의 작업 환경 속에 이름을 관리하는 방법을 줍니다.</p>
<p>예를 들어 Lean은 이름공간 <code class="hljs">List</code> 속에 리스트를 포함한 정의와 정리를 묶습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> List.nil
<span class="hljs-keyword">#check</span> List.cons
<span class="hljs-keyword">#check</span> List.map
</code></pre>
<p><code class="hljs">open List</code>  명령은 여러분이 더 짧은 이름을 사용할 수 있게 합니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">open</span> List

<span class="hljs-keyword">#check</span> nil
<span class="hljs-keyword">#check</span> cons
<span class="hljs-keyword">#check</span> map
</code></pre>
<p>section처럼 이름공간도 중첩될 수 있습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">namespace</span> Foo
  <span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span> <span class="hljs-symbol">:</span></span> Nat := <span class="hljs-number">5</span>
  <span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span> <span class="hljs-params">(x : Nat)</span> <span class="hljs-symbol">:</span></span> Nat := x + <span class="hljs-number">7</span>

  <span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-title">a</span> <span class="hljs-symbol">:</span></span> Nat := f a

  <span class="hljs-keyword">namespace</span> Bar
    <span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-title">f</span><span class="hljs-title">a</span> <span class="hljs-symbol">:</span></span> Nat := f (f a)

    <span class="hljs-keyword">#check</span> fa
    <span class="hljs-keyword">#check</span> ffa
  <span class="hljs-keyword">end</span> Bar

  <span class="hljs-keyword">#check</span> fa
  <span class="hljs-keyword">#check</span> Bar.ffa
<span class="hljs-keyword">end</span> Foo

<span class="hljs-keyword">#check</span> Foo.fa
<span class="hljs-keyword">#check</span> Foo.Bar.ffa

<span class="hljs-keyword">open</span> Foo

<span class="hljs-keyword">#check</span> fa
<span class="hljs-keyword">#check</span> Bar.ffa
</code></pre>
<p>닫힌 이름공간은 심지어 다른 파일일지라도 나중에 다시 열릴 수 있습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">namespace</span> Foo
  <span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span> <span class="hljs-symbol">:</span></span> Nat := <span class="hljs-number">5</span>
  <span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span> <span class="hljs-params">(x : Nat)</span> <span class="hljs-symbol">:</span></span> Nat := x + <span class="hljs-number">7</span>

  <span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-title">a</span> <span class="hljs-symbol">:</span></span> Nat := f a
<span class="hljs-keyword">end</span> Foo

<span class="hljs-keyword">#check</span> Foo.a
<span class="hljs-keyword">#check</span> Foo.f

<span class="hljs-keyword">namespace</span> Foo
  <span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-title">f</span><span class="hljs-title">a</span> <span class="hljs-symbol">:</span></span> Nat := f (f a)
<span class="hljs-keyword">end</span> Foo
</code></pre>
<p>섹션과 마찬가지로 중첩된 이름공간은 그들이 열린 순서대로 닫혀야 합니다. 이름공간과 섹션은 다른 목적을 갖고 일합니다. 이름공간은 데이터를 정리하고 섹션은 정의의 삽입에 대해 변수를 선언합니다. section은 <code class="hljs">set_option</code>과 <code class="hljs">open</code>같이 명령의 범위를 제한하는데 유용합니다.</p>
<p>하지만 여러 관점에서 <code class="hljs">namespace ... end</code>블록은 <code class="hljs">section ... end</code>블록과 동일하게 동작합니다. 특히, 이름공간 안에서 <code class="hljs">variable</code> 명령을 사용한다면 그것의 범위는 이름공간으로 제한될 것입니다. 마찬가지로 여러분이 이름공간 내에서 <code class="hljs">open</code> 명령을 사용한다면 그것의 효과는 이름공간이 닫힐 때 사라질 것 입니다.</p>
<h2><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/dependent_type_theory.html#what-makes-dependent-type-theory-dependent" id="what-makes-dependent-type-theory-dependent">무엇이 의존 유형론을 의존적이게 만드는가?</a></h2>
<p>간단한 설명은 유형이 매개변수에 의존할 수 있다는 겁니다. 여러분은 이것에 대한 멋진 예제를 보았습니다. 유형  <code class="hljs">List α</code> 는 인수 <code class="hljs">α</code>에 의존합니다. 여기서  <code class="hljs">List Nat</code>과 <code class="hljs">List Bool</code>을 구분하는 것은 이 의존입니다. 또 다른 예시로 유형 <code class="hljs">Vector α n</code>을 고려해보세요. 이 벡터의 유형은 길이 <code class="hljs">n</code>인 <code class="hljs">α</code>를 원소로 하는 리스트입니다. 이 유형은 <em>두</em> 매개변수에 의존합니다. 하나는 벡터의 원소의 유형 (<code class="hljs">α : Type</code>)이고 또 다른 하나는 벡터의 길이<code class="hljs">n : Nat</code>입니다.</p>
<p>여러분이 리스트의 머리에 새 원소를 삽입하는 함수 <code class="hljs">cons</code>를 만들기 원한다 해봅시다. <code class="hljs">cons</code>는 어떤 유형을 가져야 할까요? 이러한 함수는 <em>polymorphic</em>입니다. 여러분은 <code class="hljs">cons</code>는  <code class="hljs">Nat</code>, <code class="hljs">Bool</code> 혹은 임의의 유형  <code class="hljs">α</code>에 대해 동일한 방식으로 동작해야 한다고 기대합니다. 그래서 <code class="hljs">cons</code>의 첫번째 인수의 유형으로 임의의 유형 <code class="hljs">α</code>를 받아들이게 하는게 타당합니다. <code class="hljs">cons α</code>는 <code class="hljs">α</code>유형을 원소로 하는 리스트에 대한 삽입 함수입니다. 다시 말하면 모든 <code class="hljs">α</code>에 대해  <code class="hljs">cons α</code>는 원소 <code class="hljs">a : α</code>와 리스트 <code class="hljs">as : List α</code>를 받는 함수입니다.  그리고 새로운 리스트를 반환합니다. 그래서 여러분은  <code class="hljs">cons α a as : List α</code>를 갖습니다.</p>
<p><code class="hljs">cons α</code>가  <code class="hljs">α → List α → List α</code> 유형을 가져야 함은 분명합니다. 그러나  <code class="hljs">cons</code> 는 어떤 유형을 가져야 할까요? 첫 번째 추측은 <code class="hljs">Type → α → list α → list α</code>일지 모릅니다. 그러나 생각해보면 이는 말이 되지 않습니다. 이 식에서 <code class="hljs">α</code>는 어떤 것도 지칭하지 않으므로 <code class="hljs">Type</code> 유형을 인수로 지칭해야 합니다. 다시 말하면 함수의 첫 번째 인수로  <code class="hljs">α : Type</code>으로  <em>가정</em>하면 다음 두 원소의 유형은  <code class="hljs">α</code>와 <code class="hljs">List α</code>가 됩니다. 그래서 이 유형은 첫번째 인수 <code class="hljs">α</code>.에 따라 달라집니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">c</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">s</span> <span class="hljs-params">(α : <span class="hljs-built_in">Type</span>)</span> <span class="hljs-params">(a : α)</span> <span class="hljs-params">(as : List α)</span> <span class="hljs-symbol">:</span></span> List α :=
  List.cons a as

<span class="hljs-keyword">#check</span> cons Nat        <span class="hljs-comment">-- Nat → List Nat → List Nat</span>
<span class="hljs-keyword">#check</span> cons Bool       <span class="hljs-comment">-- Bool → List Bool → List Bool</span>
<span class="hljs-keyword">#check</span> cons            <span class="hljs-comment">-- (α : Type) → α → List α → List α</span>
</code></pre>
<p>이것은 <em>의존적 함수 유형</em> 또는 <em>의존적 방향 유형</em>의 개체입니다. <code class="hljs">α : Type</code>과<code class="hljs">β : α → Type</code>이라면, <code class="hljs">β</code>를 <code class="hljs">α</code>에 대한 유형 족(family)으로 생각할 수 있습니다. 즉, 각각의 <code class="hljs">a : α</code>에 대해 <code class="hljs">β a</code>유형입니다. 이 경우 유형 <code class="hljs">(a : α) → β a</code>는 모든  <code class="hljs">a : α</code>에 대해,  <code class="hljs">f a</code> 가  <code class="hljs">β a</code>의 원소라는 성질로 <code class="hljs">f</code> 함수의 유형을 지칭합니다. 다시 말하자면 <code class="hljs">f</code>에 의해 반환되는 값의 유형은 그것의 입력에 의존합니다.</p>
<p><code class="hljs">(a : α) → β</code>는  모든 식  <code class="hljs">β : Type</code>에 대해 성립하는 것을 주목하세요. <code class="hljs">β</code>의 값이 <code class="hljs">a</code>에 의존할 때(예를 들어 앞 단락에서 식 <code class="hljs">β a</code>처럼), <code class="hljs">(a : α) → β</code>는 의존적 함수 유형을 나타냅니다.  <code class="hljs">β</code>가  <code class="hljs">a</code>에 의존하지 않을 때, <code class="hljs">(a : α) → β</code>는 유형 <code class="hljs">α → β</code>유형과 다르지 않습니다. 물론, 종속 유형론에서(그리고 Lean에서) <code class="hljs">α → β</code>는 <code class="hljs">β</code>가 <code class="hljs">a</code>에 의존하지 않을 때 <code class="hljs">(a : α) → β</code>에 대한 표기일 뿐입니다.</p>
<p>리스트의 예로 돌아가서 여러분은 다음 <code class="hljs">List</code> 함수의 유형을 검사하기 위해 <code class="hljs">#check</code> 명령을 사용할 수 있습니다.  <code class="hljs">@</code> 기호와 소괄호와 중괄호 사이의 차이는 곧 설명할 것입니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> @List.cons    <span class="hljs-comment">-- {α : Type u_1} → α → List α → List α</span>
<span class="hljs-keyword">#check</span> @List.nil     <span class="hljs-comment">-- {α : Type u_1} → List α</span>
<span class="hljs-keyword">#check</span> @List.length  <span class="hljs-comment">-- {α : Type u_1} → List α → Nat</span>
<span class="hljs-keyword">#check</span> @List.append  <span class="hljs-comment">-- {α : Type u_1} → List α → List α → List α</span>
</code></pre>
<p>의존적 함수 유형 <code class="hljs">(a : α) → β a</code>는 함수의 유형 <code class="hljs">α → β</code>의 개념을 <code class="hljs">β</code>가 <code class="hljs">α</code>에 종속적이라고 함으로써 일반화한 것처럼 의존적 카테시안 곱 유형은 <code class="hljs">(a : α) × β a</code>는 카테시안 곱  <code class="hljs">α × β</code>를 같은 방식으로 일반화합니다. 의존적 곱은 <em>sigma</em>유형이라고 불립니다. 그리고 여러분은 그것을 <code class="hljs">Σ a : α, β a</code>처럼 쓸 수 있습니다. 여러분은 <code class="hljs">⟨a, b⟩</code> 또는 <code class="hljs">Sigma.mk a b</code>를 종속적 쌍을 만드는데 쓸 수 있습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">universe</span> u v

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span> <span class="hljs-params">(α : <span class="hljs-built_in">Type</span> u)</span> <span class="hljs-params">(β : α → <span class="hljs-built_in">Type</span> v)</span> <span class="hljs-params">(a : α)</span> <span class="hljs-params">(b : β a)</span> <span class="hljs-symbol">:</span></span> (a : α) × β a :=
  ⟨a, b⟩

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">g</span> <span class="hljs-params">(α : <span class="hljs-built_in">Type</span> u)</span> <span class="hljs-params">(β : α → <span class="hljs-built_in">Type</span> v)</span> <span class="hljs-params">(a : α)</span> <span class="hljs-params">(b : β a)</span> <span class="hljs-symbol">:</span></span> Σ a : α, β a :=
  Sigma.mk a b

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">h1</span> <span class="hljs-params">(x : Nat)</span> <span class="hljs-symbol">:</span></span> Nat :=
  (f <span class="hljs-built_in">Type</span> (<span class="hljs-keyword">fun</span> α =&gt; α) Nat x).<span class="hljs-number">2</span>

<span class="hljs-keyword">#eval</span> h1 <span class="hljs-number">5</span> <span class="hljs-comment">-- 5</span>

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">h2</span> <span class="hljs-params">(x : Nat)</span> <span class="hljs-symbol">:</span></span> Nat :=
  (g <span class="hljs-built_in">Type</span> (<span class="hljs-keyword">fun</span> α =&gt; α) Nat x).<span class="hljs-number">2</span>

<span class="hljs-keyword">#eval</span> h2 <span class="hljs-number">5</span> <span class="hljs-comment">-- 5</span>
</code></pre>
<p>위 함수  <code class="hljs">f</code>와 <code class="hljs">g</code>는 같은 함수를 지칭합니다.</p>
<h2><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/dependent_type_theory.html#a-name_implicit_argsaimplicit-arguments" id="a-name_implicit_argsaimplicit-arguments"></a><a name="_implicit_args"></a>암시적 인자(Implicit Arguments)</h2>
<p>우리가 리스트의 구현을 다음과 같이 했다고 가정합시다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="숨겨진 선 보이기" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="boring"><span class="hljs-keyword">universe</span> u
</span><span class="boring"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">L</span><span class="hljs-title">s</span><span class="hljs-title">t</span> <span class="hljs-params">(α : <span class="hljs-built_in">Type</span> u)</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Type</span> u := List α
</span><span class="boring"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">L</span><span class="hljs-title">s</span><span class="hljs-title">t</span>.<span class="hljs-title">c</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">s</span> <span class="hljs-params">(α : <span class="hljs-built_in">Type</span> u)</span> <span class="hljs-params">(a : α)</span> <span class="hljs-params">(as : Lst α)</span> <span class="hljs-symbol">:</span></span> Lst α := List.cons a as
</span><span class="boring"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">L</span><span class="hljs-title">s</span><span class="hljs-title">t</span>.<span class="hljs-title">n</span><span class="hljs-title">i</span><span class="hljs-title">l</span> <span class="hljs-params">(α : <span class="hljs-built_in">Type</span> u)</span> <span class="hljs-symbol">:</span></span> Lst α := List.nil
</span><span class="boring"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">L</span><span class="hljs-title">s</span><span class="hljs-title">t</span>.<span class="hljs-title">a</span><span class="hljs-title">p</span><span class="hljs-title">p</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">d</span> <span class="hljs-params">(α : <span class="hljs-built_in">Type</span> u)</span> <span class="hljs-params">(as bs : Lst α)</span> <span class="hljs-symbol">:</span></span> Lst α := List.append as bs
</span><span class="hljs-keyword">#check</span> Lst          <span class="hljs-comment">-- Type u_1 → Type u_1</span>
<span class="hljs-keyword">#check</span> Lst.cons     <span class="hljs-comment">-- (α : Type u_1) → α → Lst α → Lst α</span>
<span class="hljs-keyword">#check</span> Lst.nil      <span class="hljs-comment">-- (α : Type u_1) → Lst α</span>
<span class="hljs-keyword">#check</span> Lst.append   <span class="hljs-comment">-- (α : Type u_1) → Lst α → Lst α → Lst α</span>
</code></pre>
<p>그럼 여러분은  <code class="hljs">Nat</code>의 리스트를 다음과 같이 생성할 수 있습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="숨겨진 선 보이기" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="boring"><span class="hljs-keyword">universe</span> u
</span><span class="boring"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">L</span><span class="hljs-title">s</span><span class="hljs-title">t</span> <span class="hljs-params">(α : <span class="hljs-built_in">Type</span> u)</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Type</span> u := List α
</span><span class="boring"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">L</span><span class="hljs-title">s</span><span class="hljs-title">t</span>.<span class="hljs-title">c</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">s</span> <span class="hljs-params">(α : <span class="hljs-built_in">Type</span> u)</span> <span class="hljs-params">(a : α)</span> <span class="hljs-params">(as : Lst α)</span> <span class="hljs-symbol">:</span></span> Lst α := List.cons a as
</span><span class="boring"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">L</span><span class="hljs-title">s</span><span class="hljs-title">t</span>.<span class="hljs-title">n</span><span class="hljs-title">i</span><span class="hljs-title">l</span> <span class="hljs-params">(α : <span class="hljs-built_in">Type</span> u)</span> <span class="hljs-symbol">:</span></span> Lst α := List.nil
</span><span class="boring"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">L</span><span class="hljs-title">s</span><span class="hljs-title">t</span>.<span class="hljs-title">a</span><span class="hljs-title">p</span><span class="hljs-title">p</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">d</span> <span class="hljs-params">(α : <span class="hljs-built_in">Type</span> u)</span> <span class="hljs-params">(as bs : Lst α)</span> <span class="hljs-symbol">:</span></span> Lst α := List.append as bs
</span><span class="boring"><span class="hljs-keyword">#check</span> Lst          <span class="hljs-comment">-- Type u_1 → Type u_1</span>
</span><span class="boring"><span class="hljs-keyword">#check</span> Lst.cons     <span class="hljs-comment">-- (α : Type u_1) → α → Lst α → Lst α</span>
</span><span class="boring"><span class="hljs-keyword">#check</span> Lst.nil      <span class="hljs-comment">-- (α : Type u_1) → Lst α</span>
</span><span class="boring"><span class="hljs-keyword">#check</span> Lst.append   <span class="hljs-comment">-- (α : Type u_1) → Lst α → Lst α → Lst α</span>
</span><span class="hljs-keyword">#check</span> Lst.cons Nat <span class="hljs-number">0</span> (Lst.nil Nat)

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span><span class="hljs-title">s</span> <span class="hljs-symbol">:</span></span> Lst Nat := Lst.nil Nat
<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">b</span><span class="hljs-title">s</span> <span class="hljs-symbol">:</span></span> Lst Nat := Lst.cons Nat <span class="hljs-number">5</span> (Lst.nil Nat)

<span class="hljs-keyword">#check</span> Lst.append Nat as bs
</code></pre>
<p>생성자들이 유형에 대해 다형적이기 때문에, 우리는 유형 <code class="hljs">Nat</code>를 인수로써 반복적으로 삽입해야 합니다. 그러나 이 정보는 중복적입니다. <code class="hljs">Lst.cons Nat 5 (Lst.nil Nat)</code>에서 두번째 인수 <code class="hljs">5</code>가 <code class="hljs">Nat</code> 유형을 가진다는 사실로부터 인수 <code class="hljs">α</code>를 추론할 수 있습니다. 그 식에서 <code class="hljs">Lst.cons</code> 함수의 인수로 전달되었다는 사실로부터 마찬가지로 <code class="hljs">Lst.nil Nat</code>에서 인수를 추론할 수 있습니다. 그리고 <code class="hljs">Lst.cons</code>는  <code class="hljs">Lst α</code> 유형의 원소를 기대합니다.</p>
<p>이는 의존 유형론의 핵심 특징입니다. 항은 많은 정보를 전달하고 종종 그 정보의 몇은  맥락으로부터 추론될 수 있습니다. Lean에서 누군가는 시스템이 자동적으로 정보를 채워넣도록 명시하기 위해 밑줄문자(<code class="hljs">_</code>)를 사용합니다. 이것은 "암시적 인자"라고 합니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="숨겨진 선 보이기" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="boring"><span class="hljs-keyword">universe</span> u
</span><span class="boring"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">L</span><span class="hljs-title">s</span><span class="hljs-title">t</span> <span class="hljs-params">(α : <span class="hljs-built_in">Type</span> u)</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Type</span> u := List α
</span><span class="boring"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">L</span><span class="hljs-title">s</span><span class="hljs-title">t</span>.<span class="hljs-title">c</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">s</span> <span class="hljs-params">(α : <span class="hljs-built_in">Type</span> u)</span> <span class="hljs-params">(a : α)</span> <span class="hljs-params">(as : Lst α)</span> <span class="hljs-symbol">:</span></span> Lst α := List.cons a as
</span><span class="boring"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">L</span><span class="hljs-title">s</span><span class="hljs-title">t</span>.<span class="hljs-title">n</span><span class="hljs-title">i</span><span class="hljs-title">l</span> <span class="hljs-params">(α : <span class="hljs-built_in">Type</span> u)</span> <span class="hljs-symbol">:</span></span> Lst α := List.nil
</span><span class="boring"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">L</span><span class="hljs-title">s</span><span class="hljs-title">t</span>.<span class="hljs-title">a</span><span class="hljs-title">p</span><span class="hljs-title">p</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">d</span> <span class="hljs-params">(α : <span class="hljs-built_in">Type</span> u)</span> <span class="hljs-params">(as bs : Lst α)</span> <span class="hljs-symbol">:</span></span> Lst α := List.append as bs
</span><span class="boring"><span class="hljs-keyword">#check</span> Lst          <span class="hljs-comment">-- Type u_1 → Type u_1</span>
</span><span class="boring"><span class="hljs-keyword">#check</span> Lst.cons     <span class="hljs-comment">-- (α : Type u_1) → α → Lst α → Lst α</span>
</span><span class="boring"><span class="hljs-keyword">#check</span> Lst.nil      <span class="hljs-comment">-- (α : Type u_1) → Lst α</span>
</span><span class="boring"><span class="hljs-keyword">#check</span> Lst.append   <span class="hljs-comment">-- (α : Type u_1) → Lst α → Lst α → Lst α</span>
</span><span class="hljs-keyword">#check</span> Lst.cons _ <span class="hljs-number">0</span> (Lst.nil _)

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span><span class="hljs-title">s</span> <span class="hljs-symbol">:</span></span> Lst Nat := Lst.nil _
<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">b</span><span class="hljs-title">s</span> <span class="hljs-symbol">:</span></span> Lst Nat := Lst.cons _ <span class="hljs-number">5</span> (Lst.nil _)

<span class="hljs-keyword">#check</span> Lst.append _ as bs
</code></pre>
<p>그래도 여전히 이 밑줄문자를 치는 것은 번거롭습니다. 함수가 일반적으로 맥락으로부터 추론할 수 있는 인수를 받을 때, Lean은 여러분이 이런 인수가 암시적이어야 함을 명시하도록 기본적으로 허용합니다. 이것은 다음과 같이 인수를 중괄호 안에 두는 것으로 할 수 있습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">universe</span> u
<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">L</span><span class="hljs-title">s</span><span class="hljs-title">t</span> <span class="hljs-params">(α : <span class="hljs-built_in">Type</span> u)</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Type</span> u := List α

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">L</span><span class="hljs-title">s</span><span class="hljs-title">t</span>.<span class="hljs-title">c</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">s</span> <span class="hljs-params">{α : <span class="hljs-built_in">Type</span> u}</span> <span class="hljs-params">(a : α)</span> <span class="hljs-params">(as : Lst α)</span> <span class="hljs-symbol">:</span></span> Lst α := List.cons a as
<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">L</span><span class="hljs-title">s</span><span class="hljs-title">t</span>.<span class="hljs-title">n</span><span class="hljs-title">i</span><span class="hljs-title">l</span> <span class="hljs-params">{α : <span class="hljs-built_in">Type</span> u}</span> <span class="hljs-symbol">:</span></span> Lst α := List.nil
<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">L</span><span class="hljs-title">s</span><span class="hljs-title">t</span>.<span class="hljs-title">a</span><span class="hljs-title">p</span><span class="hljs-title">p</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">d</span> <span class="hljs-params">{α : <span class="hljs-built_in">Type</span> u}</span> <span class="hljs-params">(as bs : Lst α)</span> <span class="hljs-symbol">:</span></span> Lst α := List.append as bs

<span class="hljs-keyword">#check</span> Lst.cons <span class="hljs-number">0</span> Lst.nil

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span><span class="hljs-title">s</span> <span class="hljs-symbol">:</span></span> Lst Nat := Lst.nil
<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">b</span><span class="hljs-title">s</span> <span class="hljs-symbol">:</span></span> Lst Nat := Lst.cons <span class="hljs-number">5</span> Lst.nil

<span class="hljs-keyword">#check</span> Lst.append as bs
</code></pre>
<p>바뀐 것이라곤 변수 선언에서 <code class="hljs">α : Type u</code> 주위의 괄호뿐입니다. 우리는 함수 정의에서도 이 기능을 쓸 수 있습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">universe</span> u
<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">i</span><span class="hljs-title">d</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">t</span> <span class="hljs-params">{α : <span class="hljs-built_in">Type</span> u}</span> <span class="hljs-params">(x : α)</span> <span class="hljs-symbol">:</span></span>= x

<span class="hljs-keyword">#check</span> ident         <span class="hljs-comment">-- ?m → ?m</span>
<span class="hljs-keyword">#check</span> ident <span class="hljs-number">1</span>       <span class="hljs-comment">-- Nat</span>
<span class="hljs-keyword">#check</span> ident <span class="hljs-string">"hello"</span> <span class="hljs-comment">-- String</span>
<span class="hljs-keyword">#check</span> @ident        <span class="hljs-comment">-- {α : Type u_1} → α → α</span>
</code></pre>
<p>이 첫 인수는 <code class="hljs">ident</code>를 암시적으로 만듭니다. 표기상으로 <code class="hljs">ident</code>가 단순히 임의의 유형의 인수를 받을 수 있는 것처럼 만들어 유형의 명세를 감춥니다. 사실 함수 <code class="hljs">id</code>는 표준 라이브러리에서도 이와 정확히 동일한 방식으로 정의되어 있습니다. 우리는 여기서 이름의 충돌을 방지하기 위해 비관습적인 이름을 선택할 뿐이었습니다.</p>
<p><code class="hljs">variable</code> 명령으로 선언될 때 변수도 암시적으로 구체화될 수 있습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">universe</span> u

<span class="hljs-keyword">section</span>
  <span class="hljs-keyword">variable</span> {α : <span class="hljs-built_in">Type</span> u}
  <span class="hljs-keyword">variable</span> (x : α)
  <span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">i</span><span class="hljs-title">d</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">t</span> <span class="hljs-symbol">:</span></span>= x
<span class="hljs-keyword">end</span>

<span class="hljs-keyword">#check</span> ident
<span class="hljs-keyword">#check</span> ident <span class="hljs-number">4</span>
<span class="hljs-keyword">#check</span> ident <span class="hljs-string">"hello"</span>
</code></pre>
<p><code class="hljs">ident</code>의 이 정의는 여기서 위의 것과 같이 같은 효과를 갖습니다.</p>
<p>Lean은 암시적인 인수를 인스턴스화(instantiating)하는데 아주 복잡한 매커니즘을 가지고 있습니다. 그리고 우리는 함수의 유형과 술어 그리고 심지어 증명을 추론하는데 사용될 수 있음을 볼 것입니다. 이런 "구멍" 또는 "플레이스 홀더"의 인스턴스화 과정은 <em>협력(elaboration)</em>으로 불리기도 합니다. 암시적 인수의 존재는 현재로는 식의 정확한 의미를 고치기에 정보가 불충분함을 의미할 수 있습니다. 다른 맥락에서 다른 의미를 가질 수 있기 때문에 <code class="hljs">id</code> 나 <code class="hljs">List.nil</code> 같은 표현식을 <em>다형적</em>이라 합니다.</p>
<p>누군가는 표현식 <code class="hljs">e</code>의 유형 <code class="hljs">T</code>를 <code class="hljs">(e : T)</code>와 같이 씀으로써 항상 명시할 수 있습니다. 이것은 린의 협력기가 암시적 인수를 해결하려고 시도할 때 <code class="hljs">e</code>의 유형으로 <code class="hljs">T</code>값을 사용하라고 지시합니다. 아래 예제의 쌍의 두 번째에서, 이 메커니즘은 식 <code class="hljs">id</code>와 <code class="hljs">List.nil</code>의 바람직한 유형을 명시하는데 사용됩니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> List.nil               <span class="hljs-comment">-- List ?m</span>
<span class="hljs-keyword">#check</span> id                     <span class="hljs-comment">-- ?m → ?m</span>

<span class="hljs-keyword">#check</span> (List.nil : List Nat)  <span class="hljs-comment">-- List Nat</span>
<span class="hljs-keyword">#check</span> (id : Nat → Nat)       <span class="hljs-comment">-- Nat → Nat</span>
</code></pre>
<p>수치들은 Lean에 매우 많이 있습니다. 그러나 수치 유형이 추론되지 못할 때, 린은 기본적으로 그걸 자연수라고 가정합니다. 그래서 아래 첫 두 <code class="hljs">#check</code>명령에서 표현식은 같은 방식으로 해석됩니다. 반면 세 번째 <code class="hljs">#check</code> 명령은 <code class="hljs">2</code>를 정수로 해석합니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> <span class="hljs-number">2</span>            <span class="hljs-comment">-- Nat</span>
<span class="hljs-keyword">#check</span> (<span class="hljs-number">2</span> : Nat)    <span class="hljs-comment">-- Nat</span>
<span class="hljs-keyword">#check</span> (<span class="hljs-number">2</span> : Int)    <span class="hljs-comment">-- Int</span>
</code></pre>
<p>하지만 때때로 우리는 우리 스스로 함수에 대한 인수가 암시적이도록 선언하는 걸 발견합니다. 그러나 지금 인수를 명시적으로 제공하길 원합니다. 만약 <code class="hljs">foo</code>가 그런 함수라면 <code class="hljs">@foo</code> 표기는 모든 인수가 명시적으로 된 같은 함수를 지칭합니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> @id        <span class="hljs-comment">-- {α : Type u_1} → α → α</span>
<span class="hljs-keyword">#check</span> @id Nat    <span class="hljs-comment">-- Nat → Nat</span>
<span class="hljs-keyword">#check</span> @id Bool   <span class="hljs-comment">-- Bool → Bool</span>

<span class="hljs-keyword">#check</span> @id Nat <span class="hljs-number">1</span>     <span class="hljs-comment">-- Nat</span>
<span class="hljs-keyword">#check</span> @id Bool <span class="hljs-literal">true</span> <span class="hljs-comment">-- Bool</span>
</code></pre>
<p>현재 첫 번째 <code class="hljs">#check</code> 명령은 식별자 <code class="hljs">id</code>의 유형을 어떤 플레이스 홀더도 삽입하지 않고 주는 것을 보세요. 게다가 출력은 첫 번째 인수가 암시적임을 가리킵니다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="https://leanprover.github.io/theorem_proving_in_lean4/introduction.html" class="mobile-nav-chapters previous" title="이전 장" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="https://leanprover.github.io/theorem_proving_in_lean4/propositions_and_proofs.html" class="mobile-nav-chapters next" title="다음 장" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="https://leanprover.github.io/theorem_proving_in_lean4/introduction.html" class="nav-chapters previous" title="이전 장" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="https://leanprover.github.io/theorem_proving_in_lean4/propositions_and_proofs.html" class="nav-chapters next" title="다음 장" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="./Dependent Type Theory - Theorem Proving in Lean 4_files/elasticlunr.min.js.다운로드" type="text/javascript" charset="utf-8"></script>
        <script src="./Dependent Type Theory - Theorem Proving in Lean 4_files/mark.min.js.다운로드" type="text/javascript" charset="utf-8"></script>
        <script src="./Dependent Type Theory - Theorem Proving in Lean 4_files/searcher.js.다운로드" type="text/javascript" charset="utf-8"></script>
        

        <script src="./Dependent Type Theory - Theorem Proving in Lean 4_files/clipboard.min.js.다운로드" type="text/javascript" charset="utf-8"></script>
        <script src="./Dependent Type Theory - Theorem Proving in Lean 4_files/highlight.js.다운로드" type="text/javascript" charset="utf-8"></script>
        <script src="./Dependent Type Theory - Theorem Proving in Lean 4_files/book.js.다운로드" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    

</body></html>