<!DOCTYPE html><!-- saved from url=(0083)https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html -->

<html lang="en" class="js sidebar-visible light"><head><meta http-equiv="content-type" content="text/html; charset=UTF-8"><!-- Book generated using mdBook -->
        
        
        <title>한정기호와 동등성 - 린4로 하는 정리 증명</title><!-- Custom HTML head --><!-- Fonts --><!-- Highlight.js Stylesheets --><!-- Custom theme stylesheets -->
        
        


        
        


        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="rgba(0, 0, 0, 0)">

        
        <link rel="icon" href="https://leanprover.github.io/theorem_proving_in_lean4/favicon.svg">
        
        
        <link rel="shortcut icon" href="https://leanprover.github.io/theorem_proving_in_lean4/favicon.png">
        
        <link rel="stylesheet" href="./Quantifiers and Equality - Theorem Proving in Lean 4_files/variables.css">
        <link rel="stylesheet" href="./Quantifiers and Equality - Theorem Proving in Lean 4_files/general.css">
        <link rel="stylesheet" href="./Quantifiers and Equality - Theorem Proving in Lean 4_files/chrome.css">
        
        <link rel="stylesheet" href="./Quantifiers and Equality - Theorem Proving in Lean 4_files/print.css" media="print">
        

        
        <link rel="stylesheet" href="./Quantifiers and Equality - Theorem Proving in Lean 4_files/font-awesome.css">
        
        <link rel="stylesheet" href="./Quantifiers and Equality - Theorem Proving in Lean 4_files/fonts.css">
        

        
        <link rel="stylesheet" href="./Quantifiers and Equality - Theorem Proving in Lean 4_files/highlight.css">
        <link rel="stylesheet" href="./Quantifiers and Equality - Theorem Proving in Lean 4_files/tomorrow-night.css" disabled="">
        <link rel="stylesheet" href="./Quantifiers and Equality - Theorem Proving in Lean 4_files/ayu-highlight.css" disabled="">

        
        

        
    </head>
    <body><!-- Provide site root to javascript -->
        
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script><!-- Work around some values being stored in localStorage wrapped in quotes -->

        
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script><!-- Set the theme before any content is loaded, prevents flash -->

        
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script><!-- Hide / unhide sidebar before it is displayed -->

        
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents" aria-hidden="false">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="https://leanprover.github.io/theorem_proving_in_lean4/title_page.html" tabindex="0">린 4로 하는 정리 증명</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/introduction.html" tabindex="0"><strong aria-hidden="true">1.</strong> 소개(Introduction)</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/dependent_type_theory.html" tabindex="0"><strong aria-hidden="true">2.</strong> 의존 유형론(Dependent Type Theory)</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/propositions_and_proofs.html" tabindex="0"><strong aria-hidden="true">3.</strong> 명제와 증명(Propositions and Proofs)</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html" class="active" tabindex="0"><strong aria-hidden="true">4.</strong> 한정기호와 동등성(Quantifiers and Equality)</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/tactics.html" tabindex="0"><strong aria-hidden="true">5.</strong> 전략(Tactics)</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/interacting_with_lean.html" tabindex="0"><strong aria-hidden="true">6.</strong> 린과 상호작용하기(Interacting with Lean)</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/inductive_types.html" tabindex="0"><strong aria-hidden="true">7.</strong> 귀납형(Inductive Types)</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html" tabindex="0"><strong aria-hidden="true">8.</strong> 귀납과 재귀(Induction and Recursion)</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/structures_and_records.html" tabindex="0"><strong aria-hidden="true">9.</strong> 구조체와 레코드(Structures and Records)</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/type_classes.html" tabindex="0"><strong aria-hidden="true">10.</strong> 유형 계층(Type Classes)</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/conv.html" tabindex="0"><strong aria-hidden="true">11.</strong> 전략 모드로 전환(The Conversion Tactic Mode)</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/axioms_and_computation.html" tabindex="0"><strong aria-hidden="true">12.</strong> 공리계와 계산(Axioms and Computation)</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar" style="top: 0px;">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="목차 토글" aria-label="Toggle Table of Contents" aria-controls="sidebar" aria-expanded="true">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="테마 바꾸기" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">밝게(기본)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">녹슨 색</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">검은색</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">짙푸른색</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">짙은 검은색</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="탐색. (단축기: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">린 4로 하는 정리 증명</h1>

                    <div class="right-buttons">
                        
                        <a href="https://leanprover.github.io/theorem_proving_in_lean4/print.html" title="책 인쇄하기" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/leanprover/theorem_proving_in_lean4" title="깃 저장소" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" placeholder="이 책을 찾아보기 ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div><!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                

                
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#quantifiers-and-equality" id="quantifiers-and-equality">한정기호와 동등성</a></h1>
<p>지난 장에서 여러분에게 명제적 연결사를 포함한 문장의 증명을 구성하는 방법을 소개했습니다. 이번 장에서는 우리는 전칭과 존재 한정기호와 동등 관계를 포함한 논리 구축 레퍼토리를 확장합니다.</p>
<h2><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#the-universal-quantifier" id="the-universal-quantifier">전칭 한정기호</a></h2>
<p><code class="hljs">α</code> 가 임의의 유형인지를 보세요, 우리는 <code class="hljs">α</code>에 대해 단항 술어 p를  <code class="hljs">α → Prop</code>형의 대상으로 나타낼 수 있습니다. 이 경우 <code class="hljs">x : α</code>가 주어진다면, <code class="hljs">p x</code>는  <code class="hljs">p</code>가  <code class="hljs">x</code>가 성립한다는 주장을 지칭합니다. 마찬가지로 대상 <code class="hljs">r : α → α → Prop</code>은 <code class="hljs">α</code>에 대한 이항 관계 즉, <code class="hljs">x y : α</code>이 주어진다면 , <code class="hljs">r x y</code>은 <code class="hljs">x</code>가 <code class="hljs">y</code>에 연관된다는 주장을 지칭합니다.</p>
<p>전칭 한정기호 <code class="hljs">∀ x : α, p x</code> 은 "모든 <code class="hljs">x : α</code>에 대해  <code class="hljs">p x</code>"가 성립한다는 주장을 가리켜야 할 것입니다. 명제적 연결사와 마찬가지로 자연 연역에서 "모든"은  도입과 제거 규칙에 지배받습니다. 비공식적으로 도입 규칙은 다음과 같이 말합니다.</p>
<blockquote>
<p>임의의 <code class="hljs">x : α</code>의 상황에서 <code class="hljs">p x</code>의 증명이 주여졌다고 하자, 그러면 우리는 증명 <code class="hljs">∀ x : α, p x</code>을 얻는다.</p>
</blockquote>
<p>제거 규칙은 이와 같이 말합니다.</p>
<blockquote>
<p>증명 <code class="hljs">∀ x : α, p x</code>과 임의의 항 <code class="hljs">t : α</code>이 있다고 하자, 그러면 우리는 <code class="hljs">p t</code>의 증명을 얻는다.</p>
</blockquote>
<p>함의의 경우 때와 같이 유형으로써 명제 해석은 이제 제 역할을 하기 시작했습니다. 의존 화살표 유형에 대한 도입과 소거 규칙을 기억하세요.</p>
<blockquote>
<p> <code class="hljs">β x</code>형의 항 <code class="hljs">t</code> 임의의 <code class="hljs">x : α</code>에 대해서 주어졌다고 해봅시다. 그러면 우리는 c3&gt;(fun x : α =&gt; t) : (x : α) → β x</code>을 갖습니다.</p>
</blockquote>
<p>제거 규칙은 이와 같이 말합니다.</p>
<blockquote>
<p>항 <code class="hljs">s : (x : α) → β x</code>과 임의의 항 <code class="hljs">t : α</code>이 주어졌다고 해봅시다. 그러면 우리는 <code class="hljs">s t : β t</code>을 가집니다.</p>
</blockquote>
<p><code class="hljs">p x</code>는 <code class="hljs">Prop</code>형을 갖는 이 경우에 대해, 우리가  <code class="hljs">(x : α) → β x</code>을 <code class="hljs">∀ x : α, p x</code>으로 대체한다면, 우리는 이것들을 전칭 한정기호를 포함한 증명을 만드는데 옳바른 규칙이라고 읽을 수 있습니다.</p>
<p>그러므로 직관주의 계산법은 의존 화살표 유형을 이처럼 모든-표현식으로 바라봅니다. 만약 <code class="hljs">p</code>가 임의의 표현식이면, <code class="hljs">∀ x : α, p</code>은 그저 <code class="hljs">(x : α) → p</code>에 대한 대체 표현일 뿐입니다. 전자의 생각은  <code class="hljs">p</code>가 명제인 후자의 경우보다 자연스럽습니다. 일반적으로 표현식 <code class="hljs">p</code>는 <code class="hljs">x : α</code>에 의존할 것입니다. 평범한 함수공간의 경우에 대해 우리는 <code class="hljs">α → β</code>을 <code class="hljs">(x : α) → β</code>의 특별한 경우로 해석할 수 있음을 생각해보세요. 이때  <code class="hljs">β</code>는 <code class="hljs">x</code>에 의존하지 않습니다. 마찬가지로 우리는 명제들 사이의 함의 <code class="hljs">p → q</code>를 <code class="hljs">∀ x : p, q</code>의 특별한 경우로써 생각할 수 있습니다. 이때 <code class="hljs">q</code>는 <code class="hljs">x</code>에 의존하지 않습니다.</p>
<p>여기에 유형으로써 명제 대응이 현장에서 어떻게 놓이는지에 대한 예제가 있습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> (α : <span class="hljs-built_in">Type</span>) (p q : α → <span class="hljs-built_in">Prop</span>) : (∀ x : α, p x ∧ q x) → ∀ y : α, p y  :=
  <span class="hljs-keyword">fun</span> h : ∀ x : α, p x ∧ q x =&gt;
  <span class="hljs-keyword">fun</span> y : α =&gt;
  <span class="hljs-built_in">show</span> p y <span class="hljs-built_in">from</span> (h y).left
</code></pre>
<p>기호 규약으로써 우리는 전칭 한정기호에게 가능한 가장 넓은 범위를 줍니다. 그래서 위의 예제에서 가정의 <code class="hljs">x</code>에만 한정사를 제한하도록 괄호가 필요합니다. <code class="hljs">∀ y : α, p y</code>을 증명하는 표준 방법은 임의의 <code class="hljs">y</code>를 받고  <code class="hljs">p y</code>임을 증명하는 것 입니다. 이것은 도입 규칙입니다. 이제 <code class="hljs">h</code>가 <code class="hljs">∀ x : α, p x ∧ q x</code>형을 갖는다고 해봅시다. 그러면 표현식 <code class="hljs">h y</code>는  <code class="hljs">p y ∧ q y</code>형을 갖습니다. 이것은 제거 규칙입니다. 왼쪽의 결합자를 취하는 것은 원하는 결론 <code class="hljs">p y</code>을 줍니다.</p>
<p>표현식들은 구속변수의 이름이 달라지기까지 동등한 것으로 간주된다는 것을 기억하세요. 그럼 예를들어 우리가 같은 변수 <code class="hljs">x</code> 가정과 결론 양쪽에 사용할 수 있어야 합니다. 그리고 증명에서 다른 변수 <code class="hljs">z</code>에 의해 이것이 개체화됩니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> (α : <span class="hljs-built_in">Type</span>) (p q : α → <span class="hljs-built_in">Prop</span>) : (∀ x : α, p x ∧ q x) → ∀ x : α, p x  :=
  <span class="hljs-keyword">fun</span> h : ∀ x : α, p x ∧ q x =&gt;
  <span class="hljs-keyword">fun</span> z : α =&gt;
  <span class="hljs-built_in">show</span> p z <span class="hljs-built_in">from</span> And.left (h z)
</code></pre>
<p>또 다른 예제처럼 여기서 관계 <code class="hljs">r</code>이 추이적이라는 사실을 어떻게 표현할지를 보여줍니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">variable</span> (α : <span class="hljs-built_in">Type</span>) (r : α → α → <span class="hljs-built_in">Prop</span>)
<span class="hljs-keyword">variable</span> (trans_r : ∀ x y z, r x y → r y z → r x z)

<span class="hljs-keyword">variable</span> (a b c : α)
<span class="hljs-keyword">variable</span> (hab : r a b) (hbc : r b c)

<span class="hljs-keyword">#check</span> trans_r    <span class="hljs-comment">-- ∀ (x y z : α), r x y → r y z → r x z</span>
<span class="hljs-keyword">#check</span> trans_r a b c
<span class="hljs-keyword">#check</span> trans_r a b c hab
<span class="hljs-keyword">#check</span> trans_r a b c hab hbc
</code></pre>
<p>무슨 일이 생긴 건지 생각해보세요. 우리가  <code class="hljs">trans_r</code>을 값 <code class="hljs">a b c</code>에 대해 개체화할 때, 우리는 <code class="hljs">r a b → r b c → r a c</code>의 증명을 갖게됩니다. 이를 "가정"  <code class="hljs">hab : r a b</code>에 적용함으로써 우리는 함의 <code class="hljs">r b c → r a c</code>의 증명을 얻습니다. 마침내, 이것을 가정 <code class="hljs">hbc</code>에 적용하는 것으로 결론 <code class="hljs">r a c</code>의 증명을 거둡니다.</p>
<p>이와 같은 상황에서 인자 <code class="hljs">a b c</code>를 제공하는 것은 번거로울 수 있습니다.  그들이 <code class="hljs">hab hbc</code>으로부터 추론될 수 있을 때, 이런 이유로 이런 인자를 암시적으로 만드는 것은 흔합니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">variable</span> (α : <span class="hljs-built_in">Type</span>) (r : α → α → <span class="hljs-built_in">Prop</span>)
<span class="hljs-keyword">variable</span> (trans_r : ∀ {x y z}, r x y → r y z → r x z)

<span class="hljs-keyword">variable</span> (a b c : α)
<span class="hljs-keyword">variable</span> (hab : r a b) (hbc : r b c)

<span class="hljs-keyword">#check</span> trans_r
<span class="hljs-keyword">#check</span> trans_r hab
<span class="hljs-keyword">#check</span> trans_r hab hbc
</code></pre>
<p>이것의 장점은 우리가 간단히 <code class="hljs">trans_r hab hbc</code>을  <code class="hljs">r a c</code>의 증명으로 쓸 수 있다는 것이고,The advantage is that we can simply write <code class="hljs">trans_r hab hbc</code> as a proof of <code class="hljs">r a c</code>. 단점은 린이 표현식 <code class="hljs">trans_r</code>과 <code class="hljs">trans_r hab</code>에서 인자의 유형을 추론하기에 충분한 정보가 없다는 것 입니다. 처음 <code class="hljs">#check</code> 명령의 출력은 <code class="hljs">r ?m.1 ?m.2 → r ?m.2 ?m.3 → r ?m.1 ?m.3</code>입니다. 이들은 여기에서 명시되지 않은 암시적 인자들을 지칭합니다.</p>
<p>이곳은 우리가 어떻게 동등 관계로 초등적인 추론을 하는지 예시를 보여줍니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">variable</span> (α : <span class="hljs-built_in">Type</span>) (r : α → α → <span class="hljs-built_in">Prop</span>)

<span class="hljs-keyword">variable</span> (refl_r : ∀ x, r x x)
<span class="hljs-keyword">variable</span> (symm_r : ∀ {x y}, r x y → r y x)
<span class="hljs-keyword">variable</span> (trans_r : ∀ {x y z}, r x y → r y z → r x z)

<span class="hljs-keyword">example</span> (a b c d : α) (hab : r a b) (hcb : r c b) (hcd : r c d) : r a d :=
  trans_r (trans_r hab (symm_r hcb)) hcd
</code></pre>
<p>전칭 한정기호 사용에 익숙해지기 위해서 여러분은 이 섹션 끝의 연습문제들을 풀어보아야 합니다.</p>
<p>이것은 의존 화살표 유형에 대한 타자 규칙입니다. 특히 그리고 전칭 한정기호는 <code class="hljs">Prop</code> 과 다른 유형들을 구분합니다. 우리가 <code class="hljs">α : Sort i</code>과 <code class="hljs">β : Sort j</code>을 갖고 있다고 가정합시다. 여기서 표현식 <code class="hljs">β</code>는 변수  <code class="hljs">x : α</code>에 의존할 수도 있습니다. 그러면 <code class="hljs">(x : α) → β</code>은 <code class="hljs">Sort (imax i j)</code>의 원소입니다. 여기서 <code class="hljs">imax i j</code>는 <code class="hljs">i</code>와 <code class="hljs">j</code>사이의 최대값이고, <code class="hljs">j</code>가 0이 아니면 0입니다.</p>
<p>아이디어는 다음과 같습니다. 만약 <code class="hljs">j</code>가 <code class="hljs">0</code>이 아니라면 <code class="hljs">(x : α) → β</code>는 <code class="hljs">Sort (max i j)</code>의 원소이다. 다시 말하면, <code class="hljs">α</code>에서 <code class="hljs">β</code>로의 의존 함수 유형이 그것의 첨자가 <code class="hljs">i</code>와 <code class="hljs">j</code> 사이의 최대값인 유형세계에 "산다"입니다. 그러나 <code class="hljs">β</code>가 <code class="hljs">Sort 0</code>형이라고 가정하면 즉, <code class="hljs">Prop</code>의 원소라면 그 경우 <code class="hljs">α</code>가 어느 유형세계에 속하였든 상관없이 <code class="hljs">(x : α) → β</code>도 <code class="hljs">Sort 0</code>의 원소입니다. 다시 말해서, 만약 <code class="hljs">β</code>가 <code class="hljs">α</code>에 의존하는 명제라면 <code class="hljs">∀ x : α, β</code>도 다시 명제인 것입니다. 이것은 데이터보다는 명제의 유형으로써 <code class="hljs">Prop</code>의 해석을 반영했습니다. 그리고 이것이 <code class="hljs">Prop</code>을 <em>impredicative</em>하게 만드는 것입니다.</p>
<p>"술어"라는 말은 20세기로 접어드는 시기에 기초수학의 발전으로부터 유래되었습니다.  이때 푸엥카레와 레셀 같은 논리학자들은 정의되는 바로 그 정의되는 성질을 포함하는 모임에 대해 한정함으로써 성질을 정의할 때 발생하는 집합론적 역설 "악순환(vicious circles)"을 비난했습니다. 만약 <code class="hljs">α</code>가 임의의 유형이면, 우리는  <code class="hljs">α</code>에 대한 모든 술어에 대해 <code class="hljs">α → Prop</code>형을 만들 수 있습니다. (" <code class="hljs">α</code>형의 능력") Prop의 impredicativity는 우리가 <code class="hljs">α → Prop</code>를 한정하는 명제를 세울 수 있음을 의미합니다. 특히, 우리는 <code class="hljs">α</code>에 대한 술어를 <code class="hljs">α</code>에 대한 모든 술어를 한정함으로써 정의할 수 있습니다. 그리고 이게 한때 문제라고 여겼던 순환 유형입니다.</p>
<h2><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#equality" id="equality">동등성</a></h2>
<p>이제 주로 동등 관계라고 하는 린의 라이브러리에 정의된 가장 기초적인 관계 중 하나로 가봅시다. <a href="https://leanprover.github.io/theorem_proving_in_lean4/inductive_types.html">유도형 장</a>에서 우리는 <em>어떻게</em> 동등이 린의 기초적인 논리 프레임워크로부터 정의되는지 설명할 것입니다. 한편, 여기서는 어떻게 그것을 사용할지 설명합니다.</p>
<p>물론 동등의 기초적인 성질은 등가 관계라는 것입니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> Eq.<span class="hljs-built_in">refl</span>    <span class="hljs-comment">-- ∀ (a : ?m.1), a = a</span>
<span class="hljs-keyword">#check</span> Eq.symm    <span class="hljs-comment">-- ?m.2 = ?m.3 → ?m.3 = ?m.2</span>
<span class="hljs-keyword">#check</span> Eq.trans   <span class="hljs-comment">-- ?m.2 = ?m.3 → ?m.3 = ?m.4 → ?m.2 = ?m.4</span>
</code></pre>
<p>우리는 린에게 암시적인 인자를 삽입하지 말라 함으로써 출력을 더 쉽게 읽어들이도록 만들 수 있습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">universe</span> u

<span class="hljs-keyword">#check</span> @Eq.<span class="hljs-built_in">refl</span>.{u}   <span class="hljs-comment">-- ∀ {α : Sort u} (a : α), a = a</span>
<span class="hljs-keyword">#check</span> @Eq.symm.{u}   <span class="hljs-comment">-- ∀ {α : Sort u} {a b : α}, a = b → b = a</span>
<span class="hljs-keyword">#check</span> @Eq.trans.{u}  <span class="hljs-comment">-- ∀ {α : Sort u} {a b c : α}, a = b → b = c → a = c</span>
</code></pre>
<p>접두사 <code class="hljs">.{u}</code>은 린에게 세계변수 <code class="hljs">u</code>로 상수를 개체화하라고 말해줍니다.</p>
<p>따라서, 우리는 이전 섹션에서 동등 관계까지의 예를 특수화 할 수 있습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">variable</span> (α : <span class="hljs-built_in">Type</span>) (a b c d : α)
<span class="hljs-keyword">variable</span> (hab : a = b) (hcb : c = b) (hcd : c = d)

<span class="hljs-keyword">example</span> : a = d :=
  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd
</code></pre>
<p>또 우리는 투영 기호(인덱싱 기호)를 사용할 수 있습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="숨겨진 선 보이기" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="boring"><span class="hljs-keyword">variable</span> (α : <span class="hljs-built_in">Type</span>) (a b c d : α)
</span><span class="boring"><span class="hljs-keyword">variable</span> (hab : a = b) (hcb : c = b) (hcd : c = d)
</span><span class="hljs-keyword">example</span> : a = d := (hab.trans hcb.symm).trans hcd
</code></pre>
<p>대칭성은 보기 보다 더 강력합니다. 직관주의적 계산법의 항은 계산적인 해석을 갖고 논리 프레임워크는 공통 환원된 항을 같은 것으로 다룬는 것을 기억하세요. 결과적으로 어떤 비직관적인 항등식들이 대칭성으로부터 증명됩니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">variable</span> (α β : <span class="hljs-built_in">Type</span>)

<span class="hljs-keyword">example</span> (f : α → β) (a : α) : (<span class="hljs-keyword">fun</span> x =&gt; f x) a = f a := Eq.<span class="hljs-built_in">refl</span> _
<span class="hljs-keyword">example</span> (a : α) (b : α) : (a, b).<span class="hljs-number">1</span> = a := Eq.<span class="hljs-built_in">refl</span> _
<span class="hljs-keyword">example</span> : <span class="hljs-number">2</span> + <span class="hljs-number">3</span> = <span class="hljs-number">5</span> := Eq.<span class="hljs-built_in">refl</span> _
</code></pre>
<p>프레임워크의 이 특징은 너무 중요해서 라이브러리가 <code class="hljs">Eq.refl _</code>에 대한 기호 <code class="hljs">rfl</code>을 정의합니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="숨겨진 선 보이기" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="boring"><span class="hljs-keyword">variable</span> (α β : <span class="hljs-built_in">Type</span>)
</span><span class="hljs-keyword">example</span> (f : α → β) (a : α) : (<span class="hljs-keyword">fun</span> x =&gt; f x) a = f a := <span class="hljs-built_in">rfl</span>
<span class="hljs-keyword">example</span> (a : α) (b : α) : (a, b).<span class="hljs-number">1</span> = a := <span class="hljs-built_in">rfl</span>
<span class="hljs-keyword">example</span> : <span class="hljs-number">2</span> + <span class="hljs-number">3</span> = <span class="hljs-number">5</span> := <span class="hljs-built_in">rfl</span>
</code></pre>
<p>하지만 동등은 등가 관계 그 이상입니다. 우리가  같은 표현식들을 진리값을 바꾸지 않고 대체할 수 있다는 점에서 등가에 대한 모든 주장은 중요한 성질이 있습니다. 즉, <code class="hljs">h1 : a = b</code>과 <code class="hljs">h2 : p a</code>에 대해 <code class="hljs">p b</code>에 대한 증명을 <code class="hljs">Eq.subst h1 h2</code>과 같은 대체를 사용하여 만들 수 있습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> (α : <span class="hljs-built_in">Type</span>) (a b : α) (p : α → <span class="hljs-built_in">Prop</span>)
        (h1 : a = b) (h2 : p a) : p b :=
  Eq.<span class="hljs-built_in">subst</span> h1 h2

<span class="hljs-keyword">example</span> (α : <span class="hljs-built_in">Type</span>) (a b : α) (p : α → <span class="hljs-built_in">Prop</span>)
    (h1 : a = b) (h2 : p a) : p b :=
  h1 ▸ h2
</code></pre>
<p>두번째 보기에서 삼각형은 <code class="hljs">Eq.subst</code>과 <code class="hljs">Eq.symm</code> 위에 세워진 매크로입니다. 여러분은 이것은 <code class="hljs">\t</code>을 쳐서 쓸 수 있습니다.</p>
<p><code class="hljs">Eq.subst</code>의 규칙은 더 명백한 대체를 수행하는 다음의 부가적인 규칙을 정의하는데 사용됩니다. 이들은 응용 항을 다루기 위해 설계되었습니다. 즉,  <code class="hljs">s t</code> 꼴의 항입니다. 구체적으로 <code class="hljs">congrArg</code>은 인수를 대체하는데 사용될 수 있습니다. <code class="hljs">congrFun</code>은 적용된 항을 대체하는데 사용할 수 있습니다. 그리고 <code class="hljs">congr</code>는 한번에 둘 다 대체하는데 사용될 수 있습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">variable</span> (α : <span class="hljs-built_in">Type</span>)
<span class="hljs-keyword">variable</span> (a b : α)
<span class="hljs-keyword">variable</span> (f g : α → Nat)
<span class="hljs-keyword">variable</span> (h₁ : a = b)
<span class="hljs-keyword">variable</span> (h₂ : f = g)

<span class="hljs-keyword">example</span> : f a = f b := <span class="hljs-built_in">congrArg</span> f h₁
<span class="hljs-keyword">example</span> : f a = g a := congrFun h₂ a
<span class="hljs-keyword">example</span> : f a = g b := <span class="hljs-built_in">congr</span> h₂ h₁
</code></pre>
<p>린의 라이브러리는 이와 같은 흔한 항등식들을 많이 가지고 있습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">variable</span> (a b c d : Nat)

<span class="hljs-keyword">example</span> : a + <span class="hljs-number">0</span> = a := Nat.add_zero a
<span class="hljs-keyword">example</span> : <span class="hljs-number">0</span> + a = a := Nat.zero_add a
<span class="hljs-keyword">example</span> : a * <span class="hljs-number">1</span> = a := Nat.mul_one a
<span class="hljs-keyword">example</span> : <span class="hljs-number">1</span> * a = a := Nat.one_mul a
<span class="hljs-keyword">example</span> : a + b = b + a := Nat.add_comm a b
<span class="hljs-keyword">example</span> : a + b + c = a + (b + c) := Nat.add_assoc a b c
<span class="hljs-keyword">example</span> : a * b = b * a := Nat.mul_comm a b
<span class="hljs-keyword">example</span> : a * b * c = a * (b * c) := Nat.mul_assoc a b c
<span class="hljs-keyword">example</span> : a * (b + c) = a * b + a * c := Nat.mul_add a b c
<span class="hljs-keyword">example</span> : a * (b + c) = a * b + a * c := Nat.left_distrib a b c
<span class="hljs-keyword">example</span> : (a + b) * c = a * c + b * c := Nat.add_mul a b c
<span class="hljs-keyword">example</span> : (a + b) * c = a * c + b * c := Nat.right_distrib a b c
</code></pre>
<p><code class="hljs">Nat.mul_add</code>과 <code class="hljs">Nat.add_mul</code>은 각각 <code class="hljs">Nat.left_distrib</code>과 <code class="hljs">Nat.right_distrib</code>에 대한 별명임을 유의하세요. 위의 성질들은 자연수 (type <code class="hljs">Nat</code>)에 대해 기술되었습니다.</p>
<p>여기 자연수에 대한 대체과 결합성, 교환성, 분배성을 혼합한 계산 예제가 있습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> (x y z : Nat) : x * (y + z) = x * y + x * z := Nat.mul_add x y z
<span class="hljs-keyword">example</span> (x y z : Nat) : (x + y) * z = x * z + y * z := Nat.add_mul x y z
<span class="hljs-keyword">example</span> (x y z : Nat) : x + y + z = x + (y + z) := Nat.add_assoc x y z

<span class="hljs-keyword">example</span> (x y : Nat) : (x + y) * (x + y) = x * x + y * x + x * y + y * y :=
  <span class="hljs-built_in">have</span> h1 : (x + y) * (x + y) = (x + y) * x + (x + y) * y :=
    Nat.mul_add (x + y) x y
  <span class="hljs-built_in">have</span> h2 : (x + y) * (x + y) = x * x + y * x + (x * y + y * y) :=
    (Nat.add_mul x y x) ▸ (Nat.add_mul x y y) ▸ h1
  h2.trans (Nat.add_assoc (x * x + y * x) (x * y) (y * y)).symm
</code></pre>
<p>대체가 일어나는 곳에 대한 맥락을 제공하는 두번째 암시적 인수 <code class="hljs">Eq.subst</code>이 <code class="hljs">α → Prop</code>형을 가지는 것을 보세요. 이 술어를 추론하는 것은 그러므로 <em>고차 통합</em>의 개체를 요구합니다. 완전 일반적으로 고차 통합자가 존재하는지 정하는 문제는 결정 불가능합니다. 그리고 린은 최선을 다해 이 문제에 부정확하지만 근사적인 해를 제공할 수 있습니다. 그러므로 <code class="hljs">Eq.subst</code>은 여러분이 원하는 대로 항상 행하지 못합니다. 매크로 <code class="hljs">h ▸ e</code>은 이 암시적 인자를 계산하는데 더욱 효과적인 경험론을 사용합니다. 그리고 종종 <code class="hljs">Eq.subst</code>의 적용이 실패하는 상황에서 성공적입니다.</p>
<p>방정식적인 추론은 꽤 흔하고 중요하기 때문에 린은 그것을 더 효과적으로 수행하는 다수의 메커니즘을 제공합니다. 다음 섹션은 여러분이 계산 증명을 더 자연스럽고 안목이 있는 방향으로 작성하게 하는 문법을 제공합니다. 그러나 더 중요한 것은 방정식적인 추론은 항 다시쓰기, 단순화, 그리고 여타의 자동화에서도 지원된다는 점 입니다. 항 다시쓰기와 단순화는 다음 섹션에서 간단히 설명합니다. 그러고 나서 다음 장에서 아주 상세하게 다룹니다.</p>
<h2><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#a-name_calc_proofsacalculational-proofs" id="a-name_calc_proofsacalculational-proofs"></a><a name="_calc_proofs"></a>계산 증명</h2>
<p>계산 증명은 동등의 전달성과 같은 기본 원리로 구성된 것을 의미하는 중간 단계의 결과를 연결할 뿐입니다. 린에서 계산 증명은 키워드 <code class="hljs">calc</code>로 시작합니다. 그리고 다음 문법을 갖습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="hljs">calc
  &lt;expr&gt;_0  'op_1'  &lt;expr&gt;_1  ':='  &lt;proof&gt;_1
    '_'     'op_2'  &lt;expr&gt;_2  ':='  &lt;proof&gt;_2
     ...
    '_'     'op_n'  &lt;expr&gt;_n  ':='  &lt;proof&gt;_n

</code></pre>
<p>각  <code class="hljs">&lt;proof&gt;_i</code>는 <code class="hljs">&lt;expr&gt;_{i-1} op_i &lt;expr&gt;_i</code>에 대한 증명입니다.</p>
<p>여기 예제가 있습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">variable</span> (a b c d e : Nat)
<span class="hljs-keyword">variable</span> (h1 : a = b)
<span class="hljs-keyword">variable</span> (h2 : b = c + <span class="hljs-number">1</span>)
<span class="hljs-keyword">variable</span> (h3 : c = d)
<span class="hljs-keyword">variable</span> (h4 : e = <span class="hljs-number">1</span> + d)

<span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">T</span> <span class="hljs-symbol">:</span></span> a = e :=
  <span class="hljs-keyword">calc</span>
    a = b      := h1
    _ = c + <span class="hljs-number">1</span>  := h2
    _ = d + <span class="hljs-number">1</span>  := <span class="hljs-built_in">congrArg</span> Nat.succ h3
    _ = <span class="hljs-number">1</span> + d  := Nat.add_comm d <span class="hljs-number">1</span>
    _ = e      := Eq.symm h4
</code></pre>
<p>증명 작성 스타일은 <code class="hljs">simp</code>와 <code class="hljs">rewrite</code> 전략을 결합해 사용되었을 때 가장 효과적입니다. 이것들은 다음 장에서 상세히 논할 것입니다. 예를 들어, 다시쓰기에 대해서 간략히 <code class="hljs">rw</code>를 쓰는 것으로 위의 증명은 다음과 같이 다시 쓸 수 있습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="숨겨진 선 보이기" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="boring"><span class="hljs-keyword">variable</span> (a b c d e : Nat)
</span><span class="boring"><span class="hljs-keyword">variable</span> (h1 : a = b)
</span><span class="boring"><span class="hljs-keyword">variable</span> (h2 : b = c + <span class="hljs-number">1</span>)
</span><span class="boring"><span class="hljs-keyword">variable</span> (h3 : c = d)
</span><span class="boring"><span class="hljs-keyword">variable</span> (h4 : e = <span class="hljs-number">1</span> + d)
</span><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">T</span> <span class="hljs-symbol">:</span></span> a = e :=
  <span class="hljs-keyword">calc</span>
    a = b      := <span class="hljs-keyword">by</span> <span class="hljs-built_in">rw</span> [h1]
    _ = c + <span class="hljs-number">1</span>  := <span class="hljs-keyword">by</span> <span class="hljs-built_in">rw</span> [h2]
    _ = d + <span class="hljs-number">1</span>  := <span class="hljs-keyword">by</span> <span class="hljs-built_in">rw</span> [h3]
    _ = <span class="hljs-number">1</span> + d  := <span class="hljs-keyword">by</span> <span class="hljs-built_in">rw</span> [Nat.add_comm]
    _ =  e     := <span class="hljs-keyword">by</span> <span class="hljs-built_in">rw</span> [h4]
</code></pre>
<p>본질적으로 <code class="hljs">rw</code> 전략은 주어진 동등성을 목표(혹은 가정, 정리, 복잡한 항이 될 수도 있음)를 "다시 쓰는데" 사용합니다. 그렇게 하면 항등식 <code class="hljs">t = t</code>로 목표를 축소합니다. 전략은 그것을 증명하는데 대칭성을 씁니다.</p>
<p>다시쓰기는 연속적으로 쓸 수 있습니다. 따라서 위의 증명은 이와 같이 더 짧아질 수 있습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="숨겨진 선 보이기" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="boring"><span class="hljs-keyword">variable</span> (a b c d e : Nat)
</span><span class="boring"><span class="hljs-keyword">variable</span> (h1 : a = b)
</span><span class="boring"><span class="hljs-keyword">variable</span> (h2 : b = c + <span class="hljs-number">1</span>)
</span><span class="boring"><span class="hljs-keyword">variable</span> (h3 : c = d)
</span><span class="boring"><span class="hljs-keyword">variable</span> (h4 : e = <span class="hljs-number">1</span> + d)
</span><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">T</span> <span class="hljs-symbol">:</span></span> a = e :=
  <span class="hljs-keyword">calc</span>
    a = d + <span class="hljs-number">1</span>  := <span class="hljs-keyword">by</span> <span class="hljs-built_in">rw</span> [h1, h2, h3]
    _ = <span class="hljs-number">1</span> + d  := <span class="hljs-keyword">by</span> <span class="hljs-built_in">rw</span> [Nat.add_comm]
    _ =  e     := <span class="hljs-keyword">by</span> <span class="hljs-built_in">rw</span> [h4]
</code></pre>
<p>심지어 이렇게도 됩니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="숨겨진 선 보이기" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="boring"><span class="hljs-keyword">variable</span> (a b c d e : Nat)
</span><span class="boring"><span class="hljs-keyword">variable</span> (h1 : a = b)
</span><span class="boring"><span class="hljs-keyword">variable</span> (h2 : b = c + <span class="hljs-number">1</span>)
</span><span class="boring"><span class="hljs-keyword">variable</span> (h3 : c = d)
</span><span class="boring"><span class="hljs-keyword">variable</span> (h4 : e = <span class="hljs-number">1</span> + d)
</span><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">T</span> <span class="hljs-symbol">:</span></span> a = e :=
  <span class="hljs-keyword">by</span> <span class="hljs-built_in">rw</span> [h1, h2, h3, Nat.add_comm, h4]
</code></pre>
<p>대신 <code class="hljs">simp</code> 전략은 주어진 항등식들을 그들이 항에 적용되는 어느 곳이든 임의의 순서대로 반복적으로 사용하여 목표를 다시 씁니다. 또 이것은 시스템에서 전에 선언된 적 있는 다른 규칙을 사용합니다.그리고 무한 루프를 현명하게 피하면서 교환성을 사용합니다. 결론적으로 다음과 같이 정리를 증명할 수도 있습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="숨겨진 선 보이기" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="boring"><span class="hljs-keyword">variable</span> (a b c d e : Nat)
</span><span class="boring"><span class="hljs-keyword">variable</span> (h1 : a = b)
</span><span class="boring"><span class="hljs-keyword">variable</span> (h2 : b = c + <span class="hljs-number">1</span>)
</span><span class="boring"><span class="hljs-keyword">variable</span> (h3 : c = d)
</span><span class="boring"><span class="hljs-keyword">variable</span> (h4 : e = <span class="hljs-number">1</span> + d)
</span><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">T</span> <span class="hljs-symbol">:</span></span> a = e :=
  <span class="hljs-keyword">by</span> <span class="hljs-built_in">simp</span> [h1, h2, h3, Nat.add_comm, h4]
</code></pre>
<p>다음 장에서 <code class="hljs">rw</code>와 <code class="hljs">simp</code>의 변형을 다룰 것입니다.</p>
<p><code class="hljs">calc</code> 명령은 전달성의 몇몇 형태를 지원하는 어떤 관계에 대해서 설정될 수 있습니다. 심지어 이것은 다른 관계와 혼합될 수 있습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> (a b c d : Nat) (h1 : a = b) (h2 : b ≤ c) (h3 : c + <span class="hljs-number">1</span> &lt; d) : a &lt; d :=
  <span class="hljs-keyword">calc</span>
    a = b     := h1
    _ &lt; b + <span class="hljs-number">1</span> := Nat.lt_succ_self b
    _ ≤ c + <span class="hljs-number">1</span> := Nat.succ_le_succ h2
    _ &lt; d     := h3
</code></pre>
<p><code class="hljs">calc</code>를 통해서 우리는 지난 섹션에서 증명을 더 자연스럽고 안목있는 방식으로 작성할 수 있었습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> (x y : Nat) : (x + y) * (x + y) = x * x + y * x + x * y + y * y :=
  <span class="hljs-keyword">calc</span>
    (x + y) * (x + y) = (x + y) * x + (x + y) * y  := <span class="hljs-keyword">by</span> <span class="hljs-built_in">rw</span> [Nat.mul_add]
        _ = x * x + y * x + (x + y) * y            := <span class="hljs-keyword">by</span> <span class="hljs-built_in">rw</span> [Nat.add_mul]
        _ = x * x + y * x + (x * y + y * y)        := <span class="hljs-keyword">by</span> <span class="hljs-built_in">rw</span> [Nat.add_mul]
        _ = x * x + y * x + x * y + y * y          := <span class="hljs-keyword">by</span> <span class="hljs-built_in">rw</span> [←Nat.add_assoc]
</code></pre>
<p><code class="hljs">Nat.add_assoc</code> 앞의 왼쪽 화살표는 항등식을 반대 방향으로 사용해 다시쓰라고 말합니다. (여러분은 이것을 <code class="hljs">\l</code>을 치거나 아스키 형식 <code class="hljs">&lt;-</code>을 사용할 수 있습니다.) 우리가 간결함을 추구한다면 <code class="hljs">rw</code>과<code class="hljs">simp</code>이 알아서 처리해 줄 것입니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> (x y : Nat) : (x + y) * (x + y) = x * x + y * x + x * y + y * y :=
  <span class="hljs-keyword">by</span> <span class="hljs-built_in">rw</span> [Nat.mul_add, Nat.add_mul, Nat.add_mul, ←Nat.add_assoc]

<span class="hljs-keyword">example</span> (x y : Nat) : (x + y) * (x + y) = x * x + y * x + x * y + y * y :=
  <span class="hljs-keyword">by</span> <span class="hljs-built_in">simp</span> [Nat.mul_add, Nat.add_mul, Nat.add_assoc, Nat.add_left_comm]
</code></pre>
<h2><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#the-existential-quantifier" id="the-existential-quantifier">존재 한정기호</a></h2>
<p>마지막으로 <code class="hljs">exists x : α, p x</code>나 <code class="hljs">∃ x : α, p x</code>으로 쓸 수 있는 존재 한정기호를 고려해봅시다. 두 버전 다 린의 라이브러리에 정의된 길고 장황한 표현식 <code class="hljs">Exists (fun x : α =&gt; p x)</code>을 위한 기호적으로 편리한 약어입니다.</p>
<p>지금 예상한 대로 라이브러리는 도입 규칙과 소거 규칙 둘 다 가지고 있습니다. 도입 규칙은 직관적입니다. <code class="hljs">∃ x : α, p x</code>을 증명하기 위해 적절한 항 <code class="hljs">t</code>와 <code class="hljs">p t</code>의 증명을 제공하는 것으로 충분합니다. 여기 몇 가지 예제가 있습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> : ∃ x : Nat, x &gt; <span class="hljs-number">0</span> :=
  <span class="hljs-built_in">have</span> h : <span class="hljs-number">1</span> &gt; <span class="hljs-number">0</span> := Nat.zero_lt_succ <span class="hljs-number">0</span>
  Exists.<span class="hljs-built_in">intro</span> <span class="hljs-number">1</span> h

<span class="hljs-keyword">example</span> (x : Nat) (h : x &gt; <span class="hljs-number">0</span>) : ∃ y, y &lt; x :=
  Exists.<span class="hljs-built_in">intro</span> <span class="hljs-number">0</span> h

<span class="hljs-keyword">example</span> (x y z : Nat) (hxy : x &lt; y) (hyz : y &lt; z) : ∃ w, x &lt; w ∧ w &lt; z :=
  Exists.<span class="hljs-built_in">intro</span> y (And.<span class="hljs-built_in">intro</span> hxy hyz)

<span class="hljs-keyword">#check</span> @Exists.<span class="hljs-built_in">intro</span>
</code></pre>
<p>우리는 맥락으로부터 형이 명백한 경우 익명 생성자 기호 <code class="hljs">⟨t, h⟩</code>을 <code class="hljs">Exists.intro t h</code>에 대해 사용할 수 있습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> : ∃ x : Nat, x &gt; <span class="hljs-number">0</span> :=
  <span class="hljs-built_in">have</span> h : <span class="hljs-number">1</span> &gt; <span class="hljs-number">0</span> := Nat.zero_lt_succ <span class="hljs-number">0</span>
  ⟨<span class="hljs-number">1</span>, h⟩

<span class="hljs-keyword">example</span> (x : Nat) (h : x &gt; <span class="hljs-number">0</span>) : ∃ y, y &lt; x :=
  ⟨<span class="hljs-number">0</span>, h⟩

<span class="hljs-keyword">example</span> (x y z : Nat) (hxy : x &lt; y) (hyz : y &lt; z) : ∃ w, x &lt; w ∧ w &lt; z :=
  ⟨y, hxy, hyz⟩
</code></pre>
<p><code class="hljs">Exists.intro</code>은 암시적인자를 가지고 있음을 유의하세요. 린은 결론 <code class="hljs">∃ x, p x</code>에서 술어 <code class="hljs">p : α → Prop</code>를 추론해야만 합니다. 이것은 명백한 문제가 아닙니다. 예를 들어 우리가 have <code class="hljs">hg : g 0 0 = 0</code>를 갖고 있고 <code class="hljs">Exists.intro 0 hg</code>을 썼다면 정리  <code class="hljs">∃ x, g x x = x</code>, <code class="hljs">∃ x, g x x = 0</code>, <code class="hljs">∃ x, g x 0 = x</code> 등에 대응하는 술어 <code class="hljs">p</code>에 대해 수없이 많은 가능한 값이 존재합니다. 린은 어떤 것이 적절한 지 추론하는데 맥락을 사용합니다. 이것은 다음 예제에서 보여주고 있습니다. 여기서 암시적 인자를 보여주는데 린의 깔끔한 출력을 사용하도록 <code class="hljs">pp.explicit</code> 옵션을 참으로 설정하였습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">variable</span> (g : Nat → Nat → Nat)
<span class="hljs-keyword">variable</span> (hg : g <span class="hljs-number">0</span> <span class="hljs-number">0</span> = <span class="hljs-number">0</span>)

<span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">g</span><span class="hljs-title">e</span><span class="hljs-title">x1</span> <span class="hljs-symbol">:</span></span> ∃ x, g x x = x := ⟨<span class="hljs-number">0</span>, hg⟩
<span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">g</span><span class="hljs-title">e</span><span class="hljs-title">x2</span> <span class="hljs-symbol">:</span></span> ∃ x, g x <span class="hljs-number">0</span> = x := ⟨<span class="hljs-number">0</span>, hg⟩
<span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">g</span><span class="hljs-title">e</span><span class="hljs-title">x3</span> <span class="hljs-symbol">:</span></span> ∃ x, g <span class="hljs-number">0</span> <span class="hljs-number">0</span> = x := ⟨<span class="hljs-number">0</span>, hg⟩
<span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">g</span><span class="hljs-title">e</span><span class="hljs-title">x4</span> <span class="hljs-symbol">:</span></span> ∃ x, g x x = <span class="hljs-number">0</span> := ⟨<span class="hljs-number">0</span>, hg⟩

<span class="hljs-keyword">set_option</span> pp.explicit <span class="hljs-literal">true</span>  <span class="hljs-comment">-- display implicit arguments</span>
<span class="hljs-keyword">#print</span> gex1
<span class="hljs-keyword">#print</span> gex2
<span class="hljs-keyword">#print</span> gex3
<span class="hljs-keyword">#print</span> gex4
</code></pre>
<p>주장의 몸체의 발견을 감추기 때문에 우리는 <code class="hljs">Exists.intro</code>을 정보 감추기 연산으로 볼 수 있습니다. 존재 한정기호 제거 규칙 <code class="hljs">Exists.elim</code>은 정반대 연산을 수행합니다. 임의의 값 <code class="hljs">w</code>에 대해 <code class="hljs">p w</code>로부터 <code class="hljs">q</code>임을 보임으로써 <code class="hljs">∃ x : α, p x</code>으로부터 명제 <code class="hljs">q</code>를 증명하게 해줍니다. 대략 말하자면 <code class="hljs">p x</code>를 만족하는 <code class="hljs">x</code>가 있다는 것을 알기 때문에 이것에 <code class="hljs">w</code>라는 이름을 줄 수 있다는 것입니다. <code class="hljs">q</code>가  <code class="hljs">w</code>를 언급하지 않았다면 <code class="hljs">p w</code>로부터 <code class="hljs">q</code>가 따름을 보이는 것으로 임의의 <code class="hljs">x</code>의 존재함으로부터  <code class="hljs">q</code>를 보이기에 충분합니다. 여기 예제가 있습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">variable</span> (α : <span class="hljs-built_in">Type</span>) (p q : α → <span class="hljs-built_in">Prop</span>)

<span class="hljs-keyword">example</span> (h : ∃ x, p x ∧ q x) : ∃ x, q x ∧ p x :=
  Exists.elim h
    (<span class="hljs-keyword">fun</span> w =&gt;
     <span class="hljs-keyword">fun</span> hw : p w ∧ q w =&gt;
     <span class="hljs-built_in">show</span> ∃ x, q x ∧ p x <span class="hljs-built_in">from</span> ⟨w, hw.right, hw.left⟩)
</code></pre>
<p>존재-제거 규칙과 논리합-제거 규칙을 비교하는것은 도움이 아마 도움이 될 것입니다. 왜냐하면 <code class="hljs">a</code>가 모든 <code class="hljs">α</code>의 요소 범위를 갖기 때문에 명제 <code class="hljs">∃ x : α, p x</code>은 커다란 명제의 분리자  <code class="hljs">p a</code>로 생각할 수 있습니다. 익명 생성자 기호 <code class="hljs">⟨w, hw.right, hw.left⟩</code>가 중첩된 생성자 활용을 간략히 한다는 것을 주목하세요. 우리는 이를 <code class="hljs">⟨w, ⟨hw.right, hw.left⟩⟩</code>로 동등한 의미를 갖게 쓸 수 있습니다.</p>
<p>존재 명제는 의존 유형론 섹션에서 설명했던 시그마 유형과 아주 비슷한 것을 보세요 차이점은 <code class="hljs">a : α</code>와 <code class="hljs">h : p a</code>에 대해서 항 <code class="hljs">Exists.intro a h</code>은 e <code class="hljs">(∃ x : α, p x) : Prop</code> 형을 가지고 <code class="hljs">Sigma.mk a h</code>는 <code class="hljs">(Σ x : α, p x) : Type</code>형을 갖는다는 점입니다.  <code class="hljs">∃</code>과<code class="hljs">Σ</code>의 유사점은 이들이 커리-하워드 동형의 또 다른 개체라는 점입니다.</p>
<p>린은 <code class="hljs">match</code> 표현식이 있는 존재 한정기호를 더 편리하게 제거하는 방법을 제공합니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">variable</span> (α : <span class="hljs-built_in">Type</span>) (p q : α → <span class="hljs-built_in">Prop</span>)

<span class="hljs-keyword">example</span> (h : ∃ x, p x ∧ q x) : ∃ x, q x ∧ p x :=
  <span class="hljs-keyword">match</span> h <span class="hljs-keyword">with</span>
  | ⟨w, hw⟩ =&gt; ⟨w, hw.right, hw.left⟩
</code></pre>
<p><code class="hljs">match</code> 표현식은 복잡한 함수를 정의하는데 편리하고 표현력있는 방식을 제공하는 린의 함수 정의 시스템의 일부분입니다. 한 번 더  커리-하워드 동형은 우리가 증명을 작성하는 데에도 이 메커니즘과 함께 쓰이게 합니다. <code class="hljs">match</code> 구문은 존재 주장 속 성분인 <code class="hljs">w</code>와 <code class="hljs">hw</code>로 '파괴'합니다.  이들은 명제를 증명하기 위해 문장의 몸체에서 사용될 수 있습니다. 우리는 더 명확함을 위해 match에서 사용되는 유형을 나타낼 수 있습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="숨겨진 선 보이기" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="boring"><span class="hljs-keyword">variable</span> (α : <span class="hljs-built_in">Type</span>) (p q : α → <span class="hljs-built_in">Prop</span>)
</span><span class="hljs-keyword">example</span> (h : ∃ x, p x ∧ q x) : ∃ x, q x ∧ p x :=
  <span class="hljs-keyword">match</span> h <span class="hljs-keyword">with</span>
  | ⟨(w : α), (hw : p w ∧ q w)⟩ =&gt; ⟨w, hw.right, hw.left⟩
</code></pre>
<p>심지어 우리는 match 문장을 분해하는 동시에 결합하기 위해 사용할 수 있습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="숨겨진 선 보이기" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="boring"><span class="hljs-keyword">variable</span> (α : <span class="hljs-built_in">Type</span>) (p q : α → <span class="hljs-built_in">Prop</span>)
</span><span class="hljs-keyword">example</span> (h : ∃ x, p x ∧ q x) : ∃ x, q x ∧ p x :=
  <span class="hljs-keyword">match</span> h <span class="hljs-keyword">with</span>
  | ⟨w, hpw, hqw⟩ =&gt; ⟨w, hqw, hpw⟩
</code></pre>
<p>또 린은 패턴-매칭 <code class="hljs">let</code>  표현식을 제공합니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="숨겨진 선 보이기" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="boring"><span class="hljs-keyword">variable</span> (α : <span class="hljs-built_in">Type</span>) (p q : α → <span class="hljs-built_in">Prop</span>)
</span><span class="hljs-keyword">example</span> (h : ∃ x, p x ∧ q x) : ∃ x, q x ∧ p x :=
  <span class="hljs-keyword">let</span> ⟨w, hpw, hqw⟩ := h
  ⟨w, hqw, hpw⟩
</code></pre>
<p>이것은 본질적으로 위의 <code class="hljs">match</code> 생성을 위한 대체 기호일 뿐입니다. 심지어 린은 우리에게 c2&gt;fun</code> 표현식에서 암시적인 <code class="hljs">match</code>를 사용할 수 있게 해줍니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="숨겨진 선 보이기" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="boring"><span class="hljs-keyword">variable</span> (α : <span class="hljs-built_in">Type</span>) (p q : α → <span class="hljs-built_in">Prop</span>)
</span><span class="hljs-keyword">example</span> : (∃ x, p x ∧ q x) → ∃ x, q x ∧ p x :=
  <span class="hljs-keyword">fun</span> ⟨w, hpw, hqw⟩ =&gt; ⟨w, hqw, hpw⟩
</code></pre>
<p> <a href="https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html">유도와 재귀 장</a>에서 더 일반적인 패턴-매칭 생성 개체들의 모든 변형을 볼 겁니다.</p>
<p>다음 예제에서 우리는 <code class="hljs">짝수 a</code>를 <code class="hljs">∃ b, a = 2*b</code>와 같이 정의합니다. 그런 뒤 두 짝수의 합이 짝수임을 보일 것 입니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">_</span><span class="hljs-title">e</span><span class="hljs-title">v</span><span class="hljs-title">e</span><span class="hljs-title">n</span> <span class="hljs-params">(a : Nat)</span> <span class="hljs-symbol">:</span></span>= ∃ b, a = <span class="hljs-number">2</span> * b

<span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">e</span><span class="hljs-title">v</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">_</span><span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">u</span><span class="hljs-title">s</span><span class="hljs-title">_</span><span class="hljs-title">e</span><span class="hljs-title">v</span><span class="hljs-title">e</span><span class="hljs-title">n</span> <span class="hljs-params">(h1 : is_even a)</span> <span class="hljs-params">(h2 : is_even b)</span> <span class="hljs-symbol">:</span></span> is_even (a + b) :=
  Exists.elim h1 (<span class="hljs-keyword">fun</span> w1 (hw1 : a = <span class="hljs-number">2</span> * w1) =&gt;
  Exists.elim h2 (<span class="hljs-keyword">fun</span> w2 (hw2 : b = <span class="hljs-number">2</span> * w2) =&gt;
    Exists.<span class="hljs-built_in">intro</span> (w1 + w2)
      (<span class="hljs-keyword">calc</span>
        a + b = <span class="hljs-number">2</span> * w1 + <span class="hljs-number">2</span> * w2  := <span class="hljs-keyword">by</span> <span class="hljs-built_in">rw</span> [hw1, hw2]
          _   = <span class="hljs-number">2</span>*(w1 + w2)      := <span class="hljs-keyword">by</span> <span class="hljs-built_in">rw</span> [Nat.mul_add])))
</code></pre>
<p>여기서 설명한 다양한 도구-match 구문, 익명 생성자,  <code class="hljs">다시쓰기</code>전략-를 사용하여 다음과 같이 이 증명을 간결하게 쓸 수 있습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="숨겨진 선 보이기" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="boring"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">_</span><span class="hljs-title">e</span><span class="hljs-title">v</span><span class="hljs-title">e</span><span class="hljs-title">n</span> <span class="hljs-params">(a : Nat)</span> <span class="hljs-symbol">:</span></span>= ∃ b, a = <span class="hljs-number">2</span> * b
</span><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">e</span><span class="hljs-title">v</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">_</span><span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">u</span><span class="hljs-title">s</span><span class="hljs-title">_</span><span class="hljs-title">e</span><span class="hljs-title">v</span><span class="hljs-title">e</span><span class="hljs-title">n</span> <span class="hljs-params">(h1 : is_even a)</span> <span class="hljs-params">(h2 : is_even b)</span> <span class="hljs-symbol">:</span></span> is_even (a + b) :=
  <span class="hljs-keyword">match</span> h1, h2 <span class="hljs-keyword">with</span>
  | ⟨w1, hw1⟩, ⟨w2, hw2⟩ =&gt; ⟨w1 + w2, <span class="hljs-keyword">by</span> <span class="hljs-built_in">rw</span> [hw1, hw2, Nat.mul_add]⟩
</code></pre>
<p>직관주의적 "or"은 고전주의의 "or"보다 강한 것처럼 직관주의적 "존재한다"도 고전주의적 "존재한다"보다 강한 의미를 가집니다. 예를 들어, 직관주의적 관점에서 모든 <code class="hljs">x</code>가 <code class="hljs">¬p</code>을 만족하는 경우가 아니라는 것을 아는 것은 <code class="hljs">p</code>를 만족하는 특정 <code class="hljs">x</code>를 갖는 것과 같지 않기 때문에 다음의 함의는 고전적인 추론을 필요로 합니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">open</span> Classical
<span class="hljs-keyword">variable</span> (p : α → <span class="hljs-built_in">Prop</span>)

<span class="hljs-keyword">example</span> (h : ¬ ∀ x, ¬ p x) : ∃ x, p x :=
  byContradiction
    (<span class="hljs-keyword">fun</span> h1 : ¬ ∃ x, p x =&gt;
      <span class="hljs-built_in">have</span> h2 : ∀ x, ¬ p x :=
        <span class="hljs-keyword">fun</span> x =&gt;
        <span class="hljs-keyword">fun</span> h3 : p x =&gt;
        <span class="hljs-built_in">have</span> h4 : ∃ x, p x :=  ⟨x, h3⟩
        <span class="hljs-built_in">show</span> False <span class="hljs-built_in">from</span> h1 h4
      <span class="hljs-built_in">show</span> False <span class="hljs-built_in">from</span> h h2)
</code></pre>
<p>다음은 존재 한정기호를 포함한 몇 가지 흔한 항등식들 입니다. 아래 연습 문제에서 여러분이 할 수 있는 가능한 많이 증명해보길 권합니다. 우리는 또한 어떤 것이 비직관주의적인지 결정하는 것을 여러분에게 맡깁니다. 그러므로 일부는 고전 논리의 형식를 요구합니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">open</span> Classical

<span class="hljs-keyword">variable</span> (α : <span class="hljs-built_in">Type</span>) (p q : α → <span class="hljs-built_in">Prop</span>)
<span class="hljs-keyword">variable</span> (r : <span class="hljs-built_in">Prop</span>)

<span class="hljs-keyword">example</span> : (∃ x : α, r) → r := <span class="hljs-strong">sorry</span>
<span class="hljs-keyword">example</span> (a : α) : r → (∃ x : α, r) := <span class="hljs-strong">sorry</span>
<span class="hljs-keyword">example</span> : (∃ x, p x ∧ r) ↔ (∃ x, p x) ∧ r := <span class="hljs-strong">sorry</span>
<span class="hljs-keyword">example</span> : (∃ x, p x ∨ q x) ↔ (∃ x, p x) ∨ (∃ x, q x) := <span class="hljs-strong">sorry</span>

<span class="hljs-keyword">example</span> : (∀ x, p x) ↔ ¬ (∃ x, ¬ p x) := <span class="hljs-strong">sorry</span>
<span class="hljs-keyword">example</span> : (∃ x, p x) ↔ ¬ (∀ x, ¬ p x) := <span class="hljs-strong">sorry</span>
<span class="hljs-keyword">example</span> : (¬ ∃ x, p x) ↔ (∀ x, ¬ p x) := <span class="hljs-strong">sorry</span>
<span class="hljs-keyword">example</span> : (¬ ∀ x, p x) ↔ (∃ x, ¬ p x) := <span class="hljs-strong">sorry</span>

<span class="hljs-keyword">example</span> : (∀ x, p x → r) ↔ (∃ x, p x) → r := <span class="hljs-strong">sorry</span>
<span class="hljs-keyword">example</span> (a : α) : (∃ x, p x → r) ↔ (∀ x, p x) → r := <span class="hljs-strong">sorry</span>
<span class="hljs-keyword">example</span> (a : α) : (∃ x, r → p x) ↔ (r → ∃ x, p x) := <span class="hljs-strong">sorry</span>
</code></pre>
<p>두 번째 예제와 마지막 두 예제는 <code class="hljs">α</code>형의 한 원소 <code class="hljs">a</code>가 적어도 하나 있다는 가정을 필요로 한다는 것을 유의하세요.</p>
<p>여기 더 어려운 두 문제에 대한 해답이 있습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">open</span> Classical

<span class="hljs-keyword">variable</span> (α : <span class="hljs-built_in">Type</span>) (p q : α → <span class="hljs-built_in">Prop</span>)
<span class="hljs-keyword">variable</span> (a : α)
<span class="hljs-keyword">variable</span> (r : <span class="hljs-built_in">Prop</span>)

<span class="hljs-keyword">example</span> : (∃ x, p x ∨ q x) ↔ (∃ x, p x) ∨ (∃ x, q x) :=
  Iff.<span class="hljs-built_in">intro</span>
    (<span class="hljs-keyword">fun</span> ⟨a, (h1 : p a ∨ q a)⟩ =&gt;
      Or.elim h1
        (<span class="hljs-keyword">fun</span> hpa : p a =&gt; Or.inl ⟨a, hpa⟩)
        (<span class="hljs-keyword">fun</span> hqa : q a =&gt; Or.inr ⟨a, hqa⟩))
    (<span class="hljs-keyword">fun</span> h : (∃ x, p x) ∨ (∃ x, q x) =&gt;
      Or.elim h
        (<span class="hljs-keyword">fun</span> ⟨a, hpa⟩ =&gt; ⟨a, (Or.inl hpa)⟩)
        (<span class="hljs-keyword">fun</span> ⟨a, hqa⟩ =&gt; ⟨a, (Or.inr hqa)⟩))

<span class="hljs-keyword">example</span> : (∃ x, p x → r) ↔ (∀ x, p x) → r :=
  Iff.<span class="hljs-built_in">intro</span>
    (<span class="hljs-keyword">fun</span> ⟨b, (hb : p b → r)⟩ =&gt;
     <span class="hljs-keyword">fun</span> h2 : ∀ x, p x =&gt;
     <span class="hljs-built_in">show</span> r <span class="hljs-built_in">from</span>  hb (h2 b))
    (<span class="hljs-keyword">fun</span> h1 : (∀ x, p x) → r =&gt;
     <span class="hljs-built_in">show</span> ∃ x, p x → r <span class="hljs-built_in">from</span>
       byCases
         (<span class="hljs-keyword">fun</span> hap : ∀ x, p x =&gt; ⟨a, λ h' =&gt; h1 hap⟩)
         (<span class="hljs-keyword">fun</span> hnap : ¬ ∀ x, p x =&gt;
          byContradiction
            (<span class="hljs-keyword">fun</span> hnex : ¬ ∃ x, p x → r =&gt;
              <span class="hljs-built_in">have</span> hap : ∀ x, p x :=
                <span class="hljs-keyword">fun</span> x =&gt;
                byContradiction
                  (<span class="hljs-keyword">fun</span> hnp : ¬ p x =&gt;
                    <span class="hljs-built_in">have</span> hex : ∃ x, p x → r := ⟨x, (<span class="hljs-keyword">fun</span> hp =&gt; absurd hp hnp)⟩
                    <span class="hljs-built_in">show</span> False <span class="hljs-built_in">from</span> hnex hex)
              <span class="hljs-built_in">show</span> False <span class="hljs-built_in">from</span> hnap hap)))
</code></pre>
<h2><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#more-on-the-proof-language" id="more-on-the-proof-language">증명 언어에 대한 자세한 내용</a></h2>
<p>우리는 <code class="hljs">fun</code>과 <code class="hljs">have</code>,<code class="hljs">show</code>와 같은 키워드가 비형식적인 수학적 증명의 구조를 반영하는 형식적 증명 용어를 쓸 수 있게 만든 것을 보았다. 이 섹션에서는 종종 편리한 증명 언어의 몇 가지 추가적인 기능에 대해 설명합니다.</p>
<p>우선, 우리는 익명 "have" 표현식으로 보조 목표의 이름 없이 도입하는데 사용할 수 있습니다. 이렇게 도입된 마지막 표현식을 키워드 <code class="hljs"> this</code>를 사용하여 참조할 수 있습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">variable</span> (f : Nat → Nat)
<span class="hljs-keyword">variable</span> (h : ∀ x : Nat, f x ≤ f (x + <span class="hljs-number">1</span>))

<span class="hljs-keyword">example</span> : f <span class="hljs-number">0</span> ≤ f <span class="hljs-number">3</span> :=
  <span class="hljs-built_in">have</span> : f <span class="hljs-number">0</span> ≤ f <span class="hljs-number">1</span> := h <span class="hljs-number">0</span>
  <span class="hljs-built_in">have</span> : f <span class="hljs-number">0</span> ≤ f <span class="hljs-number">2</span> := Nat.le_trans this (h <span class="hljs-number">1</span>)
  <span class="hljs-built_in">show</span> f <span class="hljs-number">0</span> ≤ f <span class="hljs-number">3</span> <span class="hljs-built_in">from</span> Nat.le_trans this (h <span class="hljs-number">2</span>)
</code></pre>
<p>증명은 종종 한 사실에서 다음 사실로 이동하기 때문에 이것은 많은 이름으로 생기는 혼동을 없애는 데 효과적입니다.</p>
<p>목표가 추론될 수 있을 때, 우리는 <code class="hljs">by assumption</code>을 써 증명을 채우는 대신 린에게 물어볼 수도 있습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="숨겨진 선 보이기" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="boring"><span class="hljs-keyword">variable</span> (f : Nat → Nat)
</span><span class="boring"><span class="hljs-keyword">variable</span> (h : ∀ x : Nat, f x ≤ f (x + <span class="hljs-number">1</span>))
</span><span class="hljs-keyword">example</span> : f <span class="hljs-number">0</span> ≤ f <span class="hljs-number">3</span> :=
  <span class="hljs-built_in">have</span> : f <span class="hljs-number">0</span> ≤ f <span class="hljs-number">1</span> := h <span class="hljs-number">0</span>
  <span class="hljs-built_in">have</span> : f <span class="hljs-number">0</span> ≤ f <span class="hljs-number">2</span> := Nat.le_trans (<span class="hljs-keyword">by</span> <span class="hljs-built_in">assumption</span>) (h <span class="hljs-number">1</span>)
  <span class="hljs-built_in">show</span> f <span class="hljs-number">0</span> ≤ f <span class="hljs-number">3</span> <span class="hljs-built_in">from</span> Nat.le_trans (<span class="hljs-keyword">by</span> <span class="hljs-built_in">assumption</span>) (h <span class="hljs-number">2</span>)
</code></pre>
<p>이것은 린에게 <code class="hljs">assumption</code> 전략을 사용하라고 말합니다. 따라서 이 전략은 현재 상황판에서 적절한 가정을 찾아 목표를 증명합니다. 다음 장에서 <code class="hljs">assumption</code> 전략에 대해 더 배울 예정입니다.</p>
<p>또 우린 린에게 <code class="hljs">‹p›</code>라고 써서 증명 속을 채우도록 린에게 요청할수 있습니다. 여기서 <code class="hljs">p</code>는 명제이고, 그것의 증명은 현재 상황에서 린이 찾기 바라는 것입니다. 여러분은 이런 인용 꺽쇠를 각각 <code class="hljs">\f&lt;</code>과 <code class="hljs">\f&gt;</code>을 사용해서 칠 수 있습니다. "f"는 "프랑스"의 첫머리 글자입니다. 왜냐하면 이 유니코드 기호는 프랑스 인용부호로도 사용되기 때문입니다. 사실 린에서 정의된 기호는 다음과 같습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">notation</span> <span class="hljs-string">"‹"</span> p <span class="hljs-string">"›"</span> =&gt; <span class="hljs-built_in">show</span> p <span class="hljs-keyword">by</span> <span class="hljs-built_in">assumption</span>
</code></pre>
<p>추론될 필요가 있는 가정의 유형은 명백하게 주어져야 하므로 이런 접근법은 <code class="hljs">by assumption</code>을 사용하는 것보다 더 견고합니다. 또 이것은 증명을 더 가독성있게 만듭니다. 여기 더 협력(elaborate)하는 예제들이 있습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">variable</span> (f : Nat → Nat)
<span class="hljs-keyword">variable</span> (h : ∀ x : Nat, f x ≤ f (x + <span class="hljs-number">1</span>))

<span class="hljs-keyword">example</span> : f <span class="hljs-number">0</span> ≥ f <span class="hljs-number">1</span> → f <span class="hljs-number">1</span> ≥ f <span class="hljs-number">2</span> → f <span class="hljs-number">0</span> = f <span class="hljs-number">2</span> :=
  <span class="hljs-keyword">fun</span> _ : f <span class="hljs-number">0</span> ≥ f <span class="hljs-number">1</span> =&gt;
  <span class="hljs-keyword">fun</span> _ : f <span class="hljs-number">1</span> ≥ f <span class="hljs-number">2</span> =&gt;
  <span class="hljs-built_in">have</span> : f <span class="hljs-number">0</span> ≥ f <span class="hljs-number">2</span> := Nat.le_trans ‹f <span class="hljs-number">1</span> ≥ f <span class="hljs-number">2</span>› ‹f <span class="hljs-number">0</span> ≥ f <span class="hljs-number">1</span>›
  <span class="hljs-built_in">have</span> : f <span class="hljs-number">0</span> ≤ f <span class="hljs-number">2</span> := Nat.le_trans (h <span class="hljs-number">0</span>) (h <span class="hljs-number">1</span>)
  <span class="hljs-built_in">show</span> f <span class="hljs-number">0</span> = f <span class="hljs-number">2</span> <span class="hljs-built_in">from</span> Nat.le_antisymm this ‹f <span class="hljs-number">0</span> ≥ f <span class="hljs-number">2</span>›
</code></pre>
<p>여러분은 프랑스 인용부호를 맥락 속에서 익명으로 도입된 것들 뿐만 아니라 <em>어떤 것이든</em> 참조하기 위해 사용될 수 있다는 점을 명심하세요. 그것의 용도는 명제에마 국한되지 않고 약간 이상하지만 데이터에 대해서도 사용됩니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> (n : Nat) : Nat := ‹Nat›
</code></pre>
<p>나중에 우리는 린의 매크로 시스템을 사용해서 증명 언어를 확장하는 방법을 소개합니다.</p>
<h2><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#exercises" id="exercises">연습문제</a></h2>
<ol>
<li>이 등가들을 증명하세요.</li>
</ol>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"> <span class="hljs-keyword">variable</span> (α : <span class="hljs-built_in">Type</span>) (p q : α → <span class="hljs-built_in">Prop</span>)

 <span class="hljs-keyword">example</span> : (∀ x, p x ∧ q x) ↔ (∀ x, p x) ∧ (∀ x, q x) := <span class="hljs-strong">sorry</span>
 <span class="hljs-keyword">example</span> : (∀ x, p x → q x) → (∀ x, p x) → (∀ x, q x) := <span class="hljs-strong">sorry</span>
 <span class="hljs-keyword">example</span> : (∀ x, p x) ∨ (∀ x, q x) → ∀ x, p x ∨ q x := <span class="hljs-strong">sorry</span>
</code></pre>
<p>여러분은 왜 명제의 역이 마지막 예제에서 불가능한지 이해하려고 시도해봐야 합니다.</p>
<ol start="2">
<li>식이 정량화된 변수에 의존하지 않을 때 종종 전칭 한정기호를 식의 바깥 쪽으로 가져올 수 있습니다. 이것들을 증명해 보세요.(이들 두 번째 예제의 한쪽 방향은 고전논리가 필요합니다.)</li>
</ol>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">variable</span> (α : <span class="hljs-built_in">Type</span>) (p q : α → <span class="hljs-built_in">Prop</span>)
<span class="hljs-keyword">variable</span> (r : <span class="hljs-built_in">Prop</span>)

<span class="hljs-keyword">example</span> : α → ((∀ x : α, r) ↔ r) := <span class="hljs-strong">sorry</span>
<span class="hljs-keyword">example</span> : (∀ x, p x ∨ r) ↔ (∀ x, p x) ∨ r := <span class="hljs-strong">sorry</span>
<span class="hljs-keyword">example</span> : (∀ x, r → p x) ↔ (r → ∀ x, p x) := <span class="hljs-strong">sorry</span>
</code></pre>
<ol start="3">
<li>"이발사의 역설"을 고려해보세요. 즉, 그들 자신을 면도하지 않는 남자만 면도해 준다고 주장하는 어떤 마을의 (남자) 이발사의 주장입니다. 이것이 모순임을 증명하세요.</li>
</ol>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">variable</span> (men : <span class="hljs-built_in">Type</span>) (barber : men)
<span class="hljs-keyword">variable</span>  (shaves : men → men → <span class="hljs-built_in">Prop</span>)

<span class="hljs-keyword">example</span> (h : ∀ x : men, shaves barber x ↔ ¬ shaves x x) : False := <span class="hljs-strong">sorry</span>
</code></pre>
<ol start="4">
<li>어떤 매개변수도 없이 <code class="hljs">Prop</code>형의 표현식은 그저 주장일 뿐이라는 걸 기억하세요. 아래의 <code class="hljs">prime</code>과 <code class="hljs">Fermat_prime</code>의 정의를 채우세요. 그리고 주어진 주장의 각각을 생성하세요. 예를 들어, 여러분은 모든 자연수 <code class="hljs">n</code>에 대해 <code class="hljs">n</code>보다 큰 소수가 있다고 주장하여 무한히 많은 소수가 있다고 말할 수 있습니다. 골드바흐의 약한 추측은 5보다 큰 모든 홀수 세 소수의 합으로 표현될 수 있다고 말합니다. 페르마 소수의 정의나 필요하다면 다른 문장들을 찾아보세요.</li>
</ol>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">e</span><span class="hljs-title">v</span><span class="hljs-title">e</span><span class="hljs-title">n</span> <span class="hljs-params">(n : Nat)</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Prop</span> := <span class="hljs-strong">sorry</span>

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">p</span><span class="hljs-title">r</span><span class="hljs-title">i</span><span class="hljs-title">m</span><span class="hljs-title">e</span> <span class="hljs-params">(n : Nat)</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Prop</span> := <span class="hljs-strong">sorry</span>

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">f</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">i</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">l</span><span class="hljs-title">y</span><span class="hljs-title">_</span><span class="hljs-title">m</span><span class="hljs-title">a</span><span class="hljs-title">n</span><span class="hljs-title">y</span><span class="hljs-title">_</span><span class="hljs-title">p</span><span class="hljs-title">r</span><span class="hljs-title">i</span><span class="hljs-title">m</span><span class="hljs-title">e</span><span class="hljs-title">s</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Prop</span> := <span class="hljs-strong">sorry</span>

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">F</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">m</span><span class="hljs-title">a</span><span class="hljs-title">t</span><span class="hljs-title">_</span><span class="hljs-title">p</span><span class="hljs-title">r</span><span class="hljs-title">i</span><span class="hljs-title">m</span><span class="hljs-title">e</span> <span class="hljs-params">(n : Nat)</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Prop</span> := <span class="hljs-strong">sorry</span>

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">f</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">i</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">l</span><span class="hljs-title">y</span><span class="hljs-title">_</span><span class="hljs-title">m</span><span class="hljs-title">a</span><span class="hljs-title">n</span><span class="hljs-title">y</span><span class="hljs-title">_</span><span class="hljs-title">F</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">m</span><span class="hljs-title">a</span><span class="hljs-title">t</span><span class="hljs-title">_</span><span class="hljs-title">p</span><span class="hljs-title">r</span><span class="hljs-title">i</span><span class="hljs-title">m</span><span class="hljs-title">e</span><span class="hljs-title">s</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Prop</span> := <span class="hljs-strong">sorry</span>

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">g</span><span class="hljs-title">o</span><span class="hljs-title">l</span><span class="hljs-title">d</span><span class="hljs-title">b</span><span class="hljs-title">a</span><span class="hljs-title">c</span><span class="hljs-title">h</span><span class="hljs-title">_</span><span class="hljs-title">c</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">j</span><span class="hljs-title">e</span><span class="hljs-title">c</span><span class="hljs-title">t</span><span class="hljs-title">u</span><span class="hljs-title">r</span><span class="hljs-title">e</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Prop</span> := <span class="hljs-strong">sorry</span>

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">G</span><span class="hljs-title">o</span><span class="hljs-title">l</span><span class="hljs-title">d</span><span class="hljs-title">b</span><span class="hljs-title">a</span><span class="hljs-title">c</span><span class="hljs-title">h'</span><span class="hljs-title">s</span><span class="hljs-title">_w</span><span class="hljs-title">e</span><span class="hljs-title">a</span><span class="hljs-title">k</span><span class="hljs-title">_</span><span class="hljs-title">c</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">j</span><span class="hljs-title">e</span><span class="hljs-title">c</span><span class="hljs-title">t</span><span class="hljs-title">u</span><span class="hljs-title">r</span><span class="hljs-title">e</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Prop</span> := <span class="hljs-strong">sorry</span>

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">F</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">m</span><span class="hljs-title">a</span><span class="hljs-title">t'</span><span class="hljs-title">s</span><span class="hljs-title">_</span><span class="hljs-title">l</span><span class="hljs-title">a</span><span class="hljs-title">s</span><span class="hljs-title">t</span><span class="hljs-title">_</span><span class="hljs-title">t</span><span class="hljs-title">h</span><span class="hljs-title">e</span><span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">m</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Prop</span> := <span class="hljs-strong">sorry</span>
</code></pre>
<ol start="5">
<li>존재 정량자에서 수록된 항등식을 여러분이 할 수 있는 만큼 가능한 많이 증명해보세요.</li>
</ol><!-- Mobile navigation buttons -->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        
                        
                            <a rel="prev" href="https://leanprover.github.io/theorem_proving_in_lean4/propositions_and_proofs.html" class="mobile-nav-chapters previous" title="이전 장" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="https://leanprover.github.io/theorem_proving_in_lean4/tactics.html" class="mobile-nav-chapters next" title="다음 장" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="https://leanprover.github.io/theorem_proving_in_lean4/propositions_and_proofs.html" class="nav-chapters previous" title="이전 장" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="https://leanprover.github.io/theorem_proving_in_lean4/tactics.html" class="nav-chapters next" title="다음 장" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="./Quantifiers and Equality - Theorem Proving in Lean 4_files/elasticlunr.min.js.다운로드" type="text/javascript" charset="utf-8"></script>
        <script src="./Quantifiers and Equality - Theorem Proving in Lean 4_files/mark.min.js.다운로드" type="text/javascript" charset="utf-8"></script>
        <script src="./Quantifiers and Equality - Theorem Proving in Lean 4_files/searcher.js.다운로드" type="text/javascript" charset="utf-8"></script>
        

        <script src="./Quantifiers and Equality - Theorem Proving in Lean 4_files/clipboard.min.js.다운로드" type="text/javascript" charset="utf-8"></script>
        <script src="./Quantifiers and Equality - Theorem Proving in Lean 4_files/highlight.js.다운로드" type="text/javascript" charset="utf-8"></script>
        <script src="./Quantifiers and Equality - Theorem Proving in Lean 4_files/book.js.다운로드" type="text/javascript" charset="utf-8"></script><!-- Custom JS scripts -->

        
        

        

    

</body></html>