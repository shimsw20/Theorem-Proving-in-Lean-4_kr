<!DOCTYPE html>
<!-- saved from url=(0082)https://leanprover.github.io/theorem_proving_in_lean4/propositions_and_proofs.html -->
<html lang="en" class="js sidebar-visible light"><head><meta http-equiv="content-type" content="text/html; charset=UTF-8">
        <!-- Book generated using mdBook -->
        
        <title>명제와 증명 - 린4로 하는 정리 증명</title>
        
        


        <!-- Custom HTML head -->
        


        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="rgba(0, 0, 0, 0)">

        
        <link rel="icon" href="https://leanprover.github.io/theorem_proving_in_lean4/favicon.svg">
        
        
        <link rel="shortcut icon" href="https://leanprover.github.io/theorem_proving_in_lean4/favicon.png">
        
        <link rel="stylesheet" href="./Propositions and Proofs - Theorem Proving in Lean 4_files/variables.css">
        <link rel="stylesheet" href="./Propositions and Proofs - Theorem Proving in Lean 4_files/general.css">
        <link rel="stylesheet" href="./Propositions and Proofs - Theorem Proving in Lean 4_files/chrome.css">
        
        <link rel="stylesheet" href="./Propositions and Proofs - Theorem Proving in Lean 4_files/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="./Propositions and Proofs - Theorem Proving in Lean 4_files/font-awesome.css">
        
        <link rel="stylesheet" href="./Propositions and Proofs - Theorem Proving in Lean 4_files/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="./Propositions and Proofs - Theorem Proving in Lean 4_files/highlight.css">
        <link rel="stylesheet" href="./Propositions and Proofs - Theorem Proving in Lean 4_files/tomorrow-night.css" disabled="">
        <link rel="stylesheet" href="./Propositions and Proofs - Theorem Proving in Lean 4_files/ayu-highlight.css" disabled="">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents" aria-hidden="false">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="https://leanprover.github.io/theorem_proving_in_lean4/title_page.html" tabindex="0">린 4로 하는 정리 증명</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/introduction.html" tabindex="0"><strong aria-hidden="true">1.</strong> 소개(Introduction)</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/dependent_type_theory.html" tabindex="0"><strong aria-hidden="true">2.</strong> 의존 유형론(Dependent Type Theory)</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/propositions_and_proofs.html" class="active" tabindex="0"><strong aria-hidden="true">3.</strong> 명제와 증명(Propositions and Proofs)</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html" tabindex="0"><strong aria-hidden="true">4.</strong> 한정기호와 동등성(Quantifiers and Equality)</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/tactics.html" tabindex="0"><strong aria-hidden="true">5.</strong> 전략(Tactics)</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/interacting_with_lean.html" tabindex="0"><strong aria-hidden="true">6.</strong> 린과 상호작용하기(Interacting with Lean)</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/inductive_types.html" tabindex="0"><strong aria-hidden="true">7.</strong> 귀납형(Inductive Types)</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html" tabindex="0"><strong aria-hidden="true">8.</strong> 귀납과 재귀(Induction and Recursion)</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/structures_and_records.html" tabindex="0"><strong aria-hidden="true">9.</strong> 구조체와 레코드(Structures and Records)</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/type_classes.html" tabindex="0"><strong aria-hidden="true">10.</strong> 유형 계층(Type Classes)</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/conv.html" tabindex="0"><strong aria-hidden="true">11.</strong> 전략 모드로 전환(The Conversion Tactic Mode)</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/axioms_and_computation.html" tabindex="0"><strong aria-hidden="true">12.</strong> 공리계와 계산(Axioms and Computation)</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar" style="top: 0px;">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="목차 토글" aria-label="Toggle Table of Contents" aria-controls="sidebar" aria-expanded="true">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="테마 바꾸기" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">밝게(기본)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">녹슨 색</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">검은색</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">짙푸른색</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">짙은 검은색</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="탐색. (단축기: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">린 4로 하는 정리 증명</h1>

                    <div class="right-buttons">
                        
                        <a href="https://leanprover.github.io/theorem_proving_in_lean4/print.html" title="책 인쇄하기" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/leanprover/theorem_proving_in_lean4" title="깃 저장소" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" placeholder="이 책을 찾아보기 ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/propositions_and_proofs.html#propositions-and-proofs" id="propositions-and-proofs">명제와 증명</a></h1>
<p>지금까지, 여러분들은 린에서 객체와 함수를 정의하는 몇가지 방법을 배웠습니다. 이 장에서 우리는 수학적 주장과 증명을 의존 유형론의 언어로써 어떻게 작성할지 설명할 것입니다.</p>
<h2><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/propositions_and_proofs.html#propositions-as-types" id="propositions-as-types">유형으로써 명제</a></h2>
<p>의존 유형론의 언어로 정의된 객체에 대해서 주장을 증명하는 한 전략은 주장 언어와 증명 언어를 정의언어의 꼭대기 층에 두는 것입니다. 그러나 의존유형론은 유연하고 표현력 있어 이런 식으로 언어들을 늘릴 이유는 없습니다. 그리고 주장과 증명은 한 동일한 일반적 프레임워크에서 표현하지 못할 이유도 없습니다.</p>
<p>예를 들어, 우리는 새로운 유형 <code class="hljs">Prop</code>을 명제를 나타내기 위해 도입할 수 있습니다. 그리고 다른 유형으로부터 새로운 명제를 만드는 생성자를 도입할 수 있습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="숨겨진 선 보이기" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="boring"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">I</span><span class="hljs-title">m</span><span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">i</span><span class="hljs-title">e</span><span class="hljs-title">s</span> <span class="hljs-params">(p q : <span class="hljs-built_in">Prop</span>)</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Prop</span> := p → q
</span><span class="hljs-keyword">#check</span> And     <span class="hljs-comment">-- Prop → Prop → Prop</span>
<span class="hljs-keyword">#check</span> Or      <span class="hljs-comment">-- Prop → Prop → Prop</span>
<span class="hljs-keyword">#check</span> Not     <span class="hljs-comment">-- Prop → Prop</span>
<span class="hljs-keyword">#check</span> Implies <span class="hljs-comment">-- Prop → Prop → Prop</span>

<span class="hljs-keyword">variable</span> (p q r : <span class="hljs-built_in">Prop</span>)
<span class="hljs-keyword">#check</span> And p q                      <span class="hljs-comment">-- Prop</span>
<span class="hljs-keyword">#check</span> Or (And p q) r               <span class="hljs-comment">-- Prop</span>
<span class="hljs-keyword">#check</span> Implies (And p q) (And q p)  <span class="hljs-comment">-- Prop</span>
</code></pre>
<p>그러면 우리는 각각의 원소 <code class="hljs">p : Prop</code>와 또 다른 유형인 <code class="hljs">Proof p</code>을 <code class="hljs">p</code>의 증명 유형으로 가져올 수 있습니다. "공리"는 그러한 유형의 상수입니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="숨겨진 선 보이기" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="boring"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">I</span><span class="hljs-title">m</span><span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">i</span><span class="hljs-title">e</span><span class="hljs-title">s</span> <span class="hljs-params">(p q : <span class="hljs-built_in">Prop</span>)</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Prop</span> := p → q
</span><span class="boring"><span class="hljs-theorem"><span class="hljs-keyword">structure</span> <span class="hljs-title">P</span><span class="hljs-title">r</span><span class="hljs-title">o</span><span class="hljs-title">o</span><span class="hljs-title">f</span> <span class="hljs-params">(p : <span class="hljs-built_in">Prop</span>)</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Type</span> <span class="hljs-keyword">where</span>
</span><span class="boring">  proof : p
</span><span class="hljs-keyword">#check</span> Proof   <span class="hljs-comment">-- Proof : Prop → Type</span>

<span class="hljs-keyword">axiom</span> and_comm (p q : <span class="hljs-built_in">Prop</span>) : Proof (Implies (And p q) (And q p))

<span class="hljs-keyword">variable</span> (p q : <span class="hljs-built_in">Prop</span>)
<span class="hljs-keyword">#check</span> and_comm p q     <span class="hljs-comment">-- Proof (Implies (And p q) (And q p))</span>
</code></pre>
<p>하지만 공리에 더해 우리는 이전 증명으로부터 새로운 증명을 만드는데 사용할 규칙도 필요합니다. 예를 들어 명제논리에 대한 많은 증명보조기들은 전건긍정(modus ponens)에 대한 규칙을 갖고 있습니다.</p>
<blockquote>
<p>증명 <code class="hljs">Implies p q</code>과 증명<code class="hljs">p</code>으로부터 우리는 증명 <code class="hljs">q</code>을 얻을 수 있습니다.</p>
</blockquote>
<p>이를 다음과 같이 나타낼 수 있습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="숨겨진 선 보이기" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="boring"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">I</span><span class="hljs-title">m</span><span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">i</span><span class="hljs-title">e</span><span class="hljs-title">s</span> <span class="hljs-params">(p q : <span class="hljs-built_in">Prop</span>)</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Prop</span> := p → q
</span><span class="boring"><span class="hljs-theorem"><span class="hljs-keyword">structure</span> <span class="hljs-title">P</span><span class="hljs-title">r</span><span class="hljs-title">o</span><span class="hljs-title">o</span><span class="hljs-title">f</span> <span class="hljs-params">(p : <span class="hljs-built_in">Prop</span>)</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Type</span> <span class="hljs-keyword">where</span>
</span><span class="boring">  proof : p
</span><span class="hljs-keyword">axiom</span> modus_ponens : (p q : <span class="hljs-built_in">Prop</span>) → Proof (Implies p q) →  Proof p → Proof q
</code></pre>
<p>명제논리의 자연 영역에 대한 시스템은 주로 다음 규칙에 의존합니다.</p>
<blockquote>
<p>그것은 <code class="hljs">p</code>를 가정으로 하면 <code class="hljs">q</code>의 증명을 가질 수 있습니다. 그러면 우리는 가정을 "상쇄"하여 <code class="hljs">Implies p q</code>의 증명을 얻을 수 있습니다.</p>
</blockquote>
<p>이를 다음과 같이 얻을 수 있습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="숨겨진 선 보이기" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="boring"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">I</span><span class="hljs-title">m</span><span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">i</span><span class="hljs-title">e</span><span class="hljs-title">s</span> <span class="hljs-params">(p q : <span class="hljs-built_in">Prop</span>)</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Prop</span> := p → q
</span><span class="boring"><span class="hljs-theorem"><span class="hljs-keyword">structure</span> <span class="hljs-title">P</span><span class="hljs-title">r</span><span class="hljs-title">o</span><span class="hljs-title">o</span><span class="hljs-title">f</span> <span class="hljs-params">(p : <span class="hljs-built_in">Prop</span>)</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Type</span> <span class="hljs-keyword">where</span>
</span><span class="boring">  proof : p
</span><span class="hljs-keyword">axiom</span> implies_intro : (p q : <span class="hljs-built_in">Prop</span>) → (Proof p → Proof q) → Proof (Implies p q)
</code></pre>
<p>이런 접근은 주장과 증명을 만드는 합리적인 방법을 우리에게 줍니다. 표현식 <code class="hljs">t</code>는 주장 <code class="hljs">p</code>의 올바른 증명이다를 결정하는 것은 <code class="hljs">t</code>가 <code class="hljs">Proof p</code>형임을 확인하는 문제가 됩니다.</p>
<p>하지만 몇 가지 단순화는 가능합니다. 그렇기 위해 우리는 <code class="hljs">Proof p</code>를 <code class="hljs">p</code>를 같이 쓰는 것으로 <code class="hljs">Proof</code>에 대한 반복적인 사용을 피할 수 있습니다. 다시 말하자면, <code class="hljs">p : Prop</code>를 갖는한 우리는p를 유형으로써 p가 그 증명에 대한 유형으로  해석할 수 있습니다. 우리는<code class="hljs">t : p</code>를 <code class="hljs">t</code>는 <code class="hljs">p</code>의 증명이라는 주장으로써 읽을 수 있습니다.</p>
<p>게다가 한번 우리가 이런 식별을 하면 함의 규칙은 <code class="hljs">Implies p q</code>과 <code class="hljs">p → q</code>의 앞뒤를 오갈 수 있다는 것을 보여줍니다. 다시 말하면, 명제  <code class="hljs">p</code>과 <code class="hljs">q</code>사이의 함의는  <code class="hljs">p</code>의 원소에서 <code class="hljs">q</code>의 원소로 가는 함수를 갖는 것에 대응된니다. 결과적으로 연결사 <code class="hljs">Implies</code>의 도입은 완전히 중복됩니다. 그래서 우리는 의존 유형론의 함의에 대한 개념으로써 종종 함수 공간 생성자<code class="hljs">p → q</code>를 사용할 수 있습니다.</p>
<p>이는 직관주의적 계산법에 따른 접근법입니다. 그리고 이는 린에서도 마찬가지 입니다. 자연 추론을 위한 증명 보조기에서 함의에 대한 규칙이 함수 추상화와 함수 적용을 지배하는 규칙과 정확히 일치한다는 사실은 <em>커리-하워드 동형론(Curry-Howard isomorphism) </em>의 한 예이며, 때때로 <em>유형으로써 명제(propositions-as-types)</em> 패러다임으로 알려져 있습니다. 사실 <code class="hljs">Prop</code>형은 <code class="hljs">Sort 0</code>에 대한 문법적 설탕입니다. 유형 계층의 최하층은 마지막 장에서 설명합니다. 게다가 <code class="hljs">Type u</code>도 <code class="hljs">Sort (u+1)</code>에 대한 문법적 설탕입니다. <code class="hljs">Prop</code>은 특별한 특징이 있습니다. 하지만 다른 유형 세계처럼, 화살표 생성자로 달성됩니다. 우리가 <code class="hljs">p q : Prop</code>갖는다면  <code class="hljs">p → q : Prop</code>입니다.</p>
<p>유형으로써 명제에 대해 생각할 수 있는 최소한 두 가지 방법이 있습니다. 논리와 수학에 직관주의적 관점을 갖는 누군가에게 이것은 명제가 되는 것의 의미를 충실하게 표현합니다. 명제 <code class="hljs">p</code>은 일종의 데이터 유형을 나타냅니다. 주로 증명을 만드는 데이터 유형의 명세입니다. <code class="hljs">p</code>의 증명은 단순히 <code class="hljs">t : p</code> 오른쪽 유형의 객체입니다.</p>
<p>이 이데올로기에 편향되지 않은 사람들은 꽤나 단순한 코딩 트릭으로 볼 것입니다. 각 명제 <code class="hljs">p</code>에 대해, 우리는 <code class="hljs">p</code>이 거짓이면 원소가 없고, <code class="hljs">p</code>가 참이면 한 원소(예: <code class="hljs">*</code>)가 있는 유형을 연관시킵니다. 후자의 경우에서 (연관된 유형)<code class="hljs">p</code>은 <em>머무른다</em>고 말합시다. 함수 적용 및 추상화 규칙이 <code class="hljs">Prop</code>의 원소가 머무르는 것을 우리가 추적하는 것을 편리하게 도울 수 있습니다. 그러므로 원소 <code class="hljs">t : p</code>을 생성하는 것은 <code class="hljs">p</code>가 사실이라고 우리에게 알립니다. <code class="hljs">p</code>의 머무름은 "<code class="hljs">p</code>가 참이라는 사실"이라 생각할 수 있습니다. <code class="hljs">p → q</code>의 증명은 "<code class="hljs">p</code>가 참이라는 사실"을 "<code class="hljs">q</code>이 참이라는 사실"을 얻기위해 사용합니다.</p>
<p>실제로 <code class="hljs">p : Prop</code>이 어떤 명제라면, 린의 커널은 임의의 두 원소 <code class="hljs">t2 : p </code>을 <code class="hljs">(fun x = t) s</code>와 <code class="hljs">t[/x]</code>를 정의상으로 동등하다고 같다는 것과 거의 같은 방식으로 정의상 동등하게 취급합니다. 이것은 <em>증명 무연관</em>으로 알려져 있고 이것은 마지막 문단에서 해석과 일관성이 있습니다. 우리가 증명<code class="hljs">t : p</code>을 의존 유형론 언어의 평범한 대상으로 다룰 수 있음에도 <code class="hljs">p</code>가 참이라는 사실 이상의 정보를 전달하지 않는다는 것을 의미합니다.</p>
<p>우리가 제안한 유형별 명제 패러다임에 대해 생각하는 두 가지 방법은 근본적인 면에서 다릅니다. 직관주의자의 관점에서 증명은 의존 유형론의 적절한 표현식으로 <em>표기된</em>추상적인 수학적 대상입니다. 반대로 위에서 설명한 코딩 트릭으로 생각한다면 표현식 그 자체는 어떤 흥미로운 것도 나타내지 않습니다. 그것보다 우리가 표현식을 쓰고 잘 쓰여졌는지 확인할 수 있다는 사실은 의문의 명제가 참인지를 확실히 만듭니다. 다시 말하자면 표현식 <em>그들 자체는</em> 증명입니다.</p>
<p>아래의 설명에서 우리는 두 말하기 방식 사이를 앞뒤로 다닐 것인데, 어떤 표현은 명제의 증명을 "구성" 또는 "생성", "반환"을 말하고, 어떤 표현은 단순히 "그것"이라고 말합니다. 이것은 컴퓨터 과학자들이 때때로 프로그램이 특정 함수를 "계산"한다고 말함으로써 문법과 의미론의 구분을 모호하게 하는 방식과 유사합니다. 그리고 다른 때에는 프로그램이 문제의 함수인 것처럼 말합니다.</p>
<p>어떤 경우에는 가장 중요한 것은 아래의 문장입니다. 의존 유형론의 언어로 수학적 주장을 형식적으로 표현하기 위해 <code class="hljs">p : Prop</code>에 대한 항으로 나타낼 필요가 있습니다. 주장을 <em>증명</em>하는 것은 <code class="hljs">t : p</code>의 항으로 나타낼 필요가 있습니다. 증명 보조기로써 린의 일은 그러한 항 <code class="hljs">t</code>를 생성하고 그것이 올바른 유형이고 잘 형성된 것을 검증하도록 돕는 것입니다.</p>
<h2><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/propositions_and_proofs.html#working-with-propositions-as-types" id="working-with-propositions-as-types">유형으로써 명제로 작업하기</a></h2>
<p>유형으로써 명제 패러다임에서 <code class="hljs">→</code>만을 포함하는 정리는 람다 추상화와 적용을 사용해 증명될 수 있습니다. 린에서 <code class="hljs">theorem</code> 명령은 새로운 정리를 도입합니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">variable</span> {p : <span class="hljs-built_in">Prop</span>}
<span class="hljs-keyword">variable</span> {q : <span class="hljs-built_in">Prop</span>}

<span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">t1</span> <span class="hljs-symbol">:</span></span> p → q → p := <span class="hljs-keyword">fun</span> hp : p =&gt; <span class="hljs-keyword">fun</span> hq : q =&gt; hp
</code></pre>
<p>이는 지난 장에서 상수함수의 정의와 완전히 동일하게 보입니다. 유일한 차이는 인수는 <code class="hljs">Prop</code>의 원소 보다는 <code class="hljs">Type</code>의 원소라는 것입니다. 직관적으로  <code class="hljs">p → q → p</code>에 대한 우리의 증명은 <code class="hljs">p</code>와 <code class="hljs">q</code>가 참이라고 가정한다. 그리고 (명백히) 첫 번 째 가정을 <code class="hljs">p</code>가 참이라는 결론을 세우기 위해 사용한다.</p>
<p><code class="hljs">theorem</code> 명령은 <code class="hljs">def</code> 명령의 한 버전이라는 것을 주목하세요. 명제와 유형 대응 하에서 정리 <code class="hljs">p → q → p</code>의 증명하는 것은 연관된 유형의 원소를 증명하는 것과 정말 같습니다. 커널 유형 확인기에서 둘 사이의 차이는 없습니다.</p>
<p>하지만 정의와 정리 사이에 약간의 실용적 차이는 있습니다. 평범한 상황에서 증명 무연관에 의해 정리의 "정의"를 펼칠 필요는 절대 없습니다. 그리고 그 정리의 임의의 두 증명도 정의상으로 동등합니다. 한번 정리의 증명이 마쳐지면 우리는 증명이 존재한다는 것만 알면 됩니다. 증명이 무엇인지 아는 것은 중요하지 않습니다. 그 사실에 비춰보면 린의 증명을 <em>줄일 수 없는</em> 것으로 태그한다. 그리고 그것은 파서(더 정확히는  <em>협력기</em>)에게 파일을 처리할 때 증명을 펼칠 필요가 없다는 힌트를 주는 역할을 한다. 사실, 어떤 증명의 옳음에 접근하는 것은 다른 것의 상세를 알 필요가 없기 때문에 린은 일반적으로 증명의 검증과 처리를 병렬적으로 할 수 있다.</p>
<p>정의와 마찬가지로 <code class="hljs">#print</code>명령은 정리의 증명을 여러분에게 보여줄 것 입니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="숨겨진 선 보이기" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="boring"><span class="hljs-keyword">variable</span> {p : <span class="hljs-built_in">Prop</span>}
</span><span class="boring"><span class="hljs-keyword">variable</span> {q : <span class="hljs-built_in">Prop</span>}
</span><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">t1</span> <span class="hljs-symbol">:</span></span> p → q → p := <span class="hljs-keyword">fun</span> hp : p =&gt; <span class="hljs-keyword">fun</span> hq : q =&gt; hp

<span class="hljs-keyword">#print</span> t1
</code></pre>
<p>람다 추상화 <code class="hljs">hp : p</code>과 <code class="hljs">hq : q</code>은 <code class="hljs">t1</code>의 증명에서 일시적인 가정으로 보일 수 있음을 주목하세요. 린은 여러분에게 마지막 항 <code class="hljs">hp</code>을 명시적으로 <code class="hljs">show</code> 문장으로 유형을 명시하는 것을 허용합니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="숨겨진 선 보이기" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="boring"><span class="hljs-keyword">variable</span> {p : <span class="hljs-built_in">Prop</span>}
</span><span class="boring"><span class="hljs-keyword">variable</span> {q : <span class="hljs-built_in">Prop</span>}
</span><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">t1</span> <span class="hljs-symbol">:</span></span> p → q → p :=
  <span class="hljs-keyword">fun</span> hp : p =&gt;
  <span class="hljs-keyword">fun</span> hq : q =&gt;
  <span class="hljs-built_in">show</span> p <span class="hljs-built_in">from</span> hp
</code></pre>
<p>그런 추가 정보를 더하는 것은 증명의 명확성을 개선하고 증명을 작성할 때 오류를 감지하도록 돕습니다. <code class="hljs">show</code> 명령은 유형에 주석을 달 뿐이고, 내부적으로 우리가 본 <code class="hljs">t1</code>의 모든 나타남이 동일한 용어를 생성할 수 있습니다.</p>
<p>평범한 정의처럼 우리는 람다 추상화된 변수를 콜론의 왼쪽으로 옮길 수 있습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="숨겨진 선 보이기" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="boring"><span class="hljs-keyword">variable</span> {p : <span class="hljs-built_in">Prop</span>}
</span><span class="boring"><span class="hljs-keyword">variable</span> {q : <span class="hljs-built_in">Prop</span>}
</span><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">t1</span> <span class="hljs-params">(hp : p)</span> <span class="hljs-params">(hq : q)</span> <span class="hljs-symbol">:</span></span> p := hp

<span class="hljs-keyword">#print</span> t1    <span class="hljs-comment">-- p → q → p</span>
</code></pre>
<p>이제 우리는 정리 <code class="hljs">t1</code>을 함수 활용에 적용할 수 있습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="숨겨진 선 보이기" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="boring"><span class="hljs-keyword">variable</span> {p : <span class="hljs-built_in">Prop</span>}
</span><span class="boring"><span class="hljs-keyword">variable</span> {q : <span class="hljs-built_in">Prop</span>}
</span><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">t1</span> <span class="hljs-params">(hp : p)</span> <span class="hljs-params">(hq : q)</span> <span class="hljs-symbol">:</span></span> p := hp

<span class="hljs-keyword">axiom</span> hp : p

<span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">t2</span> <span class="hljs-symbol">:</span></span> q → p := t1 hp
</code></pre>
<p>여기서 <code class="hljs">axiom</code> 선언은 주어진 유형의 원소의 존재성을 가정하고 논리적 일관성을 타협할지도 모릅니다. 예를 들어 우리는 그것을 빈 유형 <code class="hljs">False</code>이 원소를 갖는다고 가정하는데 사용할 수 있습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">axiom</span> unsound : False
<span class="hljs-comment">-- Everything follows from false</span>
<span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">e</span><span class="hljs-title">x</span> <span class="hljs-symbol">:</span></span> <span class="hljs-number">1</span> = <span class="hljs-number">0</span> :=
False.elim unsound
</code></pre>
<p>"공리" <code class="hljs">hp : p</code>를 선언하는 것은 <code class="hljs">hp</code>에서 본 바와 같이 <code class="hljs">p</code>가 참이라고 선언하는 것과 마찬가지입니다. 정리<code class="hljs">t1 : p → q → p</code>를 사실 <code class="hljs">hp : p</code>에 적용하는 것은 <code class="hljs">p</code>가 참임을 정리<code class="hljs">t1 hp : q → p</code>을 얻습니다.</p>
<p>우리는 정리 <code class="hljs">t1</code>을 다음과 같이 쓸 수 있음을 기억하세요/ Recall that we can also write theorem <code class="hljs">t1</code> as follows:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">t1</span> <span class="hljs-params">{p q : <span class="hljs-built_in">Prop</span>}</span> <span class="hljs-params">(hp : p)</span> <span class="hljs-params">(hq : q)</span> <span class="hljs-symbol">:</span></span> p := hp

<span class="hljs-keyword">#print</span> t1
</code></pre>
<p><code class="hljs">t1</code>의 유형은 이제 <code class="hljs">∀ {p q : Prop}, p → q → p</code>입니다. 우리는 이를 "모든 명제쌍  <code class="hljs">p q</code>에 대해 <code class="hljs">p → q → p</code>이다."라고 주장한다고 읽을 수 있다. 예를 들어, 우리는 모든 매개변수들을 콜론의 오른쪽으로 옮길 수 있다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">
<span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">t1</span> <span class="hljs-symbol">:</span></span> ∀ {p q : <span class="hljs-built_in">Prop</span>}, p → q → p :=
  <span class="hljs-keyword">fun</span> {p q : <span class="hljs-built_in">Prop</span>} (hp : p) (hq : q) =&gt; hp
</code></pre>
<p><code class="hljs">p</code>와 <code class="hljs">q</code>가 변수로 선언되었다면 린은 우리를 위해 자동적으로 일반화시킬 것입니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">variable</span> {p q : <span class="hljs-built_in">Prop</span>}

<span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">t1</span> <span class="hljs-symbol">:</span></span> p → q → p := <span class="hljs-keyword">fun</span> (hp : p) (hq : q) =&gt; hp
</code></pre>
<p>사실 유형으로써 명제 대응에 의해 우리는 <code class="hljs">p</code>를 가진 가정 <code class="hljs">hp</code>를을 또다른 변수로 선언할 수 있습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">variable</span> {p q : <span class="hljs-built_in">Prop</span>}
<span class="hljs-keyword">variable</span> (hp : p)

<span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">t1</span> <span class="hljs-symbol">:</span></span> q → p := <span class="hljs-keyword">fun</span> (hq : q) =&gt; hp
</code></pre>
<p>린은 <code class="hljs">hp</code>를 사용하는 증명을 감지하고 자동적으로 <code class="hljs">hp : p</code>를 전제로 추가합니다. 모든 경우에 명령 <code class="hljs">#print t1</code>은 여전히 <code class="hljs">∀ p q : Prop, p → q → p</code>을 출력합니다. 왜냐하면 화살표는 대상이 구속 변수에 의존하지 않는 화살표 유형만을 나타내기 때문에 이 유형은 <code class="hljs">∀ (p q : Prop) (hp : p) (hq :q), p</code>로 쓸 수 있게 함을 기억하세요. </p>
<p>우리가 <code class="hljs">t1</code>을 그런 식으로 일반화할 때, 그럼 우리는 일반 정리의 다른 예를 얻기 위해 다른 명제쌍에 대해서도 적용할 수 있습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">t1</span> <span class="hljs-params">(p q : <span class="hljs-built_in">Prop</span>)</span> <span class="hljs-params">(hp : p)</span> <span class="hljs-params">(hq : q)</span> <span class="hljs-symbol">:</span></span> p := hp

<span class="hljs-keyword">variable</span> (p q r s : <span class="hljs-built_in">Prop</span>)

<span class="hljs-keyword">#check</span> t1 p q                <span class="hljs-comment">-- p → q → p</span>
<span class="hljs-keyword">#check</span> t1 r s                <span class="hljs-comment">-- r → s → r</span>
<span class="hljs-keyword">#check</span> t1 (r → s) (s → r)    <span class="hljs-comment">-- (r → s) → (s → r) → r → s</span>

<span class="hljs-keyword">variable</span> (h : r → s)
<span class="hljs-keyword">#check</span> t1 (r → s) (s → r) h  <span class="hljs-comment">-- (s → r) → r → s</span>
</code></pre>
<p>다시 한 번, 유형으로써 명제 대응을 사용하면 <code class="hljs">r → s</code>형의 변수 <code class="hljs">h</code>는 <code class="hljs">r → s</code>을 성립시키는 가정 또는 전제로 볼 수 있습니다.</p>
<p>또 다른 예로써 지금은 유형 대신 명제로 지난 장에서 논한 합성함수를 고려해봅시다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">variable</span> (p q r s : <span class="hljs-built_in">Prop</span>)

<span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">t2</span> <span class="hljs-params">(h₁ : q → r)</span> <span class="hljs-params">(h₂ : p → q)</span> <span class="hljs-symbol">:</span></span> p → r :=
<span class="hljs-keyword">fun</span> h₃ : p =&gt;
<span class="hljs-built_in">show</span> r <span class="hljs-built_in">from</span> h₁ (h₂ h₃)
</code></pre>
<p>명제 논리의 정리로써 <code class="hljs">t2</code>가 말하는 것은 무엇인가요?</p>
<p>수치 유니코드 밑첨자를 사용하는 것은 종종 유용합니다. 이 예제에서 그런 것처럼 가정에 대해 <code class="hljs">\0</code>, <code class="hljs">\1</code>, <code class="hljs">\2</code>, ..., 으로 쳐서 쓸 수 있습니다.</p>
<h2><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic" id="propositional-logic">명제 논리</a></h2>
<p>린은 모든 표준 논리 연결사와 표기를 정의합니다. 명제 연결사는 다음 기호로 따라온다.</p>
<table><thead><tr><th>Ascii(아스키)</th><th>Unicode(유니코드)</th><th>Editor shortcut(편집 단축기)</th><th>Definition(정의)</th></tr></thead><tbody>
<tr><td>참</td><td></td><td></td><td>참</td></tr>
<tr><td>거짓</td><td></td><td></td><td>거짓</td></tr>
<tr><td>부정</td><td>¬</td><td><code class="hljs">\not</code>, <code class="hljs">\neg</code></td><td>부정</td></tr>
<tr><td>/\</td><td>∧</td><td><code class="hljs">\and</code></td><td>논리곱</td></tr>
<tr><td>\/</td><td>∨</td><td><code class="hljs">\or</code></td><td>논리합</td></tr>
<tr><td>-&gt;</td><td>→</td><td><code class="hljs">\to</code>, <code class="hljs">\r</code>, <code class="hljs">\imp</code></td><td></td></tr>
<tr><td>&lt;-&gt;</td><td>↔</td><td><code class="hljs">\iff</code>, <code class="hljs">\lr</code></td><td>쌍조건문</td></tr>
</tbody></table>
<p>이들은 <code class="hljs">Prop</code>형의 모든 값을 받습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">variable</span> (p q : <span class="hljs-built_in">Prop</span>)

<span class="hljs-keyword">#check</span> p → q → p ∧ q
<span class="hljs-keyword">#check</span> ¬p → p ↔ False
<span class="hljs-keyword">#check</span> p ∨ q → q ∨ p
</code></pre>
<p>연산자의 우선순위는 다음과 같습니다. 일항 부정 <code class="hljs">¬</code> 은 가장 강하게 결합하고 그 다음은 <code class="hljs">∧</code> 그 다음 <code class="hljs">∨</code> 그 다음 <code class="hljs">→</code> 그리고 마지막으로 <code class="hljs">↔</code>입니다. 예를 들어 <code class="hljs">a ∧ b → c ∨ d ∧ e</code>은 <code class="hljs">(a ∧ b) → (c ∨ (d ∧ e))</code>을 의미합니다. 다른 이항 결합자들처럼 <code class="hljs">→</code>은 오른쪽으로 결합한다는 것을 기억하세요.(인수가 <code class="hljs">Type</code> 대신 <code class="hljs">Prop</code>인 것을 제외하고 변한 건 없습니다.) 그래서 만약 <code class="hljs">p q r : Prop</code>이 있다면 표현식 <code class="hljs">p → q → r</code>은 "<code class="hljs">p</code>이면 그러면<code class="hljs">q</code>이면<code class="hljs">r</code>이다."로 읽습니다. 이는 <code class="hljs">p ∧ q → r</code>의 "커리된(curried)" 형태일 뿐입니다.</p>
<p>지난 장에서 우리는 람다 추상화가 <code class="hljs">→</code>에 대한 "도입 규칙"으로 본 적이 있습니다. 지금 상황에서 그것은 "도입"을 어떻게 하는지 또는 함의를 어떻게 세우는지 보여줍니다. 적용은 어떻게 "제거"하는지 증명에서 함의를 사용하는지를 보여주는 "제거 규칙"으로 볼 수 있습니다. 다른 명제논리적 연결사들은  린의 라이브러리의 <code class="hljs">Prelude.core</code> 파일 속에 정의되 있습니다. (라이브러리 계층에 대한 더 많은 정보를 위해 <a href="https://leanprover.github.io/theorem_proving_in_lean4/interacting_with_lean.html#_importing_files">파일 불러오기</a>를 보세요.) 그리고 각 연결사들마다 그것의 정식 도입, 제거 규칙이 딸려 나옵니다.</p>
<h3><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/propositions_and_proofs.html#a-name_conjunctionaconjunction" id="a-name_conjunctionaconjunction"></a><a name="_conjunction"></a>연결사</h3>
<p>표현식 <code class="hljs">And.intro h1 h2</code>은 <code class="hljs">p ∧ q</code>의 증명을 <code class="hljs">h1 : p</code>과 <code class="hljs">h2 : q</code>의 증명을 사용하여 만듭니다. <code class="hljs">And.intro</code>를 <em>and-도입</em> 규칙이라고 설명하는 것은 흔합니다. 다음 예제에서 우리는 <code class="hljs">And.intro</code>를 <code class="hljs">p → q → p ∧ q</code>의 증명을 만들기 위해 사용합니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">variable</span> (p q : <span class="hljs-built_in">Prop</span>)

<span class="hljs-keyword">example</span> (hp : p) (hq : q) : p ∧ q := And.<span class="hljs-built_in">intro</span> hp hq

<span class="hljs-keyword">#check</span> <span class="hljs-keyword">fun</span> (hp : p) (hq : q) =&gt; And.<span class="hljs-built_in">intro</span> hp hq
</code></pre>
<p><code class="hljs">example</code> 명령은 이름이 없이 영구적인 맥락으로 저장하지 않는 정리를 기술합니다. 본질적으로 어떤 항이 가리키는 유형을 갖는 것을 확인합니다. 이는 설명에 유용하고 예제 명령을 자주 사용할 것입니다.</p>
<p>표현식 <code class="hljs">And.left h</code>는 <code class="hljs">h : p ∧ q</code>의 증명으로부터 <code class="hljs">p</code>의 증명을 만듭니다. 마찬가지로 <code class="hljs">And.right h</code>는 <code class="hljs">q</code>의 증명입니다. 이들은 흔히 오른쪽과 왼쪽 <em>and-제거</em> 규칙으로 알려져 있습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">variable</span> (p q : <span class="hljs-built_in">Prop</span>)

<span class="hljs-keyword">example</span> (h : p ∧ q) : p := And.left h
<span class="hljs-keyword">example</span> (h : p ∧ q) : q := And.right h
</code></pre>
<p>이제 우리는 <code class="hljs">p ∧ q → q ∧ p</code>를 따르는 증명 항으로 증명할 수 있습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">variable</span> (p q : <span class="hljs-built_in">Prop</span>)

<span class="hljs-keyword">example</span> (h : p ∧ q) : q ∧ p :=
And.<span class="hljs-built_in">intro</span> (And.right h) (And.left h)
</code></pre>
<p>and-도입과 and-제거는 카테시안 곱 연산의 순서쌍을 구성하는 것과 순서쌍에서 원소를 추출하는 연산과 비슷한 것을 보세요. 차이는 <code class="hljs">hp : p</code>와 <code class="hljs">hq : q</code>가 주어졌을 때 <code class="hljs">And.intro hp hq</code>는 <code class="hljs">p ∧ q : Prop</code>형을 갖는 한편 <code class="hljs">Prod hp hq</code>는 <code class="hljs">p × q : Type</code>형을 갖는다는 것입니다. <code class="hljs">∧</code>과 <code class="hljs">×</code>의 유사성은 커리-하워드 동형론의 또다른 예입니다. 그러나 함의와 함수 공간 생성자와는 대조적으로  <code class="hljs">∧</code>과 <code class="hljs">×</code>은 린에서 별개로 다뤄집니다. 하지만 이 비유에도 우리가 막 만든 증명은 순서쌍의 원소를 바꾸는 함수와 비슷합니다.</p>
<p><a href="https://leanprover.github.io/theorem_proving_in_lean4/structures_and_records.html">구조체와 레코드 장</a>에서 보겠지만 린의 어떤 유형은 <em>구조체</em>입니다. 그 말은 유형이 하나의 적절한 인수의 배열로부터 유형의 원소를 만드는 정식 <em>생성자</em>로 정의된다는 것입니다. 모든 <code class="hljs">p q : Prop</code>에 대해 <code class="hljs">p ∧ q</code>가 예제입니다. 원소를 생성하는 정식 방법은 <code class="hljs">And.intro</code>를 적절한 인수 <code class="hljs">hp : p</code>과 <code class="hljs">hq : q</code>에 대해 적용하는 것입니다. 연관된 유형이 유도형이고 맥락으로부터 추리할 수 있는 상황에서 린은 <em>익명 생성자</em> 표기 <code class="hljs">⟨arg1, arg2, ...⟩</code>를 쓸 수 있게 해줍니다. 특히 <code class="hljs">And.intro hp hq</code>대신  <code class="hljs">⟨hp, hq⟩</code>와 같이 쓸 수 있습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">variable</span> (p q : <span class="hljs-built_in">Prop</span>)
<span class="hljs-keyword">variable</span> (hp : p) (hq : q)

<span class="hljs-keyword">#check</span> (⟨hp, hq⟩ : p ∧ q)
</code></pre>
<p>이 꺽긴 괄호는 <code class="hljs">\&lt;</code>과 <code class="hljs">\&gt;</code>을 각각 치는 것으로 쓸 수 있습니다.</p>
<p>린은 또 다른 유용한 문법적 도구를 제공합니다. (아마 몇 가지 인수를 적용한) 유도형이 <code class="hljs">Foo</code>인 표현식 <code class="hljs">e</code>에 대해 <code class="hljs">e.bar</code>과 같은 표기는 <code class="hljs">Foo.bar e</code>의 약식 표현입니다. 이는 이름공간을 열지 않고 함수에 접근하는 편리한 방법을 줍니다. 예를 들어 다음 두 표현식은 같은 것을 의미합니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">variable</span> (xs : List Nat)

<span class="hljs-keyword">#check</span> List.length xs
<span class="hljs-keyword">#check</span> xs.length
</code></pre>
<p>결과적으로 <code class="hljs">h : p ∧ q</code>라면 우리는 <code class="hljs">h.left</code>를 <code class="hljs">And.left h</code>을 나타내는데 그리고 <code class="hljs">h.right</code> 를 <code class="hljs">And.right h</code>을 나타내는데 쓸 수 있습니다. 우리는 다음과 같이 위의 예시 증명을 간단히 줄여 쓸  수 있습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">variable</span> (p q : <span class="hljs-built_in">Prop</span>)
<span class="hljs-keyword">example</span> (h : p ∧ q) : q ∧ p :=
  ⟨h.right, h.left⟩
</code></pre>
<p>간결함과 가독성 사이에 미세찬 차이가 있고 이런 식으로 정보를 생략하는 것은 때때로 증명을 읽기 더 어렵게 만들 수 있습니다. 위와 같은 간단한 구성의 경우 <code class="hljs">h</code>의 유형과 구성의 목표가 두드러질 때 이 표기법은 깨끗하고 효과적입니다.</p>
<p>"And"같은 반복적 생성은 흔합니다. 두 증명이 동등함을 보이기 위해 린은 여러분에게 오른쪽에 연관된 중첩된 생성자를 평평하게 만들도록 허용합니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">variable</span> (p q : <span class="hljs-built_in">Prop</span>)

<span class="hljs-keyword">example</span> (h : p ∧ q) : q ∧ p ∧ q:=
  ⟨h.right, ⟨h.left, h.right⟩⟩

<span class="hljs-keyword">example</span> (h : p ∧ q) : q ∧ p ∧ q:=
  ⟨h.right, h.left, h.right⟩
</code></pre>
<p>이것도 또한 종종 유용합니다.</p>
<h3><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/propositions_and_proofs.html#disjunction" id="disjunction">분리자</a></h3>
<p>표현식 <code class="hljs">Or.intro_left q hp</code>은 <code class="hljs">hp : p</code>의 증명으로부터 <code class="hljs">p ∨ q</code>의 증명을 만듭니다. 마찬가지로 <code class="hljs">Or.intro_right p hq</code>는 <code class="hljs">hq : q</code>의 증명을 사용하여 <code class="hljs">p ∨ q</code> 의 증명을 만듭니다. 이들은 왼쪽과 오른쪽 <em>or-도입</em> 규칙입니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">variable</span> (p q : <span class="hljs-built_in">Prop</span>)
<span class="hljs-keyword">example</span> (hp : p) : p ∨ q := Or.intro_left q hp
<span class="hljs-keyword">example</span> (hq : q) : p ∨ q := Or.intro_right p hq
</code></pre>
<p><em>or-제거</em> 규칙은 약간 더 복잡합니다. <code class="hljs">r</code>이 <code class="hljs">p</code>로부터 나오고 <code class="hljs">r</code>이 <code class="hljs">q</code>로부터 나온다는 것을 보임으로써 우리가 <code class="hljs">p ∨ q</code>로부터 <code class="hljs">r</code>을 증명할 수 있다는 생각입니다. 다시 말하자면 경우에 따라 증명한 것입니다. 표현식 <code class="hljs">Or.elim hpq hpr hqr</code>과 <code class="hljs">Or.elim</code>은 세 인수 <code class="hljs">hpq : p ∨ q</code>, <code class="hljs">hpr : p → r</code> 그리고 <code class="hljs">hqr : q → r</code>를 받습니다. 그리고 <code class="hljs">r</code>의 증명을 만듭니다. 다음 예제에서 우리는 <code class="hljs">Or.elim</code>을 <code class="hljs">p ∨ q → q ∨ p</code>을 증명하는데 사용합니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">variable</span> (p q r : <span class="hljs-built_in">Prop</span>)

<span class="hljs-keyword">example</span> (h : p ∨ q) : q ∨ p :=
  Or.elim h
    (<span class="hljs-keyword">fun</span> hp : p =&gt;
      <span class="hljs-built_in">show</span> q ∨ p <span class="hljs-built_in">from</span> Or.intro_right q hp)
    (<span class="hljs-keyword">fun</span> hq : q =&gt;
     <span class="hljs-built_in">show</span> q ∨ p <span class="hljs-built_in">from</span> Or.intro_left p hq)
</code></pre>
<p>대게의 경우  <code class="hljs">Or.intro_right</code>와 <code class="hljs">Or.intro_left</code>의 첫번째 인수는 린에 의해 자동적으로 추론될 수 있습니다. 린은 그러므로  <code class="hljs">Or.intro_right _</code>과 <code class="hljs">Or.intro_left _</code>의 약식 표현으로 볼 수 있는 <code class="hljs">Or.inr</code> 과 <code class="hljs">Or.inl</code>을 제공합니다. 따라서 위의 증명 항을 더 간결하게 쓸 수 있습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">variable</span> (p q r : <span class="hljs-built_in">Prop</span>)

<span class="hljs-keyword">example</span> (h : p ∨ q) : q ∨ p :=
  Or.elim h (<span class="hljs-keyword">fun</span> hp =&gt; Or.inr hp) (<span class="hljs-keyword">fun</span> hq =&gt; Or.inl hq)
</code></pre>
<p><code class="hljs">hp</code>와 <code class="hljs">hq</code>의 유형을 추론하기에 린에게 완전한 표현식에 충분한 정보가 있음을 보세요. 하지만 더 긴 버전의 유형 주석을 사용하는 것은 증명을 더 가독성있게 하 에러를 잡고 고치는 걸 도와줍니다.</p>
<p><code class="hljs">Or</code>은 두 개의 생성자가 있기 때문에 우리는 익명 생성자 표기를 사용할 수 없습니다. 그러나 우리는 여전히 <code class="hljs">Or.elim h</code>대신 <code class="hljs">h.elim</code>와 같이 쓸 수 있습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">variable</span> (p q r : <span class="hljs-built_in">Prop</span>)

<span class="hljs-keyword">example</span> (h : p ∨ q) : q ∨ p :=
  h.elim (<span class="hljs-keyword">fun</span> hp =&gt; Or.inr hp) (<span class="hljs-keyword">fun</span> hq =&gt; Or.inl hq)
</code></pre>
<p>다시 한 번, 여러분은 그러한 간략화가 가독성을 높이는지 낮추는지 판단을 시험해보셔야 합니다.</p>
<h3><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/propositions_and_proofs.html#negation-and-falsity" id="negation-and-falsity">부정과 거짓</a></h3>
<p>부정 <code class="hljs">¬p</code>은 실제로 <code class="hljs">p → False</code>로 정의되어 있습니다. 그래서 우리는 <code class="hljs">p</code>로부터 모순을 유도함으로써 <code class="hljs">¬p</code>를 얻습니다. 마찬가지로 표현식 <code class="hljs">hnp hp</code>은 <code class="hljs">hp : p</code>과 <code class="hljs">hnp : ¬p</code>으로부터 <code class="hljs">False</code>의 증명을 만듭니다. 다음 예제는 <code class="hljs">(p → q) → ¬q → ¬p</code>의 증명을 만들기 위해 세 가지 규칙 모두를 사용합니다. (기호 <code class="hljs">¬</code>은 <code class="hljs">\not</code>이나  <code class="hljs">\neg</code>을 치는 것으로 만들어집니다.)</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">variable</span> (p q : <span class="hljs-built_in">Prop</span>)

<span class="hljs-keyword">example</span> (hpq : p → q) (hnq : ¬q) : ¬p :=
  <span class="hljs-keyword">fun</span> hp : p =&gt;
  <span class="hljs-built_in">show</span> False <span class="hljs-built_in">from</span> hnq (hpq hp)
</code></pre>
<p>연결사 <code class="hljs">False</code>은 하나의 제거 규칙 <code class="hljs">False.elim</code>을 갖습니다. 이것은 모순으로부터 어떤 것이든 도출된다는 사실을 표현합니다. 이 규칙은 때때로 <em>ex falso</em> (라틴어 <em>ex falso sequitur quodlibet</em>을 줄인 것), 또는 <em>폭발의 원리(principle of explosion)</em>라고 불립니다..</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">variable</span> (tp q : <span class="hljs-built_in">Prop</span>)

<span class="hljs-keyword">example</span> (hp : p) (hnp : ¬p) : q := False.elim (hnp hp)
</code></pre>
<p><code class="hljs">q</code>가 어떤 거짓 명제로부터 나온다는 사실은 <code class="hljs">False.elim</code>에 대한 암시적 인수이며 자동적으로 추론됩니다. 모순적인 가정들로부터 어떤 사실을 얻는 이런 패턴은 꽤 흔하고 <code class="hljs">absurd</code>로 표현됩니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">variable</span> (p q : <span class="hljs-built_in">Prop</span>)

<span class="hljs-keyword">example</span> (hp : p) (hnp : ¬p) : q := absurd hp hnp
</code></pre>
<p>여기 <code class="hljs">¬p → q → (q → p) → r</code>의 증명에 대한 예제가 있습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">variable</span> (p q r : <span class="hljs-built_in">Prop</span>)

<span class="hljs-keyword">example</span> (hnp : ¬p) (hq : q) (hqp : q → p) : r :=
  absurd (hqp hq) hnp
</code></pre>
<p>참고로 <code class="hljs">False</code>은 제거 규칙만 있듯이 <code class="hljs">True</code>는 도입 규칙 <code class="hljs">True.intro : true</code>만 있습니다. 다시 말하자면 <code class="hljs">True</code>는 단순히 참이고, 정식 증명 <code class="hljs">True.intro</code>를 가집니다.</p>
<h3><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/propositions_and_proofs.html#logical-equivalence" id="logical-equivalence">논리적 동등성</a></h3>
<p>표현식 <code class="hljs">Iff.intro h1 h2</code>은 <code class="hljs">h1 : p → q</code>과 <code class="hljs">h2 : q → p</code>으로부터  <code class="hljs">p ↔ q</code>의 증명을 생성합니다. 표현식 <code class="hljs">Iff.mp h</code>는 <code class="hljs">h : p ↔ q</code>으로부터 <code class="hljs">p → q</code>의 증명을 생성합니다. 마찬가지로 <code class="hljs">Iff.mpr h</code>는 <code class="hljs">h : p ↔ q</code>으로부터 <code class="hljs">q → p</code>의 증명을 생성합니다. 여기 <code class="hljs">p ∧ q ↔ q ∧ p</code>의 증명이 있습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">variable</span> (p q : <span class="hljs-built_in">Prop</span>)

<span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">a</span><span class="hljs-title">n</span><span class="hljs-title">d</span><span class="hljs-title">_</span><span class="hljs-title">sw</span><span class="hljs-title">a</span><span class="hljs-title">p</span> <span class="hljs-symbol">:</span></span> p ∧ q ↔ q ∧ p :=
  Iff.<span class="hljs-built_in">intro</span>
    (<span class="hljs-keyword">fun</span> h : p ∧ q =&gt;
     <span class="hljs-built_in">show</span> q ∧ p <span class="hljs-built_in">from</span> And.<span class="hljs-built_in">intro</span> (And.right h) (And.left h))
    (<span class="hljs-keyword">fun</span> h : q ∧ p =&gt;
     <span class="hljs-built_in">show</span> p ∧ q <span class="hljs-built_in">from</span> And.<span class="hljs-built_in">intro</span> (And.right h) (And.left h))

<span class="hljs-keyword">#check</span> and_swap p q    <span class="hljs-comment">-- p ∧ q ↔ q ∧ p</span>

<span class="hljs-keyword">variable</span> (h : p ∧ q)
<span class="hljs-keyword">example</span> : q ∧ p := Iff.mp (and_swap p q) h
</code></pre>
<p>우리는 앞과 뒷방향 증명으로부터 <code class="hljs">p ↔ q</code>의 증명을 구성하기 위해 익명 생성자 표기를 사용할 수 있습니다. 그리고 우리는 <code class="hljs">.</code>와  <code class="hljs">mp</code>과 <code class="hljs">mpr</code>을 사용한 표기를 쓸 수 있습니다. 그러므로 이전 예제는 다음과 같이 간결하게 쓸 수 있습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">variable</span> (p q : <span class="hljs-built_in">Prop</span>)

<span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">a</span><span class="hljs-title">n</span><span class="hljs-title">d</span><span class="hljs-title">_</span><span class="hljs-title">sw</span><span class="hljs-title">a</span><span class="hljs-title">p</span> <span class="hljs-symbol">:</span></span> p ∧ q ↔ q ∧ p :=
  ⟨ <span class="hljs-keyword">fun</span> h =&gt; ⟨h.right, h.left⟩, <span class="hljs-keyword">fun</span> h =&gt; ⟨h.right, h.left⟩ ⟩

<span class="hljs-keyword">example</span> (h : p ∧ q) : q ∧ p := (and_swap p q).mp h
</code></pre>
<h2><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/propositions_and_proofs.html#introducing-auxiliary-subgoals" id="introducing-auxiliary-subgoals">보조적인 세부 목표를 도입하기</a></h2>
<p>이곳은 린이 긴 증명을 구조화하도록 돕는 또다른 장치를 도입하기에 적절합니다. 주로  <code class="hljs">have</code> 생성자인데 이는 증명의 보조적인 세부목표를 도입합니다. 여기 이전 장에서 가져온 작은 예제가 있습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">variable</span> (p q : <span class="hljs-built_in">Prop</span>)

<span class="hljs-keyword">example</span> (h : p ∧ q) : q ∧ p :=
  <span class="hljs-built_in">have</span> hp : p := h.left
  <span class="hljs-built_in">have</span> hq : q := h.right
  <span class="hljs-built_in">show</span> q ∧ p <span class="hljs-built_in">from</span> And.<span class="hljs-built_in">intro</span> hq hp
</code></pre>
<p>내부적으로 표현식 <code class="hljs">have h : p := s; t</code>은 항 <code class="hljs">(fun (h : p) =&gt; t) s</code>을 만듭니다. 다시 말하자면 <code class="hljs">s</code>는 <code class="hljs">p</code>의 증명입니다. <code class="hljs">h : p</code>를 가정한 <code class="hljs">t</code>는 원하는 결론의 증명입니다. 그리고 이 둘은 람다 추상화와 적용으로 결합되어 있습니다. 이 단순한 장치는 긴 증명을 구조화 해야 할 때 아주 유용합니다. 왜냐하면 우리는 간간히 <code class="hljs">have</code>를 최종 목표로 이끄는 주춧돌로써 쓰기 때문입다.</p>
<p>린은 또 구조화된 목표로부터 후방향 추론 방식을 지원합니다. 이것은 일상 수학에서 "보여주기에 충분하다" 구성을 모델링 한 것입니다. 다음 예제는 이전 증명에서 마지막 두 줄을 단순히 바꾼 것입니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">variable</span> (p q : <span class="hljs-built_in">Prop</span>)

<span class="hljs-keyword">example</span> (h : p ∧ q) : q ∧ p :=
  <span class="hljs-built_in">have</span> hp : p := h.left
  <span class="hljs-built_in">suffices</span> hq : q <span class="hljs-built_in">from</span> And.<span class="hljs-built_in">intro</span> hq hp
  <span class="hljs-built_in">show</span> q <span class="hljs-built_in">from</span> And.right h
</code></pre>
<p><code class="hljs">suffices hq : q</code>을 쓰는 것은 우리에게 두 목표를 남깁니다. 첫 째, 우리는 원래 목표<code class="hljs">q ∧ p</code> 과 추가적인 가정 <code class="hljs">hq : q</code>으로 증명함으로써 <code class="hljs">q</code>임을 충분히 보일 수 있는 것을 보여야 합니다. 마지막으로 <code class="hljs">q</code>임을 보여야 합니다.</p>
<h2><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/propositions_and_proofs.html#a-name_classicalaclassical-logic" id="a-name_classicalaclassical-logic"></a><a name="_classical"></a>고전 논리</h2>
<p>지금까지 우리가 본 도입과 제거 규칙은 모두 직관적입니다. 그 말은 그들은 유형으로써 명제 대응에 기반한 논리 연결사의 계산적인 이해를 반영하고 있다는 것입니다. 평범한 고전 논리는 여기에 배중률 <code class="hljs">p ∨ ¬p</code>을 추가합니다. 이 원리를 사용하기 위해서 여러분은 classical 이름공간을 열어야 합니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">open</span> Classical

<span class="hljs-keyword">variable</span> (p : <span class="hljs-built_in">Prop</span>)
<span class="hljs-keyword">#check</span> em p
</code></pre>
<p>직관적으로 구성자 "논리합"은 아주 강력합니다.  <code class="hljs">p ∨ q</code>라 주장하는 것은 각 경우를 아는 것과 같습니다. 만약 <code class="hljs">RH</code>가 리만 가설을 나타낸다면 우리가 아직 어느쪽에 분리자를 주장하지 않았더라도 고전 수학자는 <code class="hljs">RH ∨ ¬RH</code>라고 기꺼이 주장할 겁니다.</p>
<p>배중률의 한 결과는 이중 부정 제거의 원리입니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">open</span> Classical

<span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">d</span><span class="hljs-title">n</span><span class="hljs-title">e</span> <span class="hljs-params">{p : <span class="hljs-built_in">Prop</span>}</span> <span class="hljs-params">(h : ¬¬p)</span> <span class="hljs-symbol">:</span></span> p :=
  Or.elim (em p)
    (<span class="hljs-keyword">fun</span> hp : p =&gt; hp)
    (<span class="hljs-keyword">fun</span> hnp : ¬p =&gt; absurd hnp h)
</code></pre>
<p>이중 부정 제거는 여러분에게 어떤 명제  <code class="hljs">p</code>에 대해서 <code class="hljs">¬p</code>를 가정하면 <code class="hljs">¬¬p</code>의 증명을 고려하기 때문에 <code class="hljs">false</code>를 유도할 수 있게 허용해 줍니다. 다시 말하자면 이중 부정 제거는 직관주의적 논리에서 일반적으로 불가능한 귀류법을 사용한 증명을 허용합니다. 연습으로 여러분은 역을 증명해보세요, 즉 <code class="hljs">em</code>이 <code class="hljs">dne</code>로부터 증명될 수 있음을 보이세요.</p>
<p>고전적 공리도 여러분에게 <code class="hljs">em</code>에 호소하여 정당화될 수 있는 추가적인 증명 패턴의 접근을 줍니다. 예를 들어 누군가는 경우를 나눠 증명을 도출할 수 있습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">open</span> Classical
<span class="hljs-keyword">variable</span> (p : <span class="hljs-built_in">Prop</span>)

<span class="hljs-keyword">example</span> (h : ¬¬p) : p :=
  byCases
    (<span class="hljs-keyword">fun</span> h1 : p =&gt; h1)
    (<span class="hljs-keyword">fun</span> h1 : ¬p =&gt; absurd h1 h)
</code></pre>
<p>또는 여러분은 귀류법으로 증명을 도출할 수 있습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">open</span> Classical
<span class="hljs-keyword">variable</span> (p : <span class="hljs-built_in">Prop</span>)

<span class="hljs-keyword">example</span> (h : ¬¬p) : p :=
  byContradiction
    (<span class="hljs-keyword">fun</span> h1 : ¬p =&gt;
     <span class="hljs-built_in">show</span> False <span class="hljs-built_in">from</span> h h1)
</code></pre>
<p>여러분이 직관적으로 생각하는데 익숙치 않다면 고전 추론이 사용되는 곳을 이해하는데 약간의 시간이 소요될지도 모릅니다. 다음 예제에서 이게 필요한데 왜냐하면 직관주의적 관점에서 <code class="hljs">p</code>와 <code class="hljs">q</code> 둘 다 참이 아니라는 것을 아는 것은 여러분에게 반드시 어떤 것이 거짓이라는 것을 말해줄 필요는 없기 때문입니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">open</span> Classical
<span class="hljs-keyword">variable</span> (p q : <span class="hljs-built_in">Prop</span>)

<span class="hljs-comment">-- 시작</span>
<span class="hljs-keyword">example</span> (h : ¬(p ∧ q)) : ¬p ∨ ¬q :=
  Or.elim (em p)
    (<span class="hljs-keyword">fun</span> hp : p =&gt;
      Or.inr
        (<span class="hljs-built_in">show</span> ¬q <span class="hljs-built_in">from</span>
          <span class="hljs-keyword">fun</span> hq : q =&gt;
          h ⟨hp, hq⟩))
    (<span class="hljs-keyword">fun</span> hp : ¬p =&gt;
      Or.inl hp)
</code></pre>
<p>우리는 나중에 <em>배중률과 이중 부정 제거와 같은 원칙이 허용되는 직관주의적 논리 </em> 상황이 있음을 나중에 보게 될 것입니다. 그리고 린은 그런 맥락에서 배중률에 의존하지 않는 고전논리의 사용을 지원합니다.</p>
<p>고전 추론을 지원하기 위해 린에서 사용된 모든 공리의 리스트는 <a href="https://leanprover.github.io/theorem_proving_in_lean4/axioms_and_computations.html">공리와 계산</a>에서 다뤄집니다.</p>
<h2><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/propositions_and_proofs.html#examples-of-propositional-validities" id="examples-of-propositional-validities">명제 유효성 예제</a></h2>
<p>린의 표준 라이브러리는 명제 논리의 유효한 많은 진술들이 담겨있고 그 모든 것들은 여러분들의 주장을 증명하는데 자유롭게 사용될 수 있습니다. 다음 리스트는 흔히 사용되는 항등식들을 포함합니다.</p>
<p>교환성</p>
<ol>
<li><code class="hljs">p ∧ q ↔ q ∧ p</code></li>
<li><code class="hljs">p ∨ q ↔ q ∨ p</code></li>
</ol>
<p>결합성</p>
<ol start="3">
<li><code class="hljs">(p ∧ q) ∧ r ↔ p ∧ (q ∧ r)</code></li>
<li><code class="hljs">(p ∨ q) ∨ r ↔ p ∨ (q ∨ r)</code></li>
</ol>
<p>분배성</p>
<ol start="5">
<li><code class="hljs">p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r)</code></li>
<li><code class="hljs">p ∨ (q ∧ r) ↔ (p ∨ q) ∧ (p ∨ r)</code></li>
</ol>
<p>다른 특성들</p>
<ol start="7">
<li><code class="hljs">(p → (q → r)) ↔ (p ∧ q → r)</code></li>
<li><code class="hljs">((p ∨ q) → r) ↔ (p → r) ∧ (q → r)</code></li>
<li><code class="hljs">¬(p ∨ q) ↔ ¬p ∧ ¬q</code></li>
<li><code class="hljs">¬p ∨ ¬q → ¬(p ∧ q)</code></li>
<li><code class="hljs">¬(p ∧ ¬p)</code></li>
<li><code class="hljs">p ∧ ¬q → ¬(p → q)</code></li>
<li><code class="hljs">¬p → (p → q)</code></li>
<li><code class="hljs">(¬p ∨ q) → (p → q)</code></li>
<li><code class="hljs">p ∨ False ↔ p</code></li>
<li><code class="hljs">p ∧ False ↔ False</code></li>
<li><code class="hljs">¬(p ↔ ¬p)</code></li>
<li><code class="hljs">(p → q) → (¬q → ¬p)</code></li>
</ol>
<p>이것은 고전 추론 규칙이 필요합니다.</p>
<ol start="19">
<li><code class="hljs">(p → r ∨ s) → ((p → r) ∨ (p → s))</code></li>
<li><code class="hljs">¬(p ∧ q) → ¬p ∨ ¬q</code></li>
<li><code class="hljs">¬(p → q) → p ∧ ¬q</code></li>
<li><code class="hljs">(p → q) → (¬p ∨ q)</code></li>
<li><code class="hljs">(¬q → ¬p) → (p → q)</code></li>
<li><code class="hljs">p ∨ ¬p</code></li>
<li><code class="hljs">(((p → q) → p) → p)</code></li>
</ol>
<p><code class="hljs">sorry</code> 식별자는 어떤 증명이든 마법같이 만듭니다. 혹은 임의의 데이터 유형의 객체를 제공합니다. 물론 증명 방법으로 건전하지 않습니다. -- 예를 들어, 여러분은 <code class="hljs">False</code> 을 증명하는데 그것을 사용할 수 있습니다. --그러면 린은 그것에 의존하는 정리를 불러오거나 그런 파일을 사용할 때 심각한 경고를 보냅니다. 하지만 이것은 긴 증명을 점진적으로 만들어 나갈 때 유용합니다. 하향식으로 증명 작성을 하작하려면 보조 증명에 <code class="hljs">sorry</code>를 채워 사용하세요. 린이 모든 <code class="hljs">sorry</code>에 대한 말을 받아들이게 만드세요. 그렇지 않으면 여러분이 고쳐야 하는 에러가 생깁니다. 그리고 다시 뒤로 돌아가 각각의 <code class="hljs">sorry</code>가 더 남지 않을 때까지 실제 증명으로 바꾸세요.</p>
<p>여기 또 유용한 트릭이 있습니다. <code class="hljs">sorry</code>를 사용하는 것 대신 밑줄 문자  <code class="hljs">_</code>를 자리 차지자로 사용할 수 있습니다. 이것이 린에게 인수가 암시적이고 자동적으로 채우게 함을 의미한다는 것을 기억하세요. 만약 린이 그렇게 하려고 했는데 실패한다면 다음에 오는 항의 유형을 기대했다면서 "어떻게 자리 차지자를 동기화 해야할 지 모르겠다"는 오류 메시지를 반환합니다. 그리고 모든 객체와 가정들은 맥락에서 이용가능합니다. 다시 말하자면 각 해결되지 않은 자리 차지자에 대해 린은 그 지점에서 채워져야 할 작은 목표를 보고합니다. 그럼 여러분은 이 자리 차지자들을 점차 재우는 것으로 증명을 구성할 수 있습니다.</p>
<p>참고로 여기 위쪽의 리스트에서 가져온 유효성의 증명 예시가 두 개 있습니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">open</span> Classical

<span class="hljs-comment">-- 분배성</span>
<span class="hljs-keyword">example</span> (p q r : <span class="hljs-built_in">Prop</span>) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) :=
  Iff.<span class="hljs-built_in">intro</span>
    (<span class="hljs-keyword">fun</span> h : p ∧ (q ∨ r) =&gt;
      <span class="hljs-built_in">have</span> hp : p := h.left
      Or.elim (h.right)
        (<span class="hljs-keyword">fun</span> hq : q =&gt;
          <span class="hljs-built_in">show</span> (p ∧ q) ∨ (p ∧ r) <span class="hljs-built_in">from</span> Or.inl ⟨hp, hq⟩)
        (<span class="hljs-keyword">fun</span> hr : r =&gt;
          <span class="hljs-built_in">show</span> (p ∧ q) ∨ (p ∧ r) <span class="hljs-built_in">from</span> Or.inr ⟨hp, hr⟩))
    (<span class="hljs-keyword">fun</span> h : (p ∧ q) ∨ (p ∧ r) =&gt;
      Or.elim h
        (<span class="hljs-keyword">fun</span> hpq : p ∧ q =&gt;
          <span class="hljs-built_in">have</span> hp : p := hpq.left
          <span class="hljs-built_in">have</span> hq : q := hpq.right
          <span class="hljs-built_in">show</span> p ∧ (q ∨ r) <span class="hljs-built_in">from</span> ⟨hp, Or.inl hq⟩)
        (<span class="hljs-keyword">fun</span> hpr : p ∧ r =&gt;
          <span class="hljs-built_in">have</span> hp : p := hpr.left
          <span class="hljs-built_in">have</span> hr : r := hpr.right
          <span class="hljs-built_in">show</span> p ∧ (q ∨ r) <span class="hljs-built_in">from</span> ⟨hp, Or.inr hr⟩))

<span class="hljs-comment">-- 고전 추론을 필요로 하는 예제</span>
<span class="hljs-keyword">example</span> (p q : <span class="hljs-built_in">Prop</span>) : ¬(p ∧ ¬q) → (p → q) :=
  <span class="hljs-keyword">fun</span> h : ¬(p ∧ ¬q) =&gt;
  <span class="hljs-keyword">fun</span> hp : p =&gt;
  <span class="hljs-built_in">show</span> q <span class="hljs-built_in">from</span>
    Or.elim (em q)
      (<span class="hljs-keyword">fun</span> hq : q =&gt; hq)
      (<span class="hljs-keyword">fun</span> hnq : ¬q =&gt; absurd (And.<span class="hljs-built_in">intro</span> hp hnq) h)
</code></pre>
<h2><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/propositions_and_proofs.html#exercises" id="exercises">연습문제</a></h2>
<p>다음 항등식을 증명하세요. "sorry"를 실제 증명으로 대체하세요.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">variable</span> (p q r : <span class="hljs-built_in">Prop</span>)

<span class="hljs-comment">-- ∧ 과 ∨의 교환성</span>
<span class="hljs-keyword">example</span> : p ∧ q ↔ q ∧ p := <span class="hljs-strong">sorry</span>
<span class="hljs-keyword">example</span> : p ∨ q ↔ q ∨ p := <span class="hljs-strong">sorry</span>

<span class="hljs-comment">-- ∧ 과 ∨의 결합성</span>
<span class="hljs-keyword">example</span> : (p ∧ q) ∧ r ↔ p ∧ (q ∧ r) := <span class="hljs-strong">sorry</span>
<span class="hljs-keyword">example</span> : (p ∨ q) ∨ r ↔ p ∨ (q ∨ r) := <span class="hljs-strong">sorry</span>

<span class="hljs-comment">--분배성</span>
<span class="hljs-keyword">example</span> : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) := <span class="hljs-strong">sorry</span>
<span class="hljs-keyword">example</span> : p ∨ (q ∧ r) ↔ (p ∨ q) ∧ (p ∨ r) := <span class="hljs-strong">sorry</span>

<span class="hljs-comment">-- 다른 특성</span>
<span class="hljs-keyword">example</span> : (p → (q → r)) ↔ (p ∧ q → r) := <span class="hljs-strong">sorry</span>
<span class="hljs-keyword">example</span> : ((p ∨ q) → r) ↔ (p → r) ∧ (q → r) := <span class="hljs-strong">sorry</span>
<span class="hljs-keyword">example</span> : ¬(p ∨ q) ↔ ¬p ∧ ¬q := <span class="hljs-strong">sorry</span>
<span class="hljs-keyword">example</span> : ¬p ∨ ¬q → ¬(p ∧ q) := <span class="hljs-strong">sorry</span>
<span class="hljs-keyword">example</span> : ¬(p ∧ ¬p) := <span class="hljs-strong">sorry</span>
<span class="hljs-keyword">example</span> : p ∧ ¬q → ¬(p → q) := <span class="hljs-strong">sorry</span>
<span class="hljs-keyword">example</span> : ¬p → (p → q) := <span class="hljs-strong">sorry</span>
<span class="hljs-keyword">example</span> : (¬p ∨ q) → (p → q) := <span class="hljs-strong">sorry</span>
<span class="hljs-keyword">example</span> : p ∨ False ↔ p := <span class="hljs-strong">sorry</span>
<span class="hljs-keyword">example</span> : p ∧ False ↔ False := <span class="hljs-strong">sorry</span>
<span class="hljs-keyword">example</span> : (p → q) → (¬q → ¬p) := <span class="hljs-strong">sorry</span>
</code></pre>
<p>다음 항등식을 증명하세요. "sorry"를 실제 증명으로 대체하세요. 이것은 고전 추론 규칙이 필요합니다.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="클립보드에 복사하기" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">open</span> Classical

<span class="hljs-keyword">variable</span> (p q r s : <span class="hljs-built_in">Prop</span>)

<span class="hljs-keyword">example</span> : (p → r ∨ s) → ((p → r) ∨ (p → s)) := <span class="hljs-strong">sorry</span>
<span class="hljs-keyword">example</span> : ¬(p ∧ q) → ¬p ∨ ¬q := <span class="hljs-strong">sorry</span>
<span class="hljs-keyword">example</span> : ¬(p → q) → p ∧ ¬q := <span class="hljs-strong">sorry</span>
<span class="hljs-keyword">example</span> : (p → q) → (¬p ∨ q) := <span class="hljs-strong">sorry</span>
<span class="hljs-keyword">example</span> : (¬q → ¬p) → (p → q) := <span class="hljs-strong">sorry</span>
<span class="hljs-keyword">example</span> : p ∨ ¬p := <span class="hljs-strong">sorry</span>
<span class="hljs-keyword">example</span> : (((p → q) → p) → p) := <span class="hljs-strong">sorry</span>
</code></pre>
<p>고전 논리를 사용하지 않고 <code class="hljs">¬(p ↔ ¬p)</code>을 증명하세요.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="https://leanprover.github.io/theorem_proving_in_lean4/dependent_type_theory.html" class="mobile-nav-chapters previous" title="이전 장" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html" class="mobile-nav-chapters next" title="다음 장" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="https://leanprover.github.io/theorem_proving_in_lean4/dependent_type_theory.html" class="nav-chapters previous" title="이전 장" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html" class="nav-chapters next" title="다음 장" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="./Propositions and Proofs - Theorem Proving in Lean 4_files/elasticlunr.min.js.다운로드" type="text/javascript" charset="utf-8"></script>
        <script src="./Propositions and Proofs - Theorem Proving in Lean 4_files/mark.min.js.다운로드" type="text/javascript" charset="utf-8"></script>
        <script src="./Propositions and Proofs - Theorem Proving in Lean 4_files/searcher.js.다운로드" type="text/javascript" charset="utf-8"></script>
        

        <script src="./Propositions and Proofs - Theorem Proving in Lean 4_files/clipboard.min.js.다운로드" type="text/javascript" charset="utf-8"></script>
        <script src="./Propositions and Proofs - Theorem Proving in Lean 4_files/highlight.js.다운로드" type="text/javascript" charset="utf-8"></script>
        <script src="./Propositions and Proofs - Theorem Proving in Lean 4_files/book.js.다운로드" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    

</body></html>