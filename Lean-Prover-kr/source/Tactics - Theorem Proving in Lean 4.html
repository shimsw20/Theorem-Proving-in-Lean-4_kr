<!DOCTYPE html>
<!-- saved from url=(0066)https://leanprover.github.io/theorem_proving_in_lean4/tactics.html -->
<html lang="en" class="js sidebar-visible light"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <!-- Book generated using mdBook -->
        
        <title>Tactics - Theorem Proving in Lean 4</title>
        
        


        <!-- Custom HTML head -->
        


        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="rgba(0, 0, 0, 0)">

        
        <link rel="icon" href="https://leanprover.github.io/theorem_proving_in_lean4/favicon.svg">
        
        
        <link rel="shortcut icon" href="https://leanprover.github.io/theorem_proving_in_lean4/favicon.png">
        
        <link rel="stylesheet" href="./Tactics - Theorem Proving in Lean 4_files/variables.css">
        <link rel="stylesheet" href="./Tactics - Theorem Proving in Lean 4_files/general.css">
        <link rel="stylesheet" href="./Tactics - Theorem Proving in Lean 4_files/chrome.css">
        
        <link rel="stylesheet" href="./Tactics - Theorem Proving in Lean 4_files/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="./Tactics - Theorem Proving in Lean 4_files/font-awesome.css">
        
        <link rel="stylesheet" href="./Tactics - Theorem Proving in Lean 4_files/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="./Tactics - Theorem Proving in Lean 4_files/highlight.css">
        <link rel="stylesheet" href="./Tactics - Theorem Proving in Lean 4_files/tomorrow-night.css" disabled="">
        <link rel="stylesheet" href="./Tactics - Theorem Proving in Lean 4_files/ayu-highlight.css" disabled="">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents" aria-hidden="false">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="https://leanprover.github.io/theorem_proving_in_lean4/title_page.html" tabindex="0">Theorem Proving in Lean 4</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/introduction.html" tabindex="0"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/dependent_type_theory.html" tabindex="0"><strong aria-hidden="true">2.</strong> Dependent Type Theory</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/propositions_and_proofs.html" tabindex="0"><strong aria-hidden="true">3.</strong> Propositions and Proofs</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html" tabindex="0"><strong aria-hidden="true">4.</strong> Quantifiers and Equality</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/tactics.html" class="active" tabindex="0"><strong aria-hidden="true">5.</strong> Tactics</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/interacting_with_lean.html" tabindex="0"><strong aria-hidden="true">6.</strong> Interacting with Lean</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/inductive_types.html" tabindex="0"><strong aria-hidden="true">7.</strong> Inductive Types</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html" tabindex="0"><strong aria-hidden="true">8.</strong> Induction and Recursion</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/structures_and_records.html" tabindex="0"><strong aria-hidden="true">9.</strong> Structures and Records</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/type_classes.html" tabindex="0"><strong aria-hidden="true">10.</strong> Type Classes</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/conv.html" tabindex="0"><strong aria-hidden="true">11.</strong> The Conversion Tactic Mode</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/axioms_and_computation.html" tabindex="0"><strong aria-hidden="true">12.</strong> Axioms and Computation</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar" style="top: 0px;">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar" aria-expanded="true">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Theorem Proving in Lean 4</h1>

                    <div class="right-buttons">
                        
                        <a href="https://leanprover.github.io/theorem_proving_in_lean4/print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/leanprover/theorem_proving_in_lean4" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/tactics.html#tactics" id="tactics">Tactics</a></h1>
<p>In this chapter, we describe an alternative approach to constructing
proofs, using <em>tactics</em>.  A proof term is a representation of a
mathematical proof; tactics are commands, or instructions, that
describe how to build such a proof. Informally, you might begin a
mathematical proof by saying "to prove the forward direction, unfold
the definition, apply the previous lemma, and simplify." Just as these
are instructions that tell the reader how to find the relevant proof,
tactics are instructions that tell Lean how to construct a proof
term. They naturally support an incremental style of writing proofs,
in which you decompose a proof and work on goals one step at a time.</p>
<p>We will describe proofs that consist of sequences of tactics as
"tactic-style" proofs, to contrast with the ways of writing proof
terms we have seen so far, which we will call "term-style"
proofs. Each style has its own advantages and disadvantages. For
example, tactic-style proofs can be harder to read, because they
require the reader to predict or guess the results of each
instruction. But they can also be shorter and easier to
write. Moreover, tactics offer a gateway to using Lean's automation,
since automated procedures are themselves tactics.</p>
<h2><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/tactics.html#entering-tactic-mode" id="entering-tactic-mode">Entering Tactic Mode</a></h2>
<p>Conceptually, stating a theorem or introducing a <code class="hljs">have</code> statement
creates a goal, namely, the goal of constructing a term with the
expected type. For example, the following creates the goal of
constructing a term of type <code class="hljs">p ∧ q ∧ p</code>, in a context with constants
<code class="hljs">p q : Prop</code>, <code class="hljs">hp : p</code> and <code class="hljs">hq : q</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">s</span><span class="hljs-title">t</span> <span class="hljs-params">(p q : <span class="hljs-built_in">Prop</span>)</span> <span class="hljs-params">(hp : p)</span> <span class="hljs-params">(hq : q)</span> <span class="hljs-symbol">:</span></span> p ∧ q ∧ p :=
  <span class="hljs-strong">sorry</span>
</code></pre>
<p>You can write this goal as follows:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="hljs">    p : Prop, q : Prop, hp : p, hq : q ⊢ p ∧ q ∧ p
</code></pre>
<p>Indeed, if you replace the "sorry" by an underscore in the example
above, Lean will report that it is exactly this goal that has been
left unsolved.</p>
<p>Ordinarily, you meet such a goal by writing an explicit term. But
wherever a term is expected, Lean allows us to insert instead a <code class="hljs">by &lt;tactics&gt;</code> block, where <code class="hljs">&lt;tactics&gt;</code> is a sequence of commands,
separated by semicolons or line breaks. You can prove the theorem above
in that way:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">s</span><span class="hljs-title">t</span> <span class="hljs-params">(p q : <span class="hljs-built_in">Prop</span>)</span> <span class="hljs-params">(hp : p)</span> <span class="hljs-params">(hq : q)</span> <span class="hljs-symbol">:</span></span> p ∧ q ∧ p :=
  <span class="hljs-keyword">by</span> <span class="hljs-built_in">apply</span> And.<span class="hljs-built_in">intro</span>
     <span class="hljs-built_in">exact</span> hp
     <span class="hljs-built_in">apply</span> And.<span class="hljs-built_in">intro</span>
     <span class="hljs-built_in">exact</span> hq
     <span class="hljs-built_in">exact</span> hp
</code></pre>
<p>We often put the <code class="hljs">by</code> keyword on the preceding line, and write the
example above as</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">s</span><span class="hljs-title">t</span> <span class="hljs-params">(p q : <span class="hljs-built_in">Prop</span>)</span> <span class="hljs-params">(hp : p)</span> <span class="hljs-params">(hq : q)</span> <span class="hljs-symbol">:</span></span> p ∧ q ∧ p := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">apply</span> And.<span class="hljs-built_in">intro</span>
  <span class="hljs-built_in">exact</span> hp
  <span class="hljs-built_in">apply</span> And.<span class="hljs-built_in">intro</span>
  <span class="hljs-built_in">exact</span> hq
  <span class="hljs-built_in">exact</span> hp
</code></pre>
<p>The <code class="hljs">apply</code> tactic applies an expression, viewed as denoting a
function with zero or more arguments. It unifies the conclusion with
the expression in the current goal, and creates new goals for the
remaining arguments, provided that no later arguments depend on
them. In the example above, the command <code class="hljs">apply And.intro</code> yields two
subgoals:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="hljs">    case left
    p : Prop,
    q : Prop,
    hp : p,
    hq : q
    ⊢ p

    case right
    p : Prop,
    q : Prop,
    hp : p,
    hq : q
    ⊢ q ∧ p
</code></pre>
<p>The first goal is met with the command <code class="hljs">exact hp</code>. The <code class="hljs">exact</code>
command is just a variant of <code class="hljs">apply</code> which signals that the
expression given should fill the goal exactly. It is good form to use
it in a tactic proof, since its failure signals that something has
gone wrong. It is also more robust than <code class="hljs">apply</code>, since the
elaborator takes the expected type, given by the target of the goal,
into account when processing the expression that is being applied. In
this case, however, <code class="hljs">apply</code> would work just as well.</p>
<p>You can see the resulting proof term with the <code class="hljs">#print</code> command:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="Show hidden lines" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="boring"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">s</span><span class="hljs-title">t</span> <span class="hljs-params">(p q : <span class="hljs-built_in">Prop</span>)</span> <span class="hljs-params">(hp : p)</span> <span class="hljs-params">(hq : q)</span> <span class="hljs-symbol">:</span></span> p ∧ q ∧ p := <span class="hljs-keyword">by</span>
</span><span class="boring"> <span class="hljs-built_in">apply</span> And.<span class="hljs-built_in">intro</span>
</span><span class="boring"> <span class="hljs-built_in">exact</span> hp
</span><span class="boring"> <span class="hljs-built_in">apply</span> And.<span class="hljs-built_in">intro</span>
</span><span class="boring"> <span class="hljs-built_in">exact</span> hq
</span><span class="boring"> <span class="hljs-built_in">exact</span> hp
</span><span class="hljs-keyword">#print</span> test
</code></pre>
<p>You can write a tactic script incrementally. In VS Code, you can open
a window to display messages by pressing <code class="hljs">Ctrl-Shift-Enter</code>, and
that window will then show you the current goal whenever the cursor is
in a tactic block. In Emacs, you can see the goal at the end of any
line by pressing <code class="hljs">C-c C-g</code>, or see the remaining goal in an
incomplete proof by putting the cursor after the first character of
the last tactic. If the proof is incomplete, the token <code class="hljs">by</code> is
decorated with a red squiggly line, and the error message contains the
remaining goals.</p>
<p>Tactic commands can take compound expressions, not just single
identifiers. The following is a shorter version of the preceding
proof:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">s</span><span class="hljs-title">t</span> <span class="hljs-params">(p q : <span class="hljs-built_in">Prop</span>)</span> <span class="hljs-params">(hp : p)</span> <span class="hljs-params">(hq : q)</span> <span class="hljs-symbol">:</span></span> p ∧ q ∧ p := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">apply</span> And.<span class="hljs-built_in">intro</span> hp
  <span class="hljs-built_in">exact</span> And.<span class="hljs-built_in">intro</span> hq hp
</code></pre>
<p>Unsurprisingly, it produces exactly the same proof term.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="Show hidden lines" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="boring"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">s</span><span class="hljs-title">t</span> <span class="hljs-params">(p q : <span class="hljs-built_in">Prop</span>)</span> <span class="hljs-params">(hp : p)</span> <span class="hljs-params">(hq : q)</span> <span class="hljs-symbol">:</span></span> p ∧ q ∧ p := <span class="hljs-keyword">by</span>
</span><span class="boring"> <span class="hljs-built_in">apply</span> And.<span class="hljs-built_in">intro</span> hp
</span><span class="boring"> <span class="hljs-built_in">exact</span> And.<span class="hljs-built_in">intro</span> hq hp
</span><span class="hljs-keyword">#print</span> test
</code></pre>
<p>Multiple tactic applications can be written in a single line by concatenating with a semicolon.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">s</span><span class="hljs-title">t</span> <span class="hljs-params">(p q : <span class="hljs-built_in">Prop</span>)</span> <span class="hljs-params">(hp : p)</span> <span class="hljs-params">(hq : q)</span> <span class="hljs-symbol">:</span></span> p ∧ q ∧ p := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">apply</span> And.<span class="hljs-built_in">intro</span> hp; <span class="hljs-built_in">exact</span> And.<span class="hljs-built_in">intro</span> hq hp
</code></pre>
<p>Tactics that may produce multiple subgoals often tag them. For
example, the tactic <code class="hljs">apply And.intro</code> tagged the first sugoal as
<code class="hljs">left</code>, and the second as <code class="hljs">right</code>. In the case of the <code class="hljs">apply</code>
tactic, the tags are inferred from the parameters names used in the
<code class="hljs">And.intro</code> declaration. You can structure your tactics using the
notation <code class="hljs">case &lt;tag&gt; =&gt; &lt;tactics&gt;</code>. The following is a structured
version of our first tactic proof in this chapter.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">s</span><span class="hljs-title">t</span> <span class="hljs-params">(p q : <span class="hljs-built_in">Prop</span>)</span> <span class="hljs-params">(hp : p)</span> <span class="hljs-params">(hq : q)</span> <span class="hljs-symbol">:</span></span> p ∧ q ∧ p := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">apply</span> And.<span class="hljs-built_in">intro</span>
  <span class="hljs-built_in">case</span> left =&gt; <span class="hljs-built_in">exact</span> hp
  <span class="hljs-built_in">case</span> right =&gt;
    <span class="hljs-built_in">apply</span> And.<span class="hljs-built_in">intro</span>
    <span class="hljs-built_in">case</span> left =&gt; <span class="hljs-built_in">exact</span> hq
    <span class="hljs-built_in">case</span> right =&gt; <span class="hljs-built_in">exact</span> hp
</code></pre>
<p>You can solve the subgoal <code class="hljs">right</code> before <code class="hljs">left</code> using the <code class="hljs">case</code>
notation</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">s</span><span class="hljs-title">t</span> <span class="hljs-params">(p q : <span class="hljs-built_in">Prop</span>)</span> <span class="hljs-params">(hp : p)</span> <span class="hljs-params">(hq : q)</span> <span class="hljs-symbol">:</span></span> p ∧ q ∧ p := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">apply</span> And.<span class="hljs-built_in">intro</span>
  <span class="hljs-built_in">case</span> right =&gt;
    <span class="hljs-built_in">apply</span> And.<span class="hljs-built_in">intro</span>
    <span class="hljs-built_in">case</span> left =&gt; <span class="hljs-built_in">exact</span> hq
    <span class="hljs-built_in">case</span> right =&gt; <span class="hljs-built_in">exact</span> hp
  <span class="hljs-built_in">case</span> left =&gt; <span class="hljs-built_in">exact</span> hp
</code></pre>
<p>Note that Lean hides the other goals inside the <code class="hljs">case</code> block. We say
it is "focusing" on the selected goal.  Moreover, Lean flags an error
if the selected goal is not fully solved at the end of the <code class="hljs">case</code>
block.</p>
<p>For simple sugoals, it may not be worth selecting a subgoal using its
tag, but you may still want to structure the proof. Lean also provides
the "bullet" notation <code class="hljs">. &lt;tactics&gt;</code> (or <code class="hljs">· &lt;tactics&gt;</code>) for
structuring proof.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">s</span><span class="hljs-title">t</span> <span class="hljs-params">(p q : <span class="hljs-built_in">Prop</span>)</span> <span class="hljs-params">(hp : p)</span> <span class="hljs-params">(hq : q)</span> <span class="hljs-symbol">:</span></span> p ∧ q ∧ p := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">apply</span> And.<span class="hljs-built_in">intro</span>
  . <span class="hljs-built_in">exact</span> hp
  . <span class="hljs-built_in">apply</span> And.<span class="hljs-built_in">intro</span>
    . <span class="hljs-built_in">exact</span> hq
    . <span class="hljs-built_in">exact</span> hp
</code></pre>
<h2><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/tactics.html#basic-tactics" id="basic-tactics">Basic Tactics</a></h2>
<p>In addition to <code class="hljs">apply</code> and <code class="hljs">exact</code>, another useful tactic is
<code class="hljs">intro</code>, which introduces a hypothesis. What follows is an example
of an identity from propositional logic that we proved in a previous
chapter, now proved using tactics.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> (p q r : <span class="hljs-built_in">Prop</span>) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">apply</span> Iff.<span class="hljs-built_in">intro</span>
  . <span class="hljs-built_in">intro</span> h
    <span class="hljs-built_in">apply</span> Or.elim (And.right h)
    . <span class="hljs-built_in">intro</span> hq
      <span class="hljs-built_in">apply</span> Or.inl
      <span class="hljs-built_in">apply</span> And.<span class="hljs-built_in">intro</span>
      . <span class="hljs-built_in">exact</span> And.left h
      . <span class="hljs-built_in">exact</span> hq
    . <span class="hljs-built_in">intro</span> hr
      <span class="hljs-built_in">apply</span> Or.inr
      <span class="hljs-built_in">apply</span> And.<span class="hljs-built_in">intro</span>
      . <span class="hljs-built_in">exact</span> And.left h
      . <span class="hljs-built_in">exact</span> hr
  . <span class="hljs-built_in">intro</span> h
    <span class="hljs-built_in">apply</span> Or.elim h
    . <span class="hljs-built_in">intro</span> hpq
      <span class="hljs-built_in">apply</span> And.<span class="hljs-built_in">intro</span>
      . <span class="hljs-built_in">exact</span> And.left hpq
      . <span class="hljs-built_in">apply</span> Or.inl
        <span class="hljs-built_in">exact</span> And.right hpq
    . <span class="hljs-built_in">intro</span> hpr
      <span class="hljs-built_in">apply</span> And.<span class="hljs-built_in">intro</span>
      . <span class="hljs-built_in">exact</span> And.left hpr
      . <span class="hljs-built_in">apply</span> Or.inr
        <span class="hljs-built_in">exact</span> And.right hpr
</code></pre>
<p>The <code class="hljs">intro</code> command can more generally be used to introduce a variable of any type:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> (α : <span class="hljs-built_in">Type</span>) : α → α := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">intro</span> a
  <span class="hljs-built_in">exact</span> a

<span class="hljs-keyword">example</span> (α : <span class="hljs-built_in">Type</span>) : ∀ x : α, x = x := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">intro</span> x
  <span class="hljs-built_in">exact</span> Eq.<span class="hljs-built_in">refl</span> x
</code></pre>
<p>You can use it to introduce several variables:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> : ∀ a b c : Nat, a = b → a = c → c = b := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">intro</span> a b c h₁ h₂
  <span class="hljs-built_in">exact</span> Eq.trans (Eq.symm h₂) h₁
</code></pre>
<p>As the <code class="hljs">apply</code> tactic is a command for constructing function
applications interactively, the <code class="hljs">intro</code> tactic is a command for
constructing function abstractions interactively (i.e., terms of the
form <code class="hljs">fun x =&gt; e</code>).  As with lambda abstraction notation, the
<code class="hljs">intro</code> tactic allows us to use an implicit <code class="hljs">match</code>.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> (α : <span class="hljs-built_in">Type</span>) (p q : α → <span class="hljs-built_in">Prop</span>) : (∃ x, p x ∧ q x) → ∃ x, q x ∧ p x := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">intro</span> ⟨w, hpw, hqw⟩
  <span class="hljs-built_in">exact</span> ⟨w, hqw, hpw⟩
</code></pre>
<p>You can also provide multiple alternatives like in the <code class="hljs">match</code> expression.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> (α : <span class="hljs-built_in">Type</span>) (p q : α → <span class="hljs-built_in">Prop</span>) : (∃ x, p x ∨ q x) → ∃ x, q x ∨ p x := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">intro</span>
    | ⟨w, Or.inl h⟩ =&gt; <span class="hljs-built_in">exact</span> ⟨w, Or.inr h⟩
    | ⟨w, Or.inr h⟩ =&gt; <span class="hljs-built_in">exact</span> ⟨w, Or.inl h⟩
</code></pre>
<p>The <code class="hljs">intros</code> tactic can be used without any arguments, in which
case, it chooses names and introduces as many variables as it can. You
will see an example of this in a moment.</p>
<p>The <code class="hljs">assumption</code> tactic looks through the assumptions in context of
the current goal, and if there is one matching the conclusion, it
applies it.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> (x y z w : Nat) (h₁ : x = y) (h₂ : y = z) (h₃ : z = w) : x = w := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">apply</span> Eq.trans h₁
  <span class="hljs-built_in">apply</span> Eq.trans h₂
  <span class="hljs-built_in">assumption</span>   <span class="hljs-comment">-- applied h₃</span>
</code></pre>
<p>It will unify metavariables in the conclusion if necessary:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> (x y z w : Nat) (h₁ : x = y) (h₂ : y = z) (h₃ : z = w) : x = w := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">apply</span> Eq.trans
  <span class="hljs-built_in">assumption</span>      <span class="hljs-comment">-- solves x = ?b with h₁</span>
  <span class="hljs-built_in">apply</span> Eq.trans
  <span class="hljs-built_in">assumption</span>      <span class="hljs-comment">-- solves y = ?h₂.b with h₂</span>
  <span class="hljs-built_in">assumption</span>      <span class="hljs-comment">-- solves z = w with h₃</span>
</code></pre>
<p>The following example uses the <code class="hljs">intros</code> command to introduce the three variables and two hypotheses automatically:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> : ∀ a b c : Nat, a = b → a = c → c = b := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">intros</span>
  <span class="hljs-built_in">apply</span> Eq.trans
  <span class="hljs-built_in">apply</span> Eq.symm
  <span class="hljs-built_in">assumption</span>
  <span class="hljs-built_in">assumption</span>
</code></pre>
<p>Note that names automatically generated by Lean are inaccessible by default. The motivation is to
ensure your tactic proofs do not rely on automatically generated names, and are consequently more robust.
However, you can use the combinator <code class="hljs">unhygienic</code> to disable this restriction.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> : ∀ a b c : Nat, a = b → a = c → c = b := <span class="hljs-keyword">by</span> unhygienic
  <span class="hljs-built_in">intros</span>
  <span class="hljs-built_in">apply</span> Eq.trans
  <span class="hljs-built_in">apply</span> Eq.symm
  <span class="hljs-built_in">exact</span> a_2
  <span class="hljs-built_in">exact</span> a_1
</code></pre>
<p>You can also use the <code class="hljs">rename_i</code> tactic to rename the most recent inaccessible names in your context.
In the following example, the tactic <code class="hljs">rename_i h1 _ h2</code> renames two of the last three hypotheses in
your context.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> : ∀ a b c d : Nat, a = b → a = d → a = c → c = b := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">intros</span>
  <span class="hljs-built_in">rename_i</span> h1 _ h2
  <span class="hljs-built_in">apply</span> Eq.trans
  <span class="hljs-built_in">apply</span> Eq.symm
  <span class="hljs-built_in">exact</span> h2
  <span class="hljs-built_in">exact</span> h1
</code></pre>
<p>The <code class="hljs">rfl</code> tactic is syntax sugar for <code class="hljs">exact rfl</code>.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> (y : Nat) : (<span class="hljs-keyword">fun</span> x : Nat =&gt; <span class="hljs-number">0</span>) y = <span class="hljs-number">0</span> :=
  <span class="hljs-keyword">by</span> <span class="hljs-built_in">rfl</span>
</code></pre>
<p>The <code class="hljs">repeat</code> combinator can be used to apply a tactic several times.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> : ∀ a b c : Nat, a = b → a = c → c = b := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">intros</span>
  <span class="hljs-built_in">apply</span> Eq.trans
  <span class="hljs-built_in">apply</span> Eq.symm
  <span class="hljs-built_in">repeat</span> <span class="hljs-built_in">assumption</span>
</code></pre>
<p>Another tactic that is sometimes useful is the <code class="hljs">revert</code> tactic,
which is, in a sense, an inverse to <code class="hljs">intro</code>.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> (x : Nat) : x = x := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">revert</span> x
  <span class="hljs-comment">-- goal is ⊢ ∀ (x : Nat), x = x</span>
  <span class="hljs-built_in">intro</span> y
  <span class="hljs-comment">-- goal is y : Nat ⊢ y = y</span>
  <span class="hljs-built_in">rfl</span>
</code></pre>
<p>Moving a hypothesis into the goal yields an implication:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> (x y : Nat) (h : x = y) : y = x := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">revert</span> h
  <span class="hljs-comment">-- goal is x y : Nat ⊢ x = y → y = x</span>
  <span class="hljs-built_in">intro</span> h₁
  <span class="hljs-comment">-- goal is x y : ℕ, h₁ : x = y ⊢ y = x</span>
  <span class="hljs-built_in">apply</span> Eq.symm
  <span class="hljs-built_in">assumption</span>
</code></pre>
<p>But <code class="hljs">revert</code> is even more clever, in that it will revert not only an
element of the context but also all the subsequent elements of the
context that depend on it. For example, reverting <code class="hljs">x</code> in the example
above brings <code class="hljs">h</code> along with it:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> (x y : Nat) (h : x = y) : y = x := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">revert</span> x
  <span class="hljs-comment">-- goal is y : Nat ⊢ ∀ (x : Nat), x = y → y = x</span>
  <span class="hljs-built_in">intros</span>
  <span class="hljs-built_in">apply</span> Eq.symm
  <span class="hljs-built_in">assumption</span>
</code></pre>
<p>You can also revert multiple elements of the context at once:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> (x y : Nat) (h : x = y) : y = x := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">revert</span> x y
  <span class="hljs-comment">-- goal is ⊢ ∀ (x y : Nat), x = y → y = x</span>
  <span class="hljs-built_in">intros</span>
  <span class="hljs-built_in">apply</span> Eq.symm
  <span class="hljs-built_in">assumption</span>
</code></pre>
<p>You can only <code class="hljs">revert</code> an element of the local context, that is, a
local variable or hypothesis. But you can replace an arbitrary
expression in the goal by a fresh variable using the <code class="hljs">generalize</code>
tactic.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> : <span class="hljs-number">3</span> = <span class="hljs-number">3</span> := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">generalize</span> <span class="hljs-number">3</span> = x
  <span class="hljs-comment">-- goal is x : Nat ⊢ x = x,</span>
  <span class="hljs-built_in">revert</span> x
  <span class="hljs-comment">-- goal is ⊢ ∀ (x : Nat), x = x</span>
  <span class="hljs-built_in">intro</span> y
  <span class="hljs-comment">-- goal is y : Nat ⊢ y = y</span>
  <span class="hljs-built_in">rfl</span>
</code></pre>
<p>The mnemonic in the notation above is that you are generalizing the
goal by setting <code class="hljs">3</code> to an arbitrary variable <code class="hljs">x</code>. Be careful: not
every generalization preserves the validity of the goal. Here,
<code class="hljs">generalize</code> replaces a goal that could be proved using
<code class="hljs">rfl</code> with one that is not provable:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> : <span class="hljs-number">2</span> + <span class="hljs-number">3</span> = <span class="hljs-number">5</span> := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">generalize</span>  <span class="hljs-number">3</span> = x
  <span class="hljs-comment">-- goal is x : Nat ⊢ 2 + x = 5</span>
  <span class="hljs-strong">admit</span>
</code></pre>
<p>In this example, the <code class="hljs">admit</code> tactic is the analogue of the <code class="hljs">sorry</code>
proof term. It closes the current goal, producing the usual warning
that <code class="hljs">sorry</code> has been used. To preserve the validity of the previous
goal, the <code class="hljs">generalize</code> tactic allows us to record the fact that
<code class="hljs">3</code> has been replaced by <code class="hljs">x</code>. All you need to do is to provide a
label, and <code class="hljs">generalize</code> uses it to store the assignment in the local
context:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> : <span class="hljs-number">2</span> + <span class="hljs-number">3</span> = <span class="hljs-number">5</span> := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">generalize</span> h : <span class="hljs-number">3</span> = x
  <span class="hljs-comment">-- goal is x : Nat, h : 3 = x ⊢ 2 + x = 5</span>
  <span class="hljs-built_in">rw</span> [← h]
</code></pre>
<p>Here the <code class="hljs">rewrite</code> tactic, abbreviated <code class="hljs">rw</code>, uses <code class="hljs">h</code> to replace
<code class="hljs">x</code> by <code class="hljs">3</code> again. The <code class="hljs">rewrite</code> tactic will be discussed below.</p>
<h2><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/tactics.html#more-tactics" id="more-tactics">More Tactics</a></h2>
<p>Some additional tactics are useful for constructing and destructing
propositions and data. For example, when applied to a goal of the form
<code class="hljs">p ∨ q</code>, you use tactics such as <code class="hljs">apply Or.inl</code> and <code class="hljs">apply Or.inr</code>.  Conversely, the <code class="hljs">cases</code> tactic can be used to decompose a
disjunction.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> (p q : <span class="hljs-built_in">Prop</span>) : p ∨ q → q ∨ p := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">intro</span> h
  <span class="hljs-built_in">cases</span> h <span class="hljs-keyword">with</span>
  | inl hp =&gt; <span class="hljs-built_in">apply</span> Or.inr; <span class="hljs-built_in">exact</span> hp
  | inr hq =&gt; <span class="hljs-built_in">apply</span> Or.inl; <span class="hljs-built_in">exact</span> hq
</code></pre>
<p>Note that the syntax is similar to the one used in <code class="hljs">match</code> expressions.
The new subgoals can be solved in any order.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> (p q : <span class="hljs-built_in">Prop</span>) : p ∨ q → q ∨ p := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">intro</span> h
  <span class="hljs-built_in">cases</span> h <span class="hljs-keyword">with</span>
  | inr hq =&gt; <span class="hljs-built_in">apply</span> Or.inl; <span class="hljs-built_in">exact</span> hq
  | inl hp =&gt; <span class="hljs-built_in">apply</span> Or.inr; <span class="hljs-built_in">exact</span> hp
</code></pre>
<p>You can also use a (unstructured) <code class="hljs">cases</code> without the <code class="hljs">with</code> and a tactic
for each alternative.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> (p q : <span class="hljs-built_in">Prop</span>) : p ∨ q → q ∨ p := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">intro</span> h
  <span class="hljs-built_in">cases</span> h
  <span class="hljs-built_in">apply</span> Or.inr
  <span class="hljs-built_in">assumption</span>
  <span class="hljs-built_in">apply</span> Or.inl
  <span class="hljs-built_in">assumption</span>
</code></pre>
<p>The (unstructured) <code class="hljs">cases</code> is particularly useful when you can close several
subgoals using the same tactic.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> (p : <span class="hljs-built_in">Prop</span>) : p ∨ p → p := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">intro</span> h
  <span class="hljs-built_in">cases</span> h
  <span class="hljs-built_in">repeat</span> <span class="hljs-built_in">assumption</span>
</code></pre>
<p>You can also use the combinator <code class="hljs">tac1 &lt;;&gt; tac2</code> to apply <code class="hljs">tac2</code> to each
subgoal produced by tactic <code class="hljs">tac1</code></p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> (p : <span class="hljs-built_in">Prop</span>) : p ∨ p → p := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">intro</span> h
  <span class="hljs-built_in">cases</span> h &lt;;&gt; <span class="hljs-built_in">assumption</span>
</code></pre>
<p>You can combine the unstructured <code class="hljs">cases</code> tactic with the <code class="hljs">case</code> and <code class="hljs">.</code> notation.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> (p q : <span class="hljs-built_in">Prop</span>) : p ∨ q → q ∨ p := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">intro</span> h
  <span class="hljs-built_in">cases</span> h
  . <span class="hljs-built_in">apply</span> Or.inr
    <span class="hljs-built_in">assumption</span>
  . <span class="hljs-built_in">apply</span> Or.inl
    <span class="hljs-built_in">assumption</span>

<span class="hljs-keyword">example</span> (p q : <span class="hljs-built_in">Prop</span>) : p ∨ q → q ∨ p := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">intro</span> h
  <span class="hljs-built_in">cases</span> h
  <span class="hljs-built_in">case</span> inr h =&gt;
    <span class="hljs-built_in">apply</span> Or.inl
    <span class="hljs-built_in">assumption</span>
  <span class="hljs-built_in">case</span> inl h =&gt;
    <span class="hljs-built_in">apply</span> Or.inr
    <span class="hljs-built_in">assumption</span>

<span class="hljs-keyword">example</span> (p q : <span class="hljs-built_in">Prop</span>) : p ∨ q → q ∨ p := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">intro</span> h
  <span class="hljs-built_in">cases</span> h
  <span class="hljs-built_in">case</span> inr h =&gt;
    <span class="hljs-built_in">apply</span> Or.inl
    <span class="hljs-built_in">assumption</span>
  . <span class="hljs-built_in">apply</span> Or.inr
    <span class="hljs-built_in">assumption</span>
</code></pre>
<p>The <code class="hljs">cases</code> tactic can also be used to
decompose a conjunction.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> (p q : <span class="hljs-built_in">Prop</span>) : p ∧ q → q ∧ p := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">intro</span> h
  <span class="hljs-built_in">cases</span> h <span class="hljs-keyword">with</span>
  | <span class="hljs-built_in">intro</span> hp hq =&gt; <span class="hljs-built_in">constructor</span>; <span class="hljs-built_in">exact</span> hq; <span class="hljs-built_in">exact</span> hp
</code></pre>
<p>In this example, there is only one goal after the <code class="hljs">cases</code> tactic is
applied, with <code class="hljs">h : p ∧ q</code> replaced by a pair of assumptions,
<code class="hljs">hp : p</code> and <code class="hljs">hq : q</code>. The <code class="hljs">constructor</code> tactic applies the unique
constructor for conjunction, <code class="hljs">And.intro</code>. With these tactics, an
example from the previous section can be rewritten as follows:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> (p q r : <span class="hljs-built_in">Prop</span>) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">apply</span> Iff.<span class="hljs-built_in">intro</span>
  . <span class="hljs-built_in">intro</span> h
    <span class="hljs-built_in">cases</span> h <span class="hljs-keyword">with</span>
    | <span class="hljs-built_in">intro</span> hp hqr =&gt;
      <span class="hljs-built_in">cases</span> hqr
      . <span class="hljs-built_in">apply</span> Or.inl; <span class="hljs-built_in">constructor</span> &lt;;&gt; <span class="hljs-built_in">assumption</span>
      . <span class="hljs-built_in">apply</span> Or.inr; <span class="hljs-built_in">constructor</span> &lt;;&gt; <span class="hljs-built_in">assumption</span>
  . <span class="hljs-built_in">intro</span> h
    <span class="hljs-built_in">cases</span> h <span class="hljs-keyword">with</span>
    | inl hpq =&gt;
      <span class="hljs-built_in">cases</span> hpq <span class="hljs-keyword">with</span>
      | <span class="hljs-built_in">intro</span> hp hq =&gt; <span class="hljs-built_in">constructor</span>; <span class="hljs-built_in">exact</span> hp; <span class="hljs-built_in">apply</span> Or.inl; <span class="hljs-built_in">exact</span> hq
    | inr hpr =&gt;
      <span class="hljs-built_in">cases</span> hpr <span class="hljs-keyword">with</span>
      | <span class="hljs-built_in">intro</span> hp hr =&gt; <span class="hljs-built_in">constructor</span>; <span class="hljs-built_in">exact</span> hp; <span class="hljs-built_in">apply</span> Or.inr; <span class="hljs-built_in">exact</span> hr
</code></pre>
<p>You will see in <a href="https://leanprover.github.io/theorem_proving_in_lean4/inductive_types.html">Chapter Inductive Types</a> that
these tactics are quite general. The <code class="hljs">cases</code> tactic can be used to
decompose any element of an inductively defined type; <code class="hljs">constructor</code>
always applies the first applicable constructor of an inductively defined type.
For example, you can use <code class="hljs">cases</code> and <code class="hljs">constructor</code> with an existential quantifier:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> (p q : Nat → <span class="hljs-built_in">Prop</span>) : (∃ x, p x) → ∃ x, p x ∨ q x := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">intro</span> h
  <span class="hljs-built_in">cases</span> h <span class="hljs-keyword">with</span>
  | <span class="hljs-built_in">intro</span> x px =&gt; <span class="hljs-built_in">constructor</span>; <span class="hljs-built_in">apply</span> Or.inl; <span class="hljs-built_in">exact</span> px
</code></pre>
<p>Here, the <code class="hljs">constructor</code> tactic leaves the first component of the
existential assertion, the value of <code class="hljs">x</code>, implicit. It is represented
by a metavariable, which should be instantiated later on. In the
previous example, the proper value of the metavariable is determined
by the tactic <code class="hljs">exact px</code>, since <code class="hljs">px</code> has type <code class="hljs">p x</code>. If you want
to specify a witness to the existential quantifier explicitly, you can
use the <code class="hljs">exists</code> tactic instead:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> (p q : Nat → <span class="hljs-built_in">Prop</span>) : (∃ x, p x) → ∃ x, p x ∨ q x := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">intro</span> h
  <span class="hljs-built_in">cases</span> h <span class="hljs-keyword">with</span>
  | <span class="hljs-built_in">intro</span> x px =&gt; <span class="hljs-built_in">exists</span> x; <span class="hljs-built_in">apply</span> Or.inl; <span class="hljs-built_in">exact</span> px
</code></pre>
<p>Here is another example:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> (p q : Nat → <span class="hljs-built_in">Prop</span>) : (∃ x, p x ∧ q x) → ∃ x, q x ∧ p x := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">intro</span> h
  <span class="hljs-built_in">cases</span> h <span class="hljs-keyword">with</span>
  | <span class="hljs-built_in">intro</span> x hpq =&gt;
    <span class="hljs-built_in">cases</span> hpq <span class="hljs-keyword">with</span>
    | <span class="hljs-built_in">intro</span> hp hq =&gt;
      <span class="hljs-built_in">exists</span> x
      <span class="hljs-built_in">constructor</span> &lt;;&gt; <span class="hljs-built_in">assumption</span>
</code></pre>
<p>These tactics can be used on data just as well as propositions. In the
next two examples, they are used to define functions which swap the
components of the product and sum types:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">sw</span><span class="hljs-title">a</span><span class="hljs-title">p</span><span class="hljs-title">_</span><span class="hljs-title">p</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">r</span> <span class="hljs-symbol">:</span></span> α × β → β × α := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">intro</span> p
  <span class="hljs-built_in">cases</span> p
  <span class="hljs-built_in">constructor</span> &lt;;&gt; <span class="hljs-built_in">assumption</span>
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">sw</span><span class="hljs-title">a</span><span class="hljs-title">p</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">u</span><span class="hljs-title">m</span> <span class="hljs-symbol">:</span></span> Sum α β → Sum β α := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">intro</span> p
  <span class="hljs-built_in">cases</span> p
  . <span class="hljs-built_in">apply</span> Sum.inr; <span class="hljs-built_in">assumption</span>
  . <span class="hljs-built_in">apply</span> Sum.inl; <span class="hljs-built_in">assumption</span>
</code></pre>
<p>Note that up to the names we have chosen for the variables, the
definitions are identical to the proofs of the analogous propositions
for conjunction and disjunction. The <code class="hljs">cases</code> tactic will also do a
case distinction on a natural number:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">open</span> Nat
<span class="hljs-keyword">example</span> (P : Nat → <span class="hljs-built_in">Prop</span>) (h₀ : P <span class="hljs-number">0</span>) (h₁ : ∀ n, P (succ n)) (m : Nat) : P m := <span class="hljs-keyword">by</span>
 <span class="hljs-built_in">cases</span> m <span class="hljs-keyword">with</span>
 | zero    =&gt; <span class="hljs-built_in">exact</span> h₀
 | succ m' =&gt; <span class="hljs-built_in">exact</span> h₁ m'
</code></pre>
<p>The <code class="hljs">cases</code> tactic, and its companion, the <code class="hljs">induction</code> tactic, are discussed in greater detail in
the <a href="https://leanprover.github.io/theorem_proving_in_lean4/inductive_types.html#_tactics_for_inductive_types">Tactics for Inductive Types</a> section.</p>
<p>The <code class="hljs">contradiction</code> tactic searches for a contradiction among the hypotheses of the current goal:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> (p q : <span class="hljs-built_in">Prop</span>) : p ∧ ¬ p → q := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">intro</span> h
  <span class="hljs-built_in">cases</span> h
  <span class="hljs-built_in">contradiction</span>
</code></pre>
<p>You can also use <code class="hljs">match</code> in tactic blocks.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> (p q r : <span class="hljs-built_in">Prop</span>) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">apply</span> Iff.<span class="hljs-built_in">intro</span>
  . <span class="hljs-built_in">intro</span> h
    <span class="hljs-keyword">match</span> h <span class="hljs-keyword">with</span>
    | ⟨_, Or.inl _⟩ =&gt; <span class="hljs-built_in">apply</span> Or.inl; <span class="hljs-built_in">constructor</span> &lt;;&gt; <span class="hljs-built_in">assumption</span>
    | ⟨_, Or.inr _⟩ =&gt; <span class="hljs-built_in">apply</span> Or.inr; <span class="hljs-built_in">constructor</span> &lt;;&gt; <span class="hljs-built_in">assumption</span>
  . <span class="hljs-built_in">intro</span> h
    <span class="hljs-keyword">match</span> h <span class="hljs-keyword">with</span>
    | Or.inl ⟨hp, hq⟩ =&gt; <span class="hljs-built_in">constructor</span>; <span class="hljs-built_in">exact</span> hp; <span class="hljs-built_in">apply</span> Or.inl; <span class="hljs-built_in">exact</span> hq
    | Or.inr ⟨hp, hr⟩ =&gt; <span class="hljs-built_in">constructor</span>; <span class="hljs-built_in">exact</span> hp; <span class="hljs-built_in">apply</span> Or.inr; <span class="hljs-built_in">exact</span> hr
</code></pre>
<p>You can "combine" <code class="hljs">intro h</code> with <code class="hljs">match h ...</code> and write the previous examples as follows</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> (p q r : <span class="hljs-built_in">Prop</span>) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">apply</span> Iff.<span class="hljs-built_in">intro</span>
  . <span class="hljs-built_in">intro</span>
     | ⟨hp, Or.inl hq⟩ =&gt; <span class="hljs-built_in">apply</span> Or.inl; <span class="hljs-built_in">constructor</span> &lt;;&gt; <span class="hljs-built_in">assumption</span>
     | ⟨hp, Or.inr hr⟩ =&gt; <span class="hljs-built_in">apply</span> Or.inr; <span class="hljs-built_in">constructor</span> &lt;;&gt; <span class="hljs-built_in">assumption</span>
  . <span class="hljs-built_in">intro</span>
     | Or.inl ⟨hp, hq⟩ =&gt; <span class="hljs-built_in">constructor</span>; <span class="hljs-built_in">assumption</span>; <span class="hljs-built_in">apply</span> Or.inl; <span class="hljs-built_in">assumption</span>
     | Or.inr ⟨hp, hr⟩ =&gt; <span class="hljs-built_in">constructor</span>; <span class="hljs-built_in">assumption</span>; <span class="hljs-built_in">apply</span> Or.inr; <span class="hljs-built_in">assumption</span>

</code></pre>
<h2><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/tactics.html#a-namestructuring_tactic_proofsastructuring-tactic-proofs" id="a-namestructuring_tactic_proofsastructuring-tactic-proofs"></a><a name="structuring_tactic_proofs"></a>Structuring Tactic Proofs</h2>
<p>Tactics often provide an efficient way of building a proof, but long
sequences of instructions can obscure the structure of the
argument. In this section, we describe some means that help provide
structure to a tactic-style proof, making such proofs more readable
and robust.</p>
<p>One thing that is nice about Lean's proof-writing syntax is that it is
possible to mix term-style and tactic-style proofs, and pass between
the two freely. For example, the tactics <code class="hljs">apply</code> and <code class="hljs">exact</code>
expect arbitrary terms, which you can write using <code class="hljs">have</code>, <code class="hljs">show</code>,
and so on. Conversely, when writing an arbitrary Lean term, you can
always invoke the tactic mode by inserting a <code class="hljs">by</code>
block. The following is a somewhat toy example:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> (p q r : <span class="hljs-built_in">Prop</span>) : p ∧ (q ∨ r) → (p ∧ q) ∨ (p ∧ r) := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">intro</span> h
  <span class="hljs-built_in">exact</span>
    <span class="hljs-built_in">have</span> hp : p := h.left
    <span class="hljs-built_in">have</span> hqr : q ∨ r := h.right
    <span class="hljs-built_in">show</span> (p ∧ q) ∨ (p ∧ r) <span class="hljs-keyword">by</span>
      <span class="hljs-built_in">cases</span> hqr <span class="hljs-keyword">with</span>
      | inl hq =&gt; <span class="hljs-built_in">exact</span> Or.inl ⟨hp, hq⟩
      | inr hr =&gt; <span class="hljs-built_in">exact</span> Or.inr ⟨hp, hr⟩
</code></pre>
<p>The following is a more natural example:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> (p q r : <span class="hljs-built_in">Prop</span>) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">apply</span> Iff.<span class="hljs-built_in">intro</span>
  . <span class="hljs-built_in">intro</span> h
    <span class="hljs-built_in">cases</span> h.right <span class="hljs-keyword">with</span>
    | inl hq =&gt; <span class="hljs-built_in">exact</span> Or.inl ⟨h.left, hq⟩
    | inr hr =&gt; <span class="hljs-built_in">exact</span> Or.inr ⟨h.left, hr⟩
  . <span class="hljs-built_in">intro</span> h
    <span class="hljs-built_in">cases</span> h <span class="hljs-keyword">with</span>
    | inl hpq =&gt; <span class="hljs-built_in">exact</span> ⟨hpq.left, Or.inl hpq.right⟩
    | inr hpr =&gt; <span class="hljs-built_in">exact</span> ⟨hpr.left, Or.inr hpr.right⟩
</code></pre>
<p>In fact, there is a <code class="hljs">show</code> tactic, which is similar to the
<code class="hljs">show</code> expression in a proof term. It simply declares the type of the
goal that is about to be solved, while remaining in tactic
mode.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> (p q r : <span class="hljs-built_in">Prop</span>) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">apply</span> Iff.<span class="hljs-built_in">intro</span>
  . <span class="hljs-built_in">intro</span> h
    <span class="hljs-built_in">cases</span> h.right <span class="hljs-keyword">with</span>
    | inl hq =&gt;
      <span class="hljs-built_in">show</span> (p ∧ q) ∨ (p ∧ r)
      <span class="hljs-built_in">exact</span> Or.inl ⟨h.left, hq⟩
    | inr hr =&gt;
      <span class="hljs-built_in">show</span> (p ∧ q) ∨ (p ∧ r)
      <span class="hljs-built_in">exact</span> Or.inr ⟨h.left, hr⟩
  . <span class="hljs-built_in">intro</span> h
    <span class="hljs-built_in">cases</span> h <span class="hljs-keyword">with</span>
    | inl hpq =&gt;
      <span class="hljs-built_in">show</span> p ∧ (q ∨ r)
      <span class="hljs-built_in">exact</span> ⟨hpq.left, Or.inl hpq.right⟩
    | inr hpr =&gt;
      <span class="hljs-built_in">show</span> p ∧ (q ∨ r)
      <span class="hljs-built_in">exact</span> ⟨hpr.left, Or.inr hpr.right⟩
</code></pre>
<p>The <code class="hljs">show</code> tactic can actually be used to rewrite a goal to something definitionally equivalent:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> (n : Nat) : n + <span class="hljs-number">1</span> = Nat.succ n := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">show</span> Nat.succ n = Nat.succ n
  <span class="hljs-built_in">rfl</span>
</code></pre>
<p>There is also a <code class="hljs">have</code> tactic, which introduces a new subgoal, just as when writing proof terms:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> (p q r : <span class="hljs-built_in">Prop</span>) : p ∧ (q ∨ r) → (p ∧ q) ∨ (p ∧ r) := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">intro</span> ⟨hp, hqr⟩
  <span class="hljs-built_in">show</span> (p ∧ q) ∨ (p ∧ r)
  <span class="hljs-built_in">cases</span> hqr <span class="hljs-keyword">with</span>
  | inl hq =&gt;
    <span class="hljs-built_in">have</span> hpq : p ∧ q := And.<span class="hljs-built_in">intro</span> hp hq
    <span class="hljs-built_in">apply</span> Or.inl
    <span class="hljs-built_in">exact</span> hpq
  | inr hr =&gt;
    <span class="hljs-built_in">have</span> hpr : p ∧ r := And.<span class="hljs-built_in">intro</span> hp hr
    <span class="hljs-built_in">apply</span> Or.inr
    <span class="hljs-built_in">exact</span> hpr
</code></pre>
<p>As with proof terms, you can omit the label in the <code class="hljs">have</code> tactic, in
which case, the default label <code class="hljs">this</code> is used:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> (p q r : <span class="hljs-built_in">Prop</span>) : p ∧ (q ∨ r) → (p ∧ q) ∨ (p ∧ r) := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">intro</span> ⟨hp, hqr⟩
  <span class="hljs-built_in">show</span> (p ∧ q) ∨ (p ∧ r)
  <span class="hljs-built_in">cases</span> hqr <span class="hljs-keyword">with</span>
  | inl hq =&gt;
    <span class="hljs-built_in">have</span> : p ∧ q := And.<span class="hljs-built_in">intro</span> hp hq
    <span class="hljs-built_in">apply</span> Or.inl
    <span class="hljs-built_in">exact</span> this
  | inr hr =&gt;
    <span class="hljs-built_in">have</span> : p ∧ r := And.<span class="hljs-built_in">intro</span> hp hr
    <span class="hljs-built_in">apply</span> Or.inr
    <span class="hljs-built_in">exact</span> this
</code></pre>
<p>The types in a <code class="hljs">have</code> tactic can be omitted, so you can write <code class="hljs">have hp := h.left</code> and <code class="hljs">have hqr := h.right</code>.  In fact, with this
notation, you can even omit both the type and the label, in which case
the new fact is introduced with the label <code class="hljs">this</code>.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> (p q r : <span class="hljs-built_in">Prop</span>) : p ∧ (q ∨ r) → (p ∧ q) ∨ (p ∧ r) := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">intro</span> ⟨hp, hqr⟩
  <span class="hljs-built_in">cases</span> hqr <span class="hljs-keyword">with</span>
  | inl hq =&gt;
    <span class="hljs-built_in">have</span> := And.<span class="hljs-built_in">intro</span> hp hq
    <span class="hljs-built_in">apply</span> Or.inl; <span class="hljs-built_in">exact</span> this
  | inr hr =&gt;
    <span class="hljs-built_in">have</span> := And.<span class="hljs-built_in">intro</span> hp hr
    <span class="hljs-built_in">apply</span> Or.inr; <span class="hljs-built_in">exact</span> this
</code></pre>
<p>Lean also has a <code class="hljs">let</code> tactic, which is similar to the <code class="hljs">have</code>
tactic, but is used to introduce local definitions instead of
auxiliary facts. It is the tactic analogue of a <code class="hljs">let</code> in a proof
term.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> : ∃ x, x + <span class="hljs-number">2</span> = <span class="hljs-number">8</span> := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">let</span> a : Nat := <span class="hljs-number">3</span> * <span class="hljs-number">2</span>
  <span class="hljs-built_in">exists</span> a
  <span class="hljs-built_in">rfl</span>
</code></pre>
<p>As with <code class="hljs">have</code>, you can leave the type implicit by writing <code class="hljs">let a := 3 * 2</code>. The difference between <code class="hljs">let</code> and <code class="hljs">have</code> is that
<code class="hljs">let</code> introduces a local definition in the context, so that the
definition of the local declaration can be unfolded in the proof.</p>
<p>We have used <code class="hljs">.</code> to create nested tactic blocks.  In a nested block,
Lean focuses on the first goal, and generates an error if it has not
been fully solved at the end of the block. This can be helpful in
indicating the separate proofs of multiple subgoals introduced by a
tactic. The notation <code class="hljs">.</code> is whitespace sensitive and relies on the indentation
to detect whether the tactic block ends. Alternatively, you can
define tactic blocks usind curly braces and semicolons.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> (p q r : <span class="hljs-built_in">Prop</span>) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">apply</span> Iff.<span class="hljs-built_in">intro</span>
  { <span class="hljs-built_in">intro</span> h;
    <span class="hljs-built_in">cases</span> h.right;
    { <span class="hljs-built_in">show</span> (p ∧ q) ∨ (p ∧ r);
      <span class="hljs-built_in">exact</span> Or.inl ⟨h.left, ‹q›⟩ }
    { <span class="hljs-built_in">show</span> (p ∧ q) ∨ (p ∧ r);
      <span class="hljs-built_in">exact</span> Or.inr ⟨h.left, ‹r›⟩ } }
  { <span class="hljs-built_in">intro</span> h;
    <span class="hljs-built_in">cases</span> h;
    { <span class="hljs-built_in">show</span> p ∧ (q ∨ r);
      <span class="hljs-built_in">rename_i</span> hpq;
      <span class="hljs-built_in">exact</span> ⟨hpq.left, Or.inl hpq.right⟩ }
    { <span class="hljs-built_in">show</span> p ∧ (q ∨ r);
      <span class="hljs-built_in">rename_i</span> hpr;
      <span class="hljs-built_in">exact</span> ⟨hpr.left, Or.inr hpr.right⟩ } }
</code></pre>
<p>It useful to use indendation to structure proof: every time a tactic
leaves more than one subgoal, we separate the remaining subgoals by
enclosing them in blocks and indenting.  Thus if the application of
theorem <code class="hljs">foo</code> to a single goal produces four subgoals, one would
expect the proof to look like this:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="hljs">  apply foo
  . &lt;proof of first goal&gt;
  . &lt;proof of second goal&gt;
  . &lt;proof of third goal&gt;
  . &lt;proof of final goal&gt;
</code></pre>
<p>or</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="hljs">  apply foo
  case &lt;tag of first goal&gt;  =&gt; &lt;proof of first goal&gt;
  case &lt;tag of second goal&gt; =&gt; &lt;proof of second goal&gt;
  case &lt;tag of third goal&gt;  =&gt; &lt;proof of third goal&gt;
  case &lt;tag of final goal&gt;  =&gt; &lt;proof of final goal&gt;
</code></pre>
<p>or</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="hljs">  apply foo
  { &lt;proof of first goal&gt;  }
  { &lt;proof of second goal&gt; }
  { &lt;proof of third goal&gt;  }
  { &lt;proof of final goal&gt;  }
</code></pre>
<h2><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/tactics.html#a-name_tactic_combinatorsa-tactic-combinators" id="a-name_tactic_combinatorsa-tactic-combinators"></a><a name="_tactic_combinators"></a> Tactic Combinators</h2>
<p><em>Tactic combinators</em> are operations that form new tactics from old
ones. A sequencing combinator is already implicit in the <code class="hljs">by</code> block:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> (p q : <span class="hljs-built_in">Prop</span>) (hp : p) : p ∨ q :=
  <span class="hljs-keyword">by</span> <span class="hljs-built_in">apply</span> Or.inl; <span class="hljs-built_in">assumption</span>
</code></pre>
<p>Here, <code class="hljs">apply Or.inl; assumption</code> is functionally equivalent to a
single tactic which first applies <code class="hljs">apply Or.inl</code> and then applies
<code class="hljs">assumption</code>.</p>
<p>In <code class="hljs">t₁ &lt;;&gt; t₂</code>, the <code class="hljs">&lt;;&gt;</code> operator provides a <em>parallel</em> version of the sequencing operation:
<code class="hljs">t₁</code> is applied to the current goal, and then <code class="hljs">t₂</code> is applied to <em>all</em> the resulting subgoals:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> (p q : <span class="hljs-built_in">Prop</span>) (hp : p) (hq : q) : p ∧ q :=
  <span class="hljs-keyword">by</span> <span class="hljs-built_in">constructor</span> &lt;;&gt; <span class="hljs-built_in">assumption</span>
</code></pre>
<p>This is especially useful when the resulting goals can be finished off
in a uniform way, or, at least, when it is possible to make progress
on all of them uniformly.</p>
<p>The <code class="hljs">first | t₁ | t₂ | ... | tₙ</code> applies each <code class="hljs">tᵢ</code> until one succeeds, or else fails:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> (p q : <span class="hljs-built_in">Prop</span>) (hp : p) : p ∨ q := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">first</span> | <span class="hljs-built_in">apply</span> Or.inl; <span class="hljs-built_in">assumption</span> | <span class="hljs-built_in">apply</span> Or.inr; <span class="hljs-built_in">assumption</span>
</code></pre>
<p>In the first example, the left branch succeeds, whereas in the second one, it is the right one that succeeds.
In the next three examples, the same compound tactic succeeds in each case.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> (p q r : <span class="hljs-built_in">Prop</span>) (hp : p) : p ∨ q ∨ r :=
  <span class="hljs-keyword">by</span> <span class="hljs-built_in">repeat</span> (<span class="hljs-built_in">first</span> | <span class="hljs-built_in">apply</span> Or.inl; <span class="hljs-built_in">assumption</span> | <span class="hljs-built_in">apply</span> Or.inr | <span class="hljs-built_in">assumption</span>)

<span class="hljs-keyword">example</span> (p q r : <span class="hljs-built_in">Prop</span>) (hq : q) : p ∨ q ∨ r :=
  <span class="hljs-keyword">by</span> <span class="hljs-built_in">repeat</span> (<span class="hljs-built_in">first</span> | <span class="hljs-built_in">apply</span> Or.inl; <span class="hljs-built_in">assumption</span> | <span class="hljs-built_in">apply</span> Or.inr | <span class="hljs-built_in">assumption</span>)

<span class="hljs-keyword">example</span> (p q r : <span class="hljs-built_in">Prop</span>) (hr : r) : p ∨ q ∨ r :=
  <span class="hljs-keyword">by</span> <span class="hljs-built_in">repeat</span> (<span class="hljs-built_in">first</span> | <span class="hljs-built_in">apply</span> Or.inl; <span class="hljs-built_in">assumption</span> | <span class="hljs-built_in">apply</span> Or.inr | <span class="hljs-built_in">assumption</span>)
</code></pre>
<p>The tactic tries to solve the left disjunct immediately by assumption;
if that fails, it tries to focus on the right disjunct; and if that
doesn't work, it invokes the assumption tactic.</p>
<p>You will have no doubt noticed by now that tactics can fail. Indeed,
it is the "failure" state that causes the <em>first</em> combinator to
backtrack and try the next tactic. The <code class="hljs">try</code> combinator builds a
tactic that always succeeds, though possibly in a trivial way:
<code class="hljs">try t</code> executes <code class="hljs">t</code> and reports success, even if <code class="hljs">t</code> fails. It is
equivalent to <code class="hljs">first | t | skip</code>, where <code class="hljs">skip</code> is a tactic that does
nothing (and succeeds in doing so). In the next example, the second
<code class="hljs">constructor</code> succeeds on the right conjunct <code class="hljs">q ∧ r</code> (remember that
disjunction and conjunction associate to the right) but fails on the
first. The <code class="hljs">try</code> tactic ensures that the sequential composition
succeeds.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> (p q r : <span class="hljs-built_in">Prop</span>) (hp : p) (hq : q) (hr : r) : p ∧ q ∧ r := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">constructor</span> &lt;;&gt; (<span class="hljs-keyword">try</span> <span class="hljs-built_in">constructor</span>) &lt;;&gt; <span class="hljs-built_in">assumption</span>
</code></pre>
<p>Be careful: <code class="hljs">repeat (try t)</code> will loop forever, because the inner tactic never fails.</p>
<p>In a proof, there are often multiple goals outstanding. Parallel
sequencing is one way to arrange it so that a single tactic is applied
to multiple goals, but there are other ways to do this. For example,
<code class="hljs">all_goals t</code> applies <code class="hljs">t</code> to all open goals:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> (p q r : <span class="hljs-built_in">Prop</span>) (hp : p) (hq : q) (hr : r) : p ∧ q ∧ r := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">constructor</span>
  <span class="hljs-built_in">all_goals</span> (<span class="hljs-keyword">try</span> <span class="hljs-built_in">constructor</span>)
  <span class="hljs-built_in">all_goals</span> <span class="hljs-built_in">assumption</span>
</code></pre>
<p>In this case, the <code class="hljs">any_goals</code> tactic provides a more robust solution.
It is similar to <code class="hljs">all_goals</code>, except it fails unless its argument
succeeds on at least one goal.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> (p q r : <span class="hljs-built_in">Prop</span>) (hp : p) (hq : q) (hr : r) : p ∧ q ∧ r := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">constructor</span>
  <span class="hljs-built_in">any_goals</span> <span class="hljs-built_in">constructor</span>
  <span class="hljs-built_in">any_goals</span> <span class="hljs-built_in">assumption</span>
</code></pre>
<p>The first tactic in the <code class="hljs">by</code> block below repeatedly splits
conjunctions:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> (p q r : <span class="hljs-built_in">Prop</span>) (hp : p) (hq : q) (hr : r) :
      p ∧ ((p ∧ q) ∧ r) ∧ (q ∧ r ∧ p) := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">repeat</span> (<span class="hljs-built_in">any_goals</span> <span class="hljs-built_in">constructor</span>)
  <span class="hljs-built_in">all_goals</span> <span class="hljs-built_in">assumption</span>
</code></pre>
<p>In fact, we can compress the full tactic down to one line:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> (p q r : <span class="hljs-built_in">Prop</span>) (hp : p) (hq : q) (hr : r) :
      p ∧ ((p ∧ q) ∧ r) ∧ (q ∧ r ∧ p) := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">repeat</span> (<span class="hljs-built_in">any_goals</span> (<span class="hljs-built_in">first</span> | <span class="hljs-built_in">constructor</span> | <span class="hljs-built_in">assumption</span>))
</code></pre>
<p>The combinator <code class="hljs">focus t</code> ensures that <code class="hljs">t</code> only effects the current
goal, temporarily hiding the others from the scope. So, if <code class="hljs">t</code>
ordinarily only effects the current goal, <code class="hljs">focus (all_goals t)</code> has
the same effect as <code class="hljs">t</code>.</p>
<h2><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/tactics.html#rewriting" id="rewriting">Rewriting</a></h2>
<p>The <code class="hljs">rewrite</code> tactic (abbreviated <code class="hljs">rw</code>) and the <code class="hljs">simp</code> tactic
were introduced briefly in <a href="https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#_calc_proofs">Calculational Proofs</a>. In this
section and the next, we discuss them in greater detail.</p>
<p>The <code class="hljs">rewrite</code> tactic provides a basic mechanism for applying
substitutions to goals and hypotheses, providing a convenient and
efficient way of working with equality. The most basic form of the
tactic is <code class="hljs">rewrite [t]</code>, where <code class="hljs">t</code> is a term whose type asserts an
equality. For example, <code class="hljs">t</code> can be a hypothesis <code class="hljs">h : x = y</code> in the
context; it can be a general lemma, like
<code class="hljs">add_comm : ∀ x y, x + y = y + x</code>, in which the rewrite tactic tries to find suitable
instantiations of <code class="hljs">x</code> and <code class="hljs">y</code>; or it can be any compound term
asserting a concrete or general equation. In the following example, we
use this basic form to rewrite the goal using a hypothesis.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> (f : Nat → Nat) (k : Nat) (h₁ : f <span class="hljs-number">0</span> = <span class="hljs-number">0</span>) (h₂ : k = <span class="hljs-number">0</span>) : f k = <span class="hljs-number">0</span> := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">rw</span> [h₂] <span class="hljs-comment">-- replace k with 0</span>
  <span class="hljs-built_in">rw</span> [h₁] <span class="hljs-comment">-- replace f 0 with 0</span>
</code></pre>
<p>In the example above, the first use of <code class="hljs">rw</code> replaces <code class="hljs">k</code> with
<code class="hljs">0</code> in the goal <code class="hljs">f k = 0</code>. Then, the second one replaces <code class="hljs">f 0</code>
with <code class="hljs">0</code>. The tactic automatically closes any goal of the form
<code class="hljs">t = t</code>. Here is an example of rewriting using a compound expression:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> (x y : Nat) (p : Nat → <span class="hljs-built_in">Prop</span>) (q : <span class="hljs-built_in">Prop</span>) (h : q → x = y)
        (h' : p y) (hq : q) : p x := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">rw</span> [h hq]; <span class="hljs-built_in">assumption</span>
</code></pre>
<p>Here, <code class="hljs">h hq</code> establishes the equation <code class="hljs">x = y</code>. The parentheses
around <code class="hljs">h hq</code> are not necessary, but we have added them for clarity.</p>
<p>Multiple rewrites can be combined using the notation <code class="hljs">rw [t_1, ..., t_n]</code>,
which is just shorthand for <code class="hljs">rw t_1; ...; rw t_n</code>. The previous example can be written as follows:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> (f : Nat → Nat) (k : Nat) (h₁ : f <span class="hljs-number">0</span> = <span class="hljs-number">0</span>) (h₂ : k = <span class="hljs-number">0</span>) : f k = <span class="hljs-number">0</span> := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">rw</span> [h₂, h₁]
</code></pre>
<p>By default, <code class="hljs">rw</code> uses an equation in the forward direction, matching
the left-hand side with an expression, and replacing it with the
right-hand side. The notation <code class="hljs">←t</code> can be used to instruct the
tactic to use the equality <code class="hljs">t</code> in the reverse direction.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> (f : Nat → Nat) (a b : Nat) (h₁ : a = b) (h₂ : f a = <span class="hljs-number">0</span>) : f b = <span class="hljs-number">0</span> := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">rw</span> [←h₁, h₂]
</code></pre>
<p>In this example, the term <code class="hljs">←h₁</code> instructs the rewriter to replace
<code class="hljs">b</code> with <code class="hljs">a</code>. In the editors, you can type the backwards arrow as
<code class="hljs">\l</code>. You can also use the ascii equivalent, <code class="hljs">&lt;-</code>.</p>
<p>Sometimes the left-hand side of an identity can match more than one
subterm in the pattern, in which case the <code class="hljs">rw</code> tactic chooses the
first match it finds when traversing the term. If that is not the one
you want, you can use additional arguments to specify the appropriate
subterm.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> (a b c : Nat) : a + b + c = a + c + b := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">rw</span> [Nat.add_assoc, Nat.add_comm b, ← Nat.add_assoc]

<span class="hljs-keyword">example</span> (a b c : Nat) : a + b + c = a + c + b := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">rw</span> [Nat.add_assoc, Nat.add_assoc, Nat.add_comm b]

<span class="hljs-keyword">example</span> (a b c : Nat) : a + b + c = a + c + b := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">rw</span> [Nat.add_assoc, Nat.add_assoc, Nat.add_comm _ b]
</code></pre>
<p>In the first example above, the first step rewrites <code class="hljs">a + b + c</code> to
<code class="hljs">a + (b + c)</code>. Then next applies commutativity to the term
<code class="hljs">b + c</code>; without specifying the argument, the tactic would instead rewrite
<code class="hljs">a + (b + c)</code> to <code class="hljs">(b + c) + a</code>. Finally, the last step applies
associativity in the reverse direction rewriting <code class="hljs">a + (c + b)</code> to
<code class="hljs">a + c + b</code>. The next two examples instead apply associativity to
move the parenthesis to the right on both sides, and then switch <code class="hljs">b</code>
and <code class="hljs">c</code>. Notice that the last example specifies that the rewrite
should take place on the right-hand side by specifying the second
argument to <code class="hljs">Nat.add_comm</code>.</p>
<p>By default, the <code class="hljs">rewrite</code> tactic affects only the goal. The notation
<code class="hljs">rw [t] at h</code> applies the rewrite <code class="hljs">t</code> at hypothesis <code class="hljs">h</code>.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> (f : Nat → Nat) (a : Nat) (h : a + <span class="hljs-number">0</span> = <span class="hljs-number">0</span>) : f a = f <span class="hljs-number">0</span> := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">rw</span> [Nat.add_zero] <span class="hljs-built_in">at</span> h
  <span class="hljs-built_in">rw</span> [h]
</code></pre>
<p>The first step, <code class="hljs">rw [Nat.add_zero] at h</code>, rewrites the hypothesis <code class="hljs">a + 0 = 0</code> to <code class="hljs">a = 0</code>.
Then the new hypothesis <code class="hljs">a = 0</code> is used to rewrite the goal to <code class="hljs">f 0 = f 0</code>.</p>
<p>The <code class="hljs">rewrite</code> tactic is not restricted to propositions.
In the following example, we use <code class="hljs">rw [h] at t</code> to rewrite the hypothesis <code class="hljs">t : Tuple α n</code> to <code class="hljs">t : Tuple α 0</code>.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">T</span><span class="hljs-title">u</span><span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">e</span> <span class="hljs-params">(α : <span class="hljs-built_in">Type</span>)</span> <span class="hljs-params">(n : Nat)</span> <span class="hljs-symbol">:</span></span>=
  { as : List α // as.length = n }

<span class="hljs-keyword">example</span> (n : Nat) (h : n = <span class="hljs-number">0</span>) (t : Tuple α n) : Tuple α <span class="hljs-number">0</span> := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">rw</span> [h] <span class="hljs-built_in">at</span> t
  <span class="hljs-built_in">exact</span> t
</code></pre>
<h2><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/tactics.html#a-name_using_simpausing-the-simplifier" id="a-name_using_simpausing-the-simplifier"></a><a name="_using_simp"></a>Using the Simplifier</h2>
<p>Whereas <code class="hljs">rewrite</code> is designed as a surgical tool for manipulating a
goal, the simplifier offers a more powerful form of automation. A
number of identities in Lean's library have been tagged with the
<code class="hljs">[simp]</code> attribute, and the <code class="hljs">simp</code> tactic uses them to iteratively
rewrite subterms in an expression.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> (x y z : Nat) (p : Nat → <span class="hljs-built_in">Prop</span>) (h : p (x * y))
        : (x + <span class="hljs-number">0</span>) * (<span class="hljs-number">0</span> + y * <span class="hljs-number">1</span> + z * <span class="hljs-number">0</span>) = x * y := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">simp</span>

<span class="hljs-keyword">example</span> (x y z : Nat) (p : Nat → <span class="hljs-built_in">Prop</span>) (h : p (x * y))
        : p ((x + <span class="hljs-number">0</span>) * (<span class="hljs-number">0</span> + y * <span class="hljs-number">1</span> + z * <span class="hljs-number">0</span>)) := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">simp</span>; <span class="hljs-built_in">assumption</span>
</code></pre>
<p>In the first example, the left-hand side of the equality in the goal
is simplified using the usual identities involving 0 and 1, reducing
the goal to <code class="hljs">x * y = x * y</code>. At that point, <code class="hljs">simp</code> applies
reflexivity to finish it off. In the second example, <code class="hljs">simp</code> reduces
the goal to <code class="hljs">p (x * y)</code>, at which point the assumption <code class="hljs">h</code>
finishes it off. Here are some more examples
with lists:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">open</span> List

<span class="hljs-keyword">example</span> (xs : List Nat)
        : reverse (xs ++ [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]) = [<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>] ++ reverse xs := <span class="hljs-keyword">by</span>
 <span class="hljs-built_in">simp</span>

<span class="hljs-keyword">example</span> (xs ys : List α)
        : length (reverse (xs ++ ys)) = length xs + length ys := <span class="hljs-keyword">by</span>
 <span class="hljs-built_in">simp</span> [Nat.add_comm]
</code></pre>
<p>As with <code class="hljs">rw</code>, you can use the keyword <code class="hljs">at</code> to simplify a hypothesis:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> (x y z : Nat) (p : Nat → <span class="hljs-built_in">Prop</span>)
        (h : p ((x + <span class="hljs-number">0</span>) * (<span class="hljs-number">0</span> + y * <span class="hljs-number">1</span> + z * <span class="hljs-number">0</span>))) : p (x * y) := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">simp</span> <span class="hljs-built_in">at</span> h; <span class="hljs-built_in">assumption</span>
</code></pre>
<p>Moreover, you can use a "wildcard" asterisk to simplify all the hypotheses and the goal:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">attribute</span> [<span class="hljs-keyword">local</span> <span class="hljs-built_in">simp</span>] Nat.mul_comm Nat.mul_assoc Nat.mul_left_comm
<span class="hljs-keyword">attribute</span> [<span class="hljs-keyword">local</span> <span class="hljs-built_in">simp</span>] Nat.add_assoc Nat.add_comm Nat.add_left_comm

<span class="hljs-keyword">example</span> (w x y z : Nat) (p : Nat → <span class="hljs-built_in">Prop</span>)
        (h : p (x * y + z * w  * x)) : p (x * w * z + y * x) := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">simp</span> <span class="hljs-built_in">at</span> *; <span class="hljs-built_in">assumption</span>

<span class="hljs-keyword">example</span> (x y z : Nat) (p : Nat → <span class="hljs-built_in">Prop</span>)
        (h₁ : p (<span class="hljs-number">1</span> * x + y)) (h₂ : p  (x * z * <span class="hljs-number">1</span>))
        : p (y + <span class="hljs-number">0</span> + x) ∧ p (z * x) := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">simp</span> <span class="hljs-built_in">at</span> * &lt;;&gt; <span class="hljs-built_in">constructor</span> &lt;;&gt; <span class="hljs-built_in">assumption</span>
</code></pre>
<p>For operations that are commutative and associative, like
multiplication on the natural numbers, the simplifier uses these two
facts to rewrite an expression, as well as <em>left commutativity</em>. In
the case of multiplication the latter is expressed as follows:
<code class="hljs">x * (y * z) = y * (x * z)</code>. The <code class="hljs">local</code> modifier tells the simplifier
to use these rules in the current file (or section or namespace, as
the case may be). It may seem that commutativity and
left-commutativity are problematic, in that repeated application of
either causes looping. But the simplifier detects identities that
permute their arguments, and uses a technique known as <em>ordered
rewriting</em>. This means that the system maintains an internal ordering
of terms, and only applies the identity if doing so decreases the
order. With the three identities mentioned above, this has the effect
that all the parentheses in an expression are associated to the right,
and the expressions are ordered in a canonical (though somewhat
arbitrary) way. Two expressions that are equivalent up to
associativity and commutativity are then rewritten to the same
canonical form.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="Show hidden lines" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="boring"><span class="hljs-keyword">attribute</span> [<span class="hljs-keyword">local</span> <span class="hljs-built_in">simp</span>] Nat.mul_comm Nat.mul_assoc Nat.mul_left_comm
</span><span class="boring"><span class="hljs-keyword">attribute</span> [<span class="hljs-keyword">local</span> <span class="hljs-built_in">simp</span>] Nat.add_assoc Nat.add_comm Nat.add_left_comm
</span><span class="hljs-keyword">example</span> (w x y z : Nat) (p : Nat → <span class="hljs-built_in">Prop</span>)
        : x * y + z * w  * x = x * w * z + y * x := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">simp</span>

<span class="hljs-keyword">example</span> (w x y z : Nat) (p : Nat → <span class="hljs-built_in">Prop</span>)
        (h : p (x * y + z * w  * x)) : p (x * w * z + y * x) := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">simp</span>; <span class="hljs-built_in">simp</span> <span class="hljs-built_in">at</span> h; <span class="hljs-built_in">assumption</span>
</code></pre>
<p>As with <code class="hljs">rewrite</code>, you can send <code class="hljs">simp</code> a list of facts to use,
including general lemmas, local hypotheses, definitions to unfold, and
compound expressions. The <code class="hljs">simp</code> tactic also recognizes the <code class="hljs">←t</code>
syntax that <code class="hljs">rewrite</code> does. In any case, the additional rules are
added to the collection of identities that are used to simplify a
term.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span> <span class="hljs-params">(m n : Nat)</span> <span class="hljs-symbol">:</span></span> Nat :=
  m + n + m

<span class="hljs-keyword">example</span> {m n : Nat} (h : n = <span class="hljs-number">1</span>) (h' : <span class="hljs-number">0</span> = m) : (f m n) = n := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">simp</span> [h, ←h', f]
</code></pre>
<p>A common idiom is to simplify a goal using local hypotheses:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> (f : Nat → Nat) (k : Nat) (h₁ : f <span class="hljs-number">0</span> = <span class="hljs-number">0</span>) (h₂ : k = <span class="hljs-number">0</span>) : f k = <span class="hljs-number">0</span> := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">simp</span> [h₁, h₂]
</code></pre>
<p>To use all the hypotheses present in the local context when
simplifying, we can use the wildcard symbol, <code class="hljs">*</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> (f : Nat → Nat) (k : Nat) (h₁ : f <span class="hljs-number">0</span> = <span class="hljs-number">0</span>) (h₂ : k = <span class="hljs-number">0</span>) : f k = <span class="hljs-number">0</span> := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">simp</span> [*]
</code></pre>
<p>Here is another example:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> (u w x y z : Nat) (h₁ : x = y + z) (h₂ : w = u + x)
        : w = z + y + u := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">simp</span> [*, Nat.add_assoc, Nat.add_comm, Nat.add_left_comm]
</code></pre>
<p>The simplifier will also do propositional rewriting. For example,
using the hypothesis <code class="hljs">p</code>, it rewrites <code class="hljs">p ∧ q</code> to <code class="hljs">q</code> and <code class="hljs">p ∨ q</code> to <code class="hljs">true</code>, which it then proves trivially. Iterating such
rewrites produces nontrivial propositional reasoning.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> (p q : <span class="hljs-built_in">Prop</span>) (hp : p) : p ∧ q ↔ q := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">simp</span> [*]

<span class="hljs-keyword">example</span> (p q : <span class="hljs-built_in">Prop</span>) (hp : p) : p ∨ q := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">simp</span> [*]

<span class="hljs-keyword">example</span> (p q r : <span class="hljs-built_in">Prop</span>) (hp : p) (hq : q) : p ∧ (q ∨ r) := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">simp</span> [*]
</code></pre>
<p>The next example simplifies all the hypotheses, and then uses them to prove the goal.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> (u w x x' y y' z : Nat) (p : Nat → <span class="hljs-built_in">Prop</span>)
        (h₁ : x + <span class="hljs-number">0</span> = x') (h₂ : y + <span class="hljs-number">0</span> = y')
        : x + y + <span class="hljs-number">0</span> = x' + y' := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">simp</span> <span class="hljs-built_in">at</span> *
  <span class="hljs-built_in">simp</span> [*]
</code></pre>
<p>One thing that makes the simplifier especially useful is that its
capabilities can grow as a library develops. For example, suppose we
define a list operation that symmetrizes its input by appending its
reversal:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span><span class="hljs-title">k</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">y</span><span class="hljs-title">m</span><span class="hljs-title">m</span> <span class="hljs-params">(xs : List α)</span> <span class="hljs-symbol">:</span></span>=
  xs ++ xs.reverse
</code></pre>
<p>Then for any list <code class="hljs">xs</code>, <code class="hljs">reverse (mk_symm xs)</code> is equal to <code class="hljs">mk_symm xs</code>,
which can easily be proved by unfolding the definition:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="Show hidden lines" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="boring"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span><span class="hljs-title">k</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">y</span><span class="hljs-title">m</span><span class="hljs-title">m</span> <span class="hljs-params">(xs : List α)</span> <span class="hljs-symbol">:</span></span>=
</span><span class="boring"> xs ++ xs.reverse
</span><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">v</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">s</span><span class="hljs-title">e</span><span class="hljs-title">_</span><span class="hljs-title">m</span><span class="hljs-title">k</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">y</span><span class="hljs-title">m</span><span class="hljs-title">m</span> <span class="hljs-params">(xs : List α)</span>
        <span class="hljs-symbol">:</span></span> (mk_symm xs).reverse = mk_symm xs := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">simp</span> [mk_symm]
</code></pre>
<p>We can now use this theorem to prove new results:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="Show hidden lines" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="boring"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span><span class="hljs-title">k</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">y</span><span class="hljs-title">m</span><span class="hljs-title">m</span> <span class="hljs-params">(xs : List α)</span> <span class="hljs-symbol">:</span></span>=
</span><span class="boring"> xs ++ xs.reverse
</span><span class="boring"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">v</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">s</span><span class="hljs-title">e</span><span class="hljs-title">_</span><span class="hljs-title">m</span><span class="hljs-title">k</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">y</span><span class="hljs-title">m</span><span class="hljs-title">m</span> <span class="hljs-params">(xs : List α)</span>
</span></span><span class="boring"><span class="hljs-theorem">       <span class="hljs-symbol">:</span></span> (mk_symm xs).reverse = mk_symm xs := <span class="hljs-keyword">by</span>
</span><span class="boring"> <span class="hljs-built_in">simp</span> [mk_symm]
</span><span class="hljs-keyword">example</span> (xs ys : List Nat)
        : (xs ++ mk_symm ys).reverse = mk_symm ys ++ xs.reverse := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">simp</span> [reverse_mk_symm]

<span class="hljs-keyword">example</span> (xs ys : List Nat) (p : List Nat → <span class="hljs-built_in">Prop</span>)
        (h : p (xs ++ mk_symm ys).reverse)
        : p (mk_symm ys ++ xs.reverse) := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">simp</span> [reverse_mk_symm] <span class="hljs-built_in">at</span> h; <span class="hljs-built_in">assumption</span>
</code></pre>
<p>But using <code class="hljs">reverse_mk_symm</code> is generally the right thing to do, and
it would be nice if users did not have to invoke it explicitly. You can
achieve that by marking it as a simplification rule when the theorem
is defined:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="Show hidden lines" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="boring"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span><span class="hljs-title">k</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">y</span><span class="hljs-title">m</span><span class="hljs-title">m</span> <span class="hljs-params">(xs : List α)</span> <span class="hljs-symbol">:</span></span>=
</span><span class="boring"> xs ++ xs.reverse
</span><span class="hljs-meta">@[simp]</span> <span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">v</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">s</span><span class="hljs-title">e</span><span class="hljs-title">_</span><span class="hljs-title">m</span><span class="hljs-title">k</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">y</span><span class="hljs-title">m</span><span class="hljs-title">m</span> <span class="hljs-params">(xs : List α)</span>
        <span class="hljs-symbol">:</span></span> (mk_symm xs).reverse = mk_symm xs := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">simp</span> [mk_symm]

<span class="hljs-keyword">example</span> (xs ys : List Nat)
        : (xs ++ mk_symm ys).reverse = mk_symm ys ++ xs.reverse := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">simp</span>

<span class="hljs-keyword">example</span> (xs ys : List Nat) (p : List Nat → <span class="hljs-built_in">Prop</span>)
        (h : p (xs ++ mk_symm ys).reverse)
        : p (mk_symm ys ++ xs.reverse) := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">simp</span> <span class="hljs-built_in">at</span> h; <span class="hljs-built_in">assumption</span>
</code></pre>
<p>The notation <code class="hljs">@[simp]</code> declares <code class="hljs">reverse_mk_symm</code> to have the
<code class="hljs">[simp]</code> attribute, and can be spelled out more explicitly:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="Show hidden lines" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="boring"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span><span class="hljs-title">k</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">y</span><span class="hljs-title">m</span><span class="hljs-title">m</span> <span class="hljs-params">(xs : List α)</span> <span class="hljs-symbol">:</span></span>=
</span><span class="boring"> xs ++ xs.reverse
</span><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">v</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">s</span><span class="hljs-title">e</span><span class="hljs-title">_</span><span class="hljs-title">m</span><span class="hljs-title">k</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">y</span><span class="hljs-title">m</span><span class="hljs-title">m</span> <span class="hljs-params">(xs : List α)</span>
        <span class="hljs-symbol">:</span></span> (mk_symm xs).reverse = mk_symm xs := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">simp</span> [mk_symm]

<span class="hljs-keyword">attribute</span> [<span class="hljs-built_in">simp</span>] reverse_mk_symm

<span class="hljs-keyword">example</span> (xs ys : List Nat)
        : (xs ++ mk_symm ys).reverse = mk_symm ys ++ xs.reverse := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">simp</span>

<span class="hljs-keyword">example</span> (xs ys : List Nat) (p : List Nat → <span class="hljs-built_in">Prop</span>)
        (h : p (xs ++ mk_symm ys).reverse)
        : p (mk_symm ys ++ xs.reverse) := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">simp</span> <span class="hljs-built_in">at</span> h; <span class="hljs-built_in">assumption</span>
</code></pre>
<p>The attribute can also be applied any time after the theorem is declared:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="Show hidden lines" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="boring"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span><span class="hljs-title">k</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">y</span><span class="hljs-title">m</span><span class="hljs-title">m</span> <span class="hljs-params">(xs : List α)</span> <span class="hljs-symbol">:</span></span>=
</span><span class="boring"> xs ++ xs.reverse
</span><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">v</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">s</span><span class="hljs-title">e</span><span class="hljs-title">_</span><span class="hljs-title">m</span><span class="hljs-title">k</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">y</span><span class="hljs-title">m</span><span class="hljs-title">m</span> <span class="hljs-params">(xs : List α)</span>
        <span class="hljs-symbol">:</span></span> (mk_symm xs).reverse = mk_symm xs := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">simp</span> [mk_symm]

<span class="hljs-keyword">example</span> (xs ys : List Nat)
        : (xs ++ mk_symm ys).reverse = mk_symm ys ++ xs.reverse := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">simp</span>[reverse_mk_symm]

<span class="hljs-keyword">attribute</span> [<span class="hljs-built_in">simp</span>] reverse_mk_symm

<span class="hljs-keyword">example</span> (xs ys : List Nat) (p : List Nat → <span class="hljs-built_in">Prop</span>)
        (h : p (xs ++ mk_symm ys).reverse)
        : p (mk_symm ys ++ xs.reverse) := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">simp</span> <span class="hljs-built_in">at</span> h; <span class="hljs-built_in">assumption</span>
</code></pre>
<p>Once the attribute is applied, however, there is no way to permanently
remove it; it persists in any file that imports the one where the
attribute is assigned. As we will discuss further in
<a href="https://leanprover.github.io/theorem_proving_in_lean4/TBD">Attributes</a>, one can limit the scope of an attribute to the
current file or section using the <code class="hljs">local</code> modifier:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="Show hidden lines" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="boring"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span><span class="hljs-title">k</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">y</span><span class="hljs-title">m</span><span class="hljs-title">m</span> <span class="hljs-params">(xs : List α)</span> <span class="hljs-symbol">:</span></span>=
</span><span class="boring"> xs ++ xs.reverse
</span><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">v</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">s</span><span class="hljs-title">e</span><span class="hljs-title">_</span><span class="hljs-title">m</span><span class="hljs-title">k</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">y</span><span class="hljs-title">m</span><span class="hljs-title">m</span> <span class="hljs-params">(xs : List α)</span>
        <span class="hljs-symbol">:</span></span> (mk_symm xs).reverse = mk_symm xs := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">simp</span> [mk_symm]

<span class="hljs-keyword">section</span>
<span class="hljs-keyword">attribute</span> [<span class="hljs-keyword">local</span> <span class="hljs-built_in">simp</span>] reverse_mk_symm

<span class="hljs-keyword">example</span> (xs ys : List Nat)
        : (xs ++ mk_symm ys).reverse = mk_symm ys ++ xs.reverse := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">simp</span>

<span class="hljs-keyword">example</span> (xs ys : List Nat) (p : List Nat → <span class="hljs-built_in">Prop</span>)
        (h : p (xs ++ mk_symm ys).reverse)
        : p (mk_symm ys ++ xs.reverse) := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">simp</span> <span class="hljs-built_in">at</span> h; <span class="hljs-built_in">assumption</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Outside the section, the simplifier will no longer use
<code class="hljs">reverse_mk_symm</code> by default.</p>
<p>Note that the various <code class="hljs">simp</code> options we have discussed --- giving an
explicit list of rules, and using <code class="hljs">at</code> to specify the location --- can be combined,
but the order they are listed is rigid. You can see the correct order
in an editor by placing the cursor on the <code class="hljs">simp</code> identifier to see
the documentation string that is associated with it.</p>
<p>There are two additional modifiers that are useful. By default,
<code class="hljs">simp</code> includes all theorems that have been marked with the
attribute <code class="hljs">[simp]</code>. Writing <code class="hljs">simp only</code> excludes these defaults,
allowing you to use a more explicitly crafted list of
rules. In the examples below, the minus sign and
<code class="hljs">only</code> are used to block the application of <code class="hljs">reverse_mk_symm</code>.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span><span class="hljs-title">k</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">y</span><span class="hljs-title">m</span><span class="hljs-title">m</span> <span class="hljs-params">(xs : List α)</span> <span class="hljs-symbol">:</span></span>=
  xs ++ xs.reverse
<span class="hljs-meta">@[simp]</span> <span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">v</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">s</span><span class="hljs-title">e</span><span class="hljs-title">_</span><span class="hljs-title">m</span><span class="hljs-title">k</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">y</span><span class="hljs-title">m</span><span class="hljs-title">m</span> <span class="hljs-params">(xs : List α)</span>
        <span class="hljs-symbol">:</span></span> (mk_symm xs).reverse = mk_symm xs := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">simp</span> [mk_symm]

<span class="hljs-keyword">example</span> (xs ys : List Nat) (p : List Nat → <span class="hljs-built_in">Prop</span>)
        (h : p (xs ++ mk_symm ys).reverse)
        : p (mk_symm ys ++ xs.reverse) := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">simp</span> <span class="hljs-built_in">at</span> h; <span class="hljs-built_in">assumption</span>

<span class="hljs-keyword">example</span> (xs ys : List Nat) (p : List Nat → <span class="hljs-built_in">Prop</span>)
        (h : p (xs ++ mk_symm ys).reverse)
        : p ((mk_symm ys).reverse ++ xs.reverse) := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">simp</span> [-reverse_mk_symm] <span class="hljs-built_in">at</span> h; <span class="hljs-built_in">assumption</span>

<span class="hljs-keyword">example</span> (xs ys : List Nat) (p : List Nat → <span class="hljs-built_in">Prop</span>)
        (h : p (xs ++ mk_symm ys).reverse)
        : p ((mk_symm ys).reverse ++ xs.reverse) := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">simp</span> only [List.reverse_append] <span class="hljs-built_in">at</span> h; <span class="hljs-built_in">assumption</span>
</code></pre>
<h2><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/tactics.html#extensible-tactics" id="extensible-tactics">Extensible Tactics</a></h2>
<p>In the following example, we define the notation <code class="hljs">triv</code> using the command <code class="hljs">syntax</code>.
Then, we use the command <code class="hljs">macro_rules</code> to specify what should
be done when <code class="hljs">triv</code> is used. You can provide different expansions, and the tactic
interpreter will try all of them until one succeeds.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-comment">-- Define a new tactic notation</span>
<span class="hljs-keyword">syntax</span> <span class="hljs-string">"triv"</span> : <span class="hljs-built_in">tactic</span>

<span class="hljs-keyword">macro_rules</span>
  | `(<span class="hljs-built_in">tactic</span>| triv) =&gt; `(<span class="hljs-built_in">tactic</span>| <span class="hljs-built_in">assumption</span>)

<span class="hljs-keyword">example</span> (h : p) : p := <span class="hljs-keyword">by</span>
  triv

<span class="hljs-comment">-- You cannot prove the following theorem using `triv`</span>
<span class="hljs-comment">-- example (x : α) : x = x := by</span>
<span class="hljs-comment">--  triv</span>

<span class="hljs-comment">-- Let's extend `triv`. The tactic interpreter</span>
<span class="hljs-comment">-- tries all possible macro extensions for `triv` until one succeeds</span>
<span class="hljs-keyword">macro_rules</span>
  | `(<span class="hljs-built_in">tactic</span>| triv) =&gt; `(<span class="hljs-built_in">tactic</span>| <span class="hljs-built_in">rfl</span>)

<span class="hljs-keyword">example</span> (x : α) : x = x := <span class="hljs-keyword">by</span>
  triv

<span class="hljs-keyword">example</span> (x : α) (h : p) : x = x ∧ p := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">apply</span> And.<span class="hljs-built_in">intro</span> &lt;;&gt; triv

<span class="hljs-comment">-- We now add a (recursive) extension</span>
<span class="hljs-keyword">macro_rules</span> | `(<span class="hljs-built_in">tactic</span>| triv) =&gt; `(<span class="hljs-built_in">tactic</span>| <span class="hljs-built_in">apply</span> And.<span class="hljs-built_in">intro</span> &lt;;&gt; triv)

<span class="hljs-keyword">example</span> (x : α) (h : p) : x = x ∧ p := <span class="hljs-keyword">by</span>
  triv
</code></pre>
<h2><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/tactics.html#exercises" id="exercises">Exercises</a></h2>
<ol>
<li>
<p>Go back to the exercises in <a href="https://leanprover.github.io/theorem_proving_in_lean4/propositions_and_proofs.html">Chapter Propositions and
Proofs</a> and
<a href="https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html">Chapter Quantifiers and Equality</a> and
redo as many as you can now with tactic proofs, using also <code class="hljs">rw</code>
and <code class="hljs">simp</code> as appropriate.</p>
</li>
<li>
<p>Use tactic combinators to obtain a one line proof of the following:</p>
</li>
</ol>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"> <span class="hljs-keyword">example</span> (p q r : <span class="hljs-built_in">Prop</span>) (hp : p)
         : (p ∨ q ∨ r) ∧ (q ∨ p ∨ r) ∧ (q ∨ r ∨ p) := <span class="hljs-keyword">by</span>
   <span class="hljs-strong">admit</span>
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="https://leanprover.github.io/theorem_proving_in_lean4/interacting_with_lean.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="https://leanprover.github.io/theorem_proving_in_lean4/interacting_with_lean.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="./Tactics - Theorem Proving in Lean 4_files/elasticlunr.min.js.다운로드" type="text/javascript" charset="utf-8"></script>
        <script src="./Tactics - Theorem Proving in Lean 4_files/mark.min.js.다운로드" type="text/javascript" charset="utf-8"></script>
        <script src="./Tactics - Theorem Proving in Lean 4_files/searcher.js.다운로드" type="text/javascript" charset="utf-8"></script>
        

        <script src="./Tactics - Theorem Proving in Lean 4_files/clipboard.min.js.다운로드" type="text/javascript" charset="utf-8"></script>
        <script src="./Tactics - Theorem Proving in Lean 4_files/highlight.js.다운로드" type="text/javascript" charset="utf-8"></script>
        <script src="./Tactics - Theorem Proving in Lean 4_files/book.js.다운로드" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    

</body></html>