<!DOCTYPE html>
<!-- saved from url=(0080)https://leanprover.github.io/theorem_proving_in_lean4/interacting_with_lean.html -->
<html lang="en" class="js sidebar-visible light"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <!-- Book generated using mdBook -->
        
        <title>Interacting with Lean - Theorem Proving in Lean 4</title>
        
        


        <!-- Custom HTML head -->
        


        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="rgba(0, 0, 0, 0)">

        
        <link rel="icon" href="https://leanprover.github.io/theorem_proving_in_lean4/favicon.svg">
        
        
        <link rel="shortcut icon" href="https://leanprover.github.io/theorem_proving_in_lean4/favicon.png">
        
        <link rel="stylesheet" href="./Interacting with Lean - Theorem Proving in Lean 4_files/variables.css">
        <link rel="stylesheet" href="./Interacting with Lean - Theorem Proving in Lean 4_files/general.css">
        <link rel="stylesheet" href="./Interacting with Lean - Theorem Proving in Lean 4_files/chrome.css">
        
        <link rel="stylesheet" href="./Interacting with Lean - Theorem Proving in Lean 4_files/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="./Interacting with Lean - Theorem Proving in Lean 4_files/font-awesome.css">
        
        <link rel="stylesheet" href="./Interacting with Lean - Theorem Proving in Lean 4_files/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="./Interacting with Lean - Theorem Proving in Lean 4_files/highlight.css">
        <link rel="stylesheet" href="./Interacting with Lean - Theorem Proving in Lean 4_files/tomorrow-night.css" disabled="">
        <link rel="stylesheet" href="./Interacting with Lean - Theorem Proving in Lean 4_files/ayu-highlight.css" disabled="">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents" aria-hidden="false">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="https://leanprover.github.io/theorem_proving_in_lean4/title_page.html" tabindex="0">Theorem Proving in Lean 4</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/introduction.html" tabindex="0"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/dependent_type_theory.html" tabindex="0"><strong aria-hidden="true">2.</strong> Dependent Type Theory</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/propositions_and_proofs.html" tabindex="0"><strong aria-hidden="true">3.</strong> Propositions and Proofs</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html" tabindex="0"><strong aria-hidden="true">4.</strong> Quantifiers and Equality</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/tactics.html" tabindex="0"><strong aria-hidden="true">5.</strong> Tactics</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/interacting_with_lean.html" class="active" tabindex="0"><strong aria-hidden="true">6.</strong> Interacting with Lean</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/inductive_types.html" tabindex="0"><strong aria-hidden="true">7.</strong> Inductive Types</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/induction_and_recursion.html" tabindex="0"><strong aria-hidden="true">8.</strong> Induction and Recursion</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/structures_and_records.html" tabindex="0"><strong aria-hidden="true">9.</strong> Structures and Records</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/type_classes.html" tabindex="0"><strong aria-hidden="true">10.</strong> Type Classes</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/conv.html" tabindex="0"><strong aria-hidden="true">11.</strong> The Conversion Tactic Mode</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/theorem_proving_in_lean4/axioms_and_computation.html" tabindex="0"><strong aria-hidden="true">12.</strong> Axioms and Computation</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar" style="top: 0px;">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar" aria-expanded="true">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Theorem Proving in Lean 4</h1>

                    <div class="right-buttons">
                        
                        <a href="https://leanprover.github.io/theorem_proving_in_lean4/print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/leanprover/theorem_proving_in_lean4" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/interacting_with_lean.html#interacting-with-lean" id="interacting-with-lean">Interacting with Lean</a></h1>
<p>You are now familiar with the fundamentals of dependent type theory,
both as a language for defining mathematical objects and a language
for constructing proofs. The one thing you are missing is a mechanism
for defining new data types. We will fill this gap in the next
chapter, which introduces the notion of an <em>inductive data type</em>. But
first, in this chapter, we take a break from the mechanics of type
theory to explore some pragmatic aspects of interacting with Lean.</p>
<p>Not all of the information found here will be useful to you right
away. We recommend skimming this section to get a sense of Lean's
features, and then returning to it as necessary.</p>
<h2><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/interacting_with_lean.html#a-name_importing_filesa-importing-files" id="a-name_importing_filesa-importing-files"></a><a name="_importing_files"></a> Importing Files</h2>
<p>The goal of Lean's front end is to interpret user input, construct
formal expressions, and check that they are well formed and type
correct. Lean also supports the use of various editors, which provide
continuous checking and feedback. More information can be found on the
Lean <a href="http://leanprover.github.io/documentation/">documentation pages</a>.</p>
<p>The definitions and theorems in Lean's standard library are spread
across multiple files. Users may also wish to make use of additional
libraries, or develop their own projects across multiple files. When
Lean starts, it automatically imports the contents of the library
<code class="hljs">Init</code> folder, which includes a number of fundamental definitions
and constructions. As a result, most of the examples we present here
work "out of the box."</p>
<p>If you want to use additional files, however, they need to be imported
manually, via an <code class="hljs">import</code> statement at the beginning of a file. The
command</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="hljs">import Bar.Baz.Blah
</code></pre>
<p>imports the file <code class="hljs">Bar/Baz/Blah.olean</code>, where the descriptions are
interpreted relative to the Lean <em>search path</em>. Information as to how
the search path is determined can be found on the
<a href="http://leanprover.github.io/documentation/">documentation pages</a>.
By default, it includes the standard library directory, and (in some contexts)
the root of the user's local project. One can also specify imports relative to the current directory; for example,
Importing is transitive. In other words, if you import <code class="hljs">Foo</code> and <code class="hljs">Foo</code> imports <code class="hljs">Bar</code>,
then you also have access to the contents of <code class="hljs">Bar</code>, and do not need to import it explicitly.</p>
<h2><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/interacting_with_lean.html#more-on-sections" id="more-on-sections">More on Sections</a></h2>
<p>Lean provides various sectioning mechanisms to help structure a
theory. You saw in <a href="https://leanprover.github.io/theorem_proving_in_lean4/dependent_type_theory.html#_variables_and_sections">Variables and Sections</a> that the
<code class="hljs">section</code> command makes it possible not only to group together
elements of a theory that go together, but also to declare variables
that are inserted as arguments to theorems and definitions, as
necessary. Remember that the point of the <code class="hljs">variable</code> command is to
declare variables for use in theorems, as in the following example:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">section</span>
<span class="hljs-keyword">variable</span> (x y : Nat)

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span><span class="hljs-title">o</span><span class="hljs-title">u</span><span class="hljs-title">b</span><span class="hljs-title">l</span><span class="hljs-title">e</span> <span class="hljs-symbol">:</span></span>= x + x

<span class="hljs-keyword">#check</span> double y
<span class="hljs-keyword">#check</span> double (<span class="hljs-number">2</span> * x)

<span class="hljs-keyword">attribute</span> [<span class="hljs-keyword">local</span> <span class="hljs-built_in">simp</span>] Nat.add_assoc Nat.add_comm Nat.add_left_comm

<span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">t1</span> <span class="hljs-symbol">:</span></span> double (x + y) = double x + double y := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">simp</span> [double]

<span class="hljs-keyword">#check</span> t1 y
<span class="hljs-keyword">#check</span> t1 (<span class="hljs-number">2</span> * x)

<span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">t2</span> <span class="hljs-symbol">:</span></span> double (x * y) = double x * y := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">simp</span> [double, Nat.add_mul]

<span class="hljs-keyword">end</span>
</code></pre>
<p>The definition of <code class="hljs">double</code> does not have to declare <code class="hljs">x</code> as an
argument; Lean detects the dependence and inserts it
automatically. Similarly, Lean detects the occurrence of <code class="hljs">x</code> in
<code class="hljs">t1</code> and <code class="hljs">t2</code>, and inserts it automatically there, too.
Note that double does <em>not</em> have <code class="hljs">y</code> as argument. Variables are only
included in declarations where they are actually used.</p>
<h2><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/interacting_with_lean.html#more-on-namespaces" id="more-on-namespaces">More on Namespaces</a></h2>
<p>In Lean, identifiers are given by hierarchical <em>names</em> like
<code class="hljs">Foo.Bar.baz</code>. We saw in <a href="https://leanprover.github.io/theorem_proving_in_lean4/dependent_type_theory.html#_namespaces">Namespaces</a> that Lean provides
mechanisms for working with hierarchical names. The command
<code class="hljs">namespace foo</code> causes <code class="hljs">foo</code> to be prepended to the name of each
definition and theorem until <code class="hljs">end foo</code> is encountered. The command
<code class="hljs">open foo</code> then creates temporary <em>aliases</em> to definitions and
theorems that begin with prefix <code class="hljs">foo</code>.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">namespace</span> Foo
<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">b</span><span class="hljs-title">a</span><span class="hljs-title">r</span> <span class="hljs-symbol">:</span></span> Nat := <span class="hljs-number">1</span>
<span class="hljs-keyword">end</span> Foo

<span class="hljs-keyword">open</span> Foo

<span class="hljs-keyword">#check</span> bar
<span class="hljs-keyword">#check</span> Foo.bar
</code></pre>
<p>The following definition</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">F</span><span class="hljs-title">o</span><span class="hljs-title">o</span>.<span class="hljs-title">b</span><span class="hljs-title">a</span><span class="hljs-title">r</span> <span class="hljs-symbol">:</span></span> Nat := <span class="hljs-number">1</span>
</code></pre>
<p>is treated as a macro, and expands to</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">namespace</span> Foo
<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">b</span><span class="hljs-title">a</span><span class="hljs-title">r</span> <span class="hljs-symbol">:</span></span> Nat := <span class="hljs-number">1</span>
<span class="hljs-keyword">end</span> Foo
</code></pre>
<p>Although the names of theorems and definitions have to be unique, the
aliases that identify them do not. When we open a namespace, an
identifier may be ambiguous. Lean tries to use type information to
disambiguate the meaning in context, but you can always disambiguate
by giving the full name. To that end, the string <code class="hljs">_root_</code> is an
explicit description of the empty prefix.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">S</span><span class="hljs-title">t</span><span class="hljs-title">r</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">g</span>.<span class="hljs-title">a</span><span class="hljs-title">d</span><span class="hljs-title">d</span> <span class="hljs-params">(a b : String)</span> <span class="hljs-symbol">:</span></span> String :=
  a ++ b

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">B</span><span class="hljs-title">o</span><span class="hljs-title">o</span><span class="hljs-title">l</span>.<span class="hljs-title">a</span><span class="hljs-title">d</span><span class="hljs-title">d</span> <span class="hljs-params">(a b : Bool)</span> <span class="hljs-symbol">:</span></span> Bool :=
  a != b

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span><span class="hljs-title">d</span><span class="hljs-title">d</span> <span class="hljs-params">(α β : <span class="hljs-built_in">Type</span>)</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Type</span> := Sum α β

<span class="hljs-keyword">open</span> Bool
<span class="hljs-keyword">open</span> String
<span class="hljs-comment">-- #check add -- ambiguous</span>
<span class="hljs-keyword">#check</span> String.add           <span class="hljs-comment">-- String → String → String</span>
<span class="hljs-keyword">#check</span> Bool.add             <span class="hljs-comment">-- Bool → Bool → Bool</span>
<span class="hljs-keyword">#check</span> _root_.add           <span class="hljs-comment">-- Type → Type → Type</span>

<span class="hljs-keyword">#check</span> add <span class="hljs-string">"hello"</span> <span class="hljs-string">"world"</span>  <span class="hljs-comment">-- String</span>
<span class="hljs-keyword">#check</span> add <span class="hljs-literal">true</span> <span class="hljs-literal">false</span>       <span class="hljs-comment">-- Bool</span>
<span class="hljs-keyword">#check</span> add Nat Nat          <span class="hljs-comment">-- Type</span>
</code></pre>
<p>We can prevent the shorter alias from being created by using the <code class="hljs">protected</code> keyword:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">protected</span> <span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">F</span><span class="hljs-title">o</span><span class="hljs-title">o</span>.<span class="hljs-title">b</span><span class="hljs-title">a</span><span class="hljs-title">r</span> <span class="hljs-symbol">:</span></span> Nat := <span class="hljs-number">1</span>

<span class="hljs-keyword">open</span> Foo

<span class="hljs-comment">-- #check bar -- error</span>
<span class="hljs-keyword">#check</span> Foo.bar
</code></pre>
<p>This is often used for names like <code class="hljs">Nat.rec</code> and <code class="hljs">Nat.recOn</code>, to prevent
overloading of common names.</p>
<p>The <code class="hljs">open</code> command admits variations. The command</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">open</span> Nat (succ zero gcd)
<span class="hljs-keyword">#check</span> zero     <span class="hljs-comment">-- Nat</span>
<span class="hljs-keyword">#eval</span> gcd <span class="hljs-number">15</span> <span class="hljs-number">6</span>  <span class="hljs-comment">-- 3</span>
</code></pre>
<p>creates aliases for only the identifiers listed. The command</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">open</span> Nat <span class="hljs-keyword">hiding</span> succ gcd
<span class="hljs-keyword">#check</span> zero     <span class="hljs-comment">-- Nat</span>
<span class="hljs-comment">-- #eval gcd 15 6  -- error</span>
<span class="hljs-keyword">#eval</span> Nat.gcd <span class="hljs-number">15</span> <span class="hljs-number">6</span>  <span class="hljs-comment">-- 3</span>
</code></pre>
<p>creates aliases for everything in the <code class="hljs">Nat</code> namespace <em>except</em> the identifiers listed.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">open</span> Nat <span class="hljs-keyword">renaming</span> mul → times, add → plus
<span class="hljs-keyword">#eval</span> plus (times <span class="hljs-number">2</span> <span class="hljs-number">2</span>) <span class="hljs-number">3</span>  <span class="hljs-comment">-- 7</span>
</code></pre>
<p>creates aliases renaming <code class="hljs">Nat.mul</code> to <code class="hljs">times</code> and <code class="hljs">Nat.add</code> to <code class="hljs">plus</code>.</p>
<p>It is sometimes useful to <code class="hljs">export</code> aliases from one namespace to another, or to the top level. The command</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">export</span> Nat (succ add sub)
</code></pre>
<p>creates aliases for <code class="hljs">succ</code>, <code class="hljs">add</code>, and <code class="hljs">sub</code> in the current
namespace, so that whenever the namespace is open, these aliases are
available. If this command is used outside a namespace, the aliases
are exported to the top level.</p>
<h2><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/interacting_with_lean.html#attributes" id="attributes">Attributes</a></h2>
<p>The main function of Lean is to translate user input to formal
expressions that are checked by the kernel for correctness and then
stored in the environment for later use. But some commands have other
effects on the environment, either assigning attributes to objects in
the environment, defining notation, or declaring instances of type
classes, as described in <a href="https://leanprover.github.io/theorem_proving_in_lean4/type_classes.html">Chapter Type Classes</a>. Most of
these commands have global effects, which is to say, that they remain
in effect not only in the current file, but also in any file that
imports it. However, such commands often support the <code class="hljs">local</code> modifier,
which indicates that they only have effect until
the current <code class="hljs">section</code> or <code class="hljs">namespace</code> is closed, or until the end
of the current file.</p>
<p>In <a href="https://leanprover.github.io/theorem_proving_in_lean4/tactics.html#_using_the_simp">Section Using the Simplifier</a>,
we saw that theorems can be annotated with the <code class="hljs">[simp]</code> attribute,
which makes them available for use by the simplifier.
The following example defines the prefix relation on lists,
proves that this relation is reflexive, and assigns the <code class="hljs">[simp]</code> attribute to that theorem.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">P</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">f</span><span class="hljs-title">i</span><span class="hljs-title">x</span> <span class="hljs-params">(l₁ : List α)</span> <span class="hljs-params">(l₂ : List α)</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Prop</span> :=
  ∃ t, l₁ ++ t = l₂

<span class="hljs-meta">@[simp]</span> <span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">L</span><span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">t</span>.<span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">P</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">f</span><span class="hljs-title">i</span><span class="hljs-title">x</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">e</span><span class="hljs-title">l</span><span class="hljs-title">f</span> <span class="hljs-params">(as : List α)</span> <span class="hljs-symbol">:</span></span> isPrefix as as :=
  ⟨[], <span class="hljs-keyword">by</span> <span class="hljs-built_in">simp</span>⟩

<span class="hljs-keyword">example</span> : isPrefix [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">simp</span>
</code></pre>
<p>The simplifier then proves <code class="hljs">isPrefix [1, 2, 3] [1, 2, 3]</code> by rewriting it to <code class="hljs">True</code>.</p>
<p>One can also assign the attribute any time after the definition takes place:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="Show hidden lines" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="boring"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">P</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">f</span><span class="hljs-title">i</span><span class="hljs-title">x</span> <span class="hljs-params">(l₁ : List α)</span> <span class="hljs-params">(l₂ : List α)</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Prop</span> :=
</span><span class="boring"> ∃ t, l₁ ++ t = l₂
</span><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">L</span><span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">t</span>.<span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">P</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">f</span><span class="hljs-title">i</span><span class="hljs-title">x</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">e</span><span class="hljs-title">l</span><span class="hljs-title">f</span> <span class="hljs-params">(as : List α)</span> <span class="hljs-symbol">:</span></span> isPrefix as as :=
  ⟨[], <span class="hljs-keyword">by</span> <span class="hljs-built_in">simp</span>⟩

<span class="hljs-keyword">attribute</span> [<span class="hljs-built_in">simp</span>] List.isPrefix_self
</code></pre>
<p>In all these cases, the attribute remains in effect in any file that
imports the one in which the declaration occurs. Adding the <code class="hljs">local</code>
modifier restricts the scope:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="Show hidden lines" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="boring"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">P</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">f</span><span class="hljs-title">i</span><span class="hljs-title">x</span> <span class="hljs-params">(l₁ : List α)</span> <span class="hljs-params">(l₂ : List α)</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Prop</span> :=
</span><span class="boring"> ∃ t, l₁ ++ t = l₂
</span><span class="hljs-keyword">section</span>

<span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">L</span><span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">t</span>.<span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">P</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">f</span><span class="hljs-title">i</span><span class="hljs-title">x</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">e</span><span class="hljs-title">l</span><span class="hljs-title">f</span> <span class="hljs-params">(as : List α)</span> <span class="hljs-symbol">:</span></span> isPrefix as as :=
  ⟨[], <span class="hljs-keyword">by</span> <span class="hljs-built_in">simp</span>⟩

<span class="hljs-keyword">attribute</span> [<span class="hljs-keyword">local</span> <span class="hljs-built_in">simp</span>] List.isPrefix_self

<span class="hljs-keyword">example</span> : isPrefix [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] := <span class="hljs-keyword">by</span>
  <span class="hljs-built_in">simp</span>

<span class="hljs-keyword">end</span>

<span class="hljs-comment">-- Error:</span>
<span class="hljs-comment">-- example : isPrefix [1, 2, 3] [1, 2, 3] := by</span>
<span class="hljs-comment">--  simp</span>
</code></pre>
<p>For another example, we can use the <code class="hljs">instance</code> command to assign the
notation <code class="hljs">≤</code> to the <code class="hljs">isPrefix</code> relation. That command, which will
be explained in <a href="https://leanprover.github.io/theorem_proving_in_lean4/type_classes.html">Chapter Type Classes</a>, works by
assigning an <code class="hljs">[instance]</code> attribute to the associated definition.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">P</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">f</span><span class="hljs-title">i</span><span class="hljs-title">x</span> <span class="hljs-params">(l₁ : List α)</span> <span class="hljs-params">(l₂ : List α)</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Prop</span> :=
  ∃ t, l₁ ++ t = l₂

<span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> LE (List α) <span class="hljs-keyword">where</span>
  le := isPrefix

<span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">L</span><span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">t</span>.<span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">P</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">f</span><span class="hljs-title">i</span><span class="hljs-title">x</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">e</span><span class="hljs-title">l</span><span class="hljs-title">f</span> <span class="hljs-params">(as : List α)</span> <span class="hljs-symbol">:</span></span> as ≤ as :=
  ⟨[], <span class="hljs-keyword">by</span> <span class="hljs-built_in">simp</span>⟩
</code></pre>
<p>That assignment can also be made local:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="Show hidden lines" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="boring"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">P</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">f</span><span class="hljs-title">i</span><span class="hljs-title">x</span> <span class="hljs-params">(l₁ : List α)</span> <span class="hljs-params">(l₂ : List α)</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Prop</span> :=
</span><span class="boring">  ∃ t, l₁ ++ t = l₂
</span><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">s</span><span class="hljs-title">t</span><span class="hljs-title">L</span><span class="hljs-title">e</span> <span class="hljs-symbol">:</span></span> LE (List α) :=
  { le := isPrefix }

<span class="hljs-keyword">section</span>
<span class="hljs-keyword">attribute</span> [<span class="hljs-keyword">local</span> <span class="hljs-theorem"><span class="hljs-keyword">instance</span>] <span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">s</span><span class="hljs-title">t</span><span class="hljs-title">L</span><span class="hljs-title">e</span>

<span class="hljs-title">e</span><span class="hljs-title">x</span><span class="hljs-title">a</span><span class="hljs-title">m</span><span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">e</span> <span class="hljs-params">(as : List α)</span> <span class="hljs-symbol">:</span></span> as ≤ as :=
  ⟨[], <span class="hljs-keyword">by</span> <span class="hljs-built_in">simp</span>⟩

<span class="hljs-keyword">end</span>

<span class="hljs-comment">-- Error:</span>
<span class="hljs-comment">-- example (as : List α) : as ≤ as :=</span>
<span class="hljs-comment">--  ⟨[], by simp⟩</span>
</code></pre>
<p>In <a href="https://leanprover.github.io/theorem_proving_in_lean4/interacting_with_lean.html#notation">Section Notation</a> below, we will discuss Lean's
mechanisms for defining notation, and see that they also support the
<code class="hljs">local</code> modifier. However, in <a href="https://leanprover.github.io/theorem_proving_in_lean4/interacting_with_lean.html#setting_options">Section Setting Options</a>, we will
discuss Lean's mechanisms for setting options, which does <em>not</em> follow
this pattern: options can <em>only</em> be set locally, which is to say,
their scope is always restricted to the current section or current
file.</p>
<h2><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/interacting_with_lean.html#more-on-implicit-arguments" id="more-on-implicit-arguments">More on Implicit Arguments</a></h2>
<p>In <a href="https://leanprover.github.io/theorem_proving_in_lean4/dependent_type_theory.html#_implicit_args">Section Implicit Arguments</a>,
we saw that if Lean displays the type
of a term <code class="hljs">t</code> as <code class="hljs">{x : α} → β x</code>, then the curly brackets
indicate that <code class="hljs">x</code> has been marked as an <em>implicit argument</em> to
<code class="hljs">t</code>. This means that whenever you write <code class="hljs">t</code>, a placeholder, or
"hole," is inserted, so that <code class="hljs">t</code> is replaced by <code class="hljs">@t _</code>. If you
don't want that to happen, you have to write <code class="hljs">@t</code> instead.</p>
<p>Notice that implicit arguments are inserted eagerly. Suppose we define
a function <code class="hljs">f (x : Nat) {y : Nat} (z : Nat)</code> with the arguments
shown. Then, when we write the expression <code class="hljs">f 7</code> without further
arguments, it is parsed as <code class="hljs">f 7 _</code>. Lean offers a weaker annotation,
<code class="hljs">{{y : ℕ}}</code>, which specifies that a placeholder should only be added
<em>before</em> a subsequent explicit argument. This annotation can also be
written using as <code class="hljs">⦃y : Nat⦄</code>, where the unicode brackets are entered
as <code class="hljs">\{{</code> and <code class="hljs">\}}</code>, respectively. With this annotation, the
expression <code class="hljs">f 7</code> would be parsed as is, whereas <code class="hljs">f 7 3</code> would be
parsed as <code class="hljs">f 7 _ 3</code>, just as it would be with the strong annotation.</p>
<p>To illustrate the difference, consider the following example, which
shows that a reflexive euclidean relation is both symmetric and
transitive.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">f</span><span class="hljs-title">l</span><span class="hljs-title">e</span><span class="hljs-title">x</span><span class="hljs-title">i</span><span class="hljs-title">v</span><span class="hljs-title">e</span> <span class="hljs-params">{α : <span class="hljs-built_in">Type</span> u}</span> <span class="hljs-params">(r : α → α → <span class="hljs-built_in">Prop</span>)</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Prop</span> :=
  ∀ (a : α), r a a

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">s</span><span class="hljs-title">y</span><span class="hljs-title">m</span><span class="hljs-title">m</span><span class="hljs-title">e</span><span class="hljs-title">t</span><span class="hljs-title">r</span><span class="hljs-title">i</span><span class="hljs-title">c</span> <span class="hljs-params">{α : <span class="hljs-built_in">Type</span> u}</span> <span class="hljs-params">(r : α → α → <span class="hljs-built_in">Prop</span>)</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Prop</span> :=
  ∀ {a b : α}, r a b → r b a

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">t</span><span class="hljs-title">r</span><span class="hljs-title">a</span><span class="hljs-title">n</span><span class="hljs-title">s</span><span class="hljs-title">i</span><span class="hljs-title">t</span><span class="hljs-title">i</span><span class="hljs-title">v</span><span class="hljs-title">e</span> <span class="hljs-params">{α : <span class="hljs-built_in">Type</span> u}</span> <span class="hljs-params">(r : α → α → <span class="hljs-built_in">Prop</span>)</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Prop</span> :=
  ∀ {a b c : α}, r a b → r b c → r a c

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">e</span><span class="hljs-title">u</span><span class="hljs-title">c</span><span class="hljs-title">l</span><span class="hljs-title">i</span><span class="hljs-title">d</span><span class="hljs-title">e</span><span class="hljs-title">a</span><span class="hljs-title">n</span> <span class="hljs-params">{α : <span class="hljs-built_in">Type</span> u}</span> <span class="hljs-params">(r : α → α → <span class="hljs-built_in">Prop</span>)</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Prop</span> :=
  ∀ {a b c : α}, r a b → r a c → r b c

<span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">t</span><span class="hljs-title">h1</span> <span class="hljs-params">{α : <span class="hljs-built_in">Type</span> u}</span> <span class="hljs-params">{r : α → α → <span class="hljs-built_in">Prop</span>}</span>
            <span class="hljs-params">(reflr : reflexive r)</span> <span class="hljs-params">(euclr : euclidean r)</span>
            <span class="hljs-symbol">:</span></span> symmetric r :=
  <span class="hljs-keyword">fun</span> {a b : α} =&gt;
  <span class="hljs-keyword">fun</span> (h : r a b) =&gt;
  <span class="hljs-built_in">show</span> r b a <span class="hljs-built_in">from</span> euclr h (reflr _)

<span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">t</span><span class="hljs-title">h2</span> <span class="hljs-params">{α : <span class="hljs-built_in">Type</span> u}</span> <span class="hljs-params">{r : α → α → <span class="hljs-built_in">Prop</span>}</span>
            <span class="hljs-params">(symmr : symmetric r)</span> <span class="hljs-params">(euclr : euclidean r)</span>
            <span class="hljs-symbol">:</span></span> transitive r :=
  <span class="hljs-keyword">fun</span> {a b c : α} =&gt;
  <span class="hljs-keyword">fun</span> (rab : r a b) (rbc : r b c) =&gt;
  euclr (symmr rab) rbc

<span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">t</span><span class="hljs-title">h3</span> <span class="hljs-params">{α : <span class="hljs-built_in">Type</span> u}</span> <span class="hljs-params">{r : α → α → <span class="hljs-built_in">Prop</span>}</span>
            <span class="hljs-params">(reflr : reflexive r)</span> <span class="hljs-params">(euclr : euclidean r)</span>
            <span class="hljs-symbol">:</span></span> transitive r :=
 @th2 _ _ (@th1 _ _ reflr @euclr) @euclr

<span class="hljs-keyword">variable</span> (r : α → α → <span class="hljs-built_in">Prop</span>)
<span class="hljs-keyword">variable</span> (euclr : euclidean r)

<span class="hljs-keyword">#check</span> euclr  <span class="hljs-comment">-- r ?m1 ?m2 → r ?m1 ?m3 → r ?m2 ?m3</span>
</code></pre>
<p>The results are broken down into small steps: <code class="hljs">th1</code> shows that a
relation that is reflexive and euclidean is symmetric, and <code class="hljs">th2</code>
shows that a relation that is symmetric and euclidean is
transitive. Then <code class="hljs">th3</code> combines the two results. But notice that we
have to manually disable the implicit arguments in <code class="hljs">th1</code>, <code class="hljs">th2</code>,
and <code class="hljs">euclr</code>, because otherwise too many implicit arguments are
inserted. The problem goes away if we use weak implicit arguments:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">f</span><span class="hljs-title">l</span><span class="hljs-title">e</span><span class="hljs-title">x</span><span class="hljs-title">i</span><span class="hljs-title">v</span><span class="hljs-title">e</span> <span class="hljs-params">{α : <span class="hljs-built_in">Type</span> u}</span> <span class="hljs-params">(r : α → α → <span class="hljs-built_in">Prop</span>)</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Prop</span> :=
  ∀ (a : α), r a a

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">s</span><span class="hljs-title">y</span><span class="hljs-title">m</span><span class="hljs-title">m</span><span class="hljs-title">e</span><span class="hljs-title">t</span><span class="hljs-title">r</span><span class="hljs-title">i</span><span class="hljs-title">c</span> <span class="hljs-params">{α : <span class="hljs-built_in">Type</span> u}</span> <span class="hljs-params">(r : α → α → <span class="hljs-built_in">Prop</span>)</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Prop</span> :=
  ∀ {{a b : α}}, r a b → r b a

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">t</span><span class="hljs-title">r</span><span class="hljs-title">a</span><span class="hljs-title">n</span><span class="hljs-title">s</span><span class="hljs-title">i</span><span class="hljs-title">t</span><span class="hljs-title">i</span><span class="hljs-title">v</span><span class="hljs-title">e</span> <span class="hljs-params">{α : <span class="hljs-built_in">Type</span> u}</span> <span class="hljs-params">(r : α → α → <span class="hljs-built_in">Prop</span>)</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Prop</span> :=
  ∀ {{a b c : α}}, r a b → r b c → r a c

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">e</span><span class="hljs-title">u</span><span class="hljs-title">c</span><span class="hljs-title">l</span><span class="hljs-title">i</span><span class="hljs-title">d</span><span class="hljs-title">e</span><span class="hljs-title">a</span><span class="hljs-title">n</span> <span class="hljs-params">{α : <span class="hljs-built_in">Type</span> u}</span> <span class="hljs-params">(r : α → α → <span class="hljs-built_in">Prop</span>)</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Prop</span> :=
  ∀ {{a b c : α}}, r a b → r a c → r b c

<span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">t</span><span class="hljs-title">h1</span> <span class="hljs-params">{α : <span class="hljs-built_in">Type</span> u}</span> <span class="hljs-params">{r : α → α → <span class="hljs-built_in">Prop</span>}</span>
            <span class="hljs-params">(reflr : reflexive r)</span> <span class="hljs-params">(euclr : euclidean r)</span>
            <span class="hljs-symbol">:</span></span> symmetric r :=
  <span class="hljs-keyword">fun</span> {a b : α} =&gt;
  <span class="hljs-keyword">fun</span> (h : r a b) =&gt;
  <span class="hljs-built_in">show</span> r b a <span class="hljs-built_in">from</span> euclr h (reflr _)

<span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">t</span><span class="hljs-title">h2</span> <span class="hljs-params">{α : <span class="hljs-built_in">Type</span> u}</span> <span class="hljs-params">{r : α → α → <span class="hljs-built_in">Prop</span>}</span>
            <span class="hljs-params">(symmr : symmetric r)</span> <span class="hljs-params">(euclr : euclidean r)</span>
            <span class="hljs-symbol">:</span></span> transitive r :=
  <span class="hljs-keyword">fun</span> {a b c : α} =&gt;
  <span class="hljs-keyword">fun</span> (rab : r a b) (rbc : r b c) =&gt;
  euclr (symmr rab) rbc

<span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">t</span><span class="hljs-title">h3</span> <span class="hljs-params">{α : <span class="hljs-built_in">Type</span> u}</span> <span class="hljs-params">{r : α → α → <span class="hljs-built_in">Prop</span>}</span>
            <span class="hljs-params">(reflr : reflexive r)</span> <span class="hljs-params">(euclr : euclidean r)</span>
            <span class="hljs-symbol">:</span></span> transitive r :=
  th2 (th1 reflr euclr) euclr

<span class="hljs-keyword">variable</span> (r : α → α → <span class="hljs-built_in">Prop</span>)
<span class="hljs-keyword">variable</span> (euclr : euclidean r)

<span class="hljs-keyword">#check</span> euclr  <span class="hljs-comment">-- euclidean r</span>
</code></pre>
<p>There is a third kind of implicit argument that is denoted with square
brackets, <code class="hljs">[</code> and <code class="hljs">]</code>. These are used for type classes, as
explained in <a href="https://leanprover.github.io/theorem_proving_in_lean4/type_classes.html">Chapter Type Classes</a>.</p>
<h2><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/interacting_with_lean.html#notation" id="notation">Notation</a></h2>
<p>Identifiers in Lean can include any alphanumeric characters, including
Greek characters (other than ∀ , Σ , and λ , which, as we have seen,
have a special meaning in the dependent type theory). They can also
include subscripts, which can be entered by typing <code class="hljs">\_</code> followed by
the desired subscripted character.</p>
<p>Lean's parser is extensible, which is to say, we can define new notation.</p>
<p>Lean's syntax can be extended and customized by users at every level,
ranging from basic "mixfix" notations to custom elaborators.  In fact,
all builtin syntax is parsed and processed using the same mechanisms
and APIs open to users.  In this section, we will describe and explain
the various extension points.</p>
<p>While introducing new notations is a relatively rare feature in
programming languages and sometimes even frowned upon because of its
potential to obscure code, it is an invaluable tool in formalization
for expressing established conventions and notations of the respective
field succinctly in code.  Going beyond basic notations, Lean's
ability to factor out common boilerplate code into (well-behaved)
macros and to embed entire custom domain specific languages (DSLs) to
textually encode subproblems efficiently and readably can be of great
benefit to both programmers and proof engineers alike.</p>
<h3><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/interacting_with_lean.html#notations-and-precedence" id="notations-and-precedence">Notations and Precedence</a></h3>
<p>The most basic syntax extension commands allow introducing new (or
overloading existing) prefix, infix, and postfix operators.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="Show hidden lines" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="hljs-keyword">infixl</span>:<span class="hljs-number">65</span>   <span class="hljs-string">" + "</span> =&gt; HAdd.hAdd  <span class="hljs-comment">-- left-associative</span>
<span class="hljs-keyword">infix</span>:<span class="hljs-number">50</span>    <span class="hljs-string">" = "</span> =&gt; Eq         <span class="hljs-comment">-- non-associative</span>
<span class="hljs-keyword">infixr</span>:<span class="hljs-number">80</span>   <span class="hljs-string">" ^ "</span> =&gt; HPow.hPow  <span class="hljs-comment">-- right-associative</span>
<span class="hljs-keyword">prefix</span>:<span class="hljs-number">100</span>  <span class="hljs-string">"-"</span>   =&gt; Neg.neg
<span class="boring"><span class="hljs-keyword">set_option</span> quotPrecheck <span class="hljs-literal">false</span>
</span><span class="hljs-keyword">postfix</span>:max <span class="hljs-string">"⁻¹"</span>  =&gt; Inv.inv
</code></pre>
<p>After the initial command name describing the operator kind (its
"fixity"), we give the <em>parsing precedence</em> of the operator preceded
by a colon <code class="hljs">:</code>, then a new or existing token surrounded by double
quotes (the whitespace is used for pretty printing), then the function
this operator should be translated to after the arrow <code class="hljs">=&gt;</code>.</p>
<p>The precedence is a natural number describing how "tightly" an
operator binds to its arguments, encoding the order of operations.  We
can make this more precise by looking at the commands the above unfold to:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="Show hidden lines" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="hljs-keyword">notation</span>:<span class="hljs-number">65</span> <span class="hljs-built_in">lhs</span>:<span class="hljs-number">65</span> <span class="hljs-string">" + "</span> <span class="hljs-built_in">rhs</span>:<span class="hljs-number">66</span> =&gt; HAdd.hAdd <span class="hljs-built_in">lhs</span> <span class="hljs-built_in">rhs</span>
<span class="hljs-keyword">notation</span>:<span class="hljs-number">50</span> <span class="hljs-built_in">lhs</span>:<span class="hljs-number">51</span> <span class="hljs-string">" = "</span> <span class="hljs-built_in">rhs</span>:<span class="hljs-number">51</span> =&gt; Eq <span class="hljs-built_in">lhs</span> <span class="hljs-built_in">rhs</span>
<span class="hljs-keyword">notation</span>:<span class="hljs-number">80</span> <span class="hljs-built_in">lhs</span>:<span class="hljs-number">81</span> <span class="hljs-string">" ^ "</span> <span class="hljs-built_in">rhs</span>:<span class="hljs-number">80</span> =&gt; HPow.hPow <span class="hljs-built_in">lhs</span> <span class="hljs-built_in">rhs</span>
<span class="hljs-keyword">notation</span>:<span class="hljs-number">100</span> <span class="hljs-string">"-"</span> <span class="hljs-built_in">arg</span>:<span class="hljs-number">100</span> =&gt; Neg.neg <span class="hljs-built_in">arg</span>
<span class="boring"><span class="hljs-keyword">set_option</span> quotPrecheck <span class="hljs-literal">false</span>
</span><span class="hljs-keyword">notation</span>:<span class="hljs-number">1024</span> <span class="hljs-built_in">arg</span>:<span class="hljs-number">1024</span> <span class="hljs-string">"⁻¹"</span> =&gt; Inv.inv <span class="hljs-built_in">arg</span>  <span class="hljs-comment">-- `max` is a shorthand for precedence 1024</span>
</code></pre>
<p>It turns out that all commands from the first code block are in fact
command <em>macros</em> translating to the more general <code class="hljs">notation</code> command.
We will learn about writing such macros below.  Instead of a single
token, the <code class="hljs">notation</code> command accepts a mixed sequence of tokens and
named term placeholders with precedences, which can be referenced on
the right-hand side of <code class="hljs">=&gt;</code> and will be replaced by the respective
term parsed at that position.  A placeholder with precedence <code class="hljs">p</code>
accepts only notations with precedence at least <code class="hljs">p</code> in that place.
Thus the string <code class="hljs">a + b + c</code> cannot be parsed as the equivalent of
<code class="hljs">a + (b + c)</code> because the right-hand side operand of an <code class="hljs">infixl</code> notation
has precedence one greater than the notation itself.  In contrast,
<code class="hljs">infixr</code> reuses the notation's precedence for the right-hand side
operand, so <code class="hljs">a ^ b ^ c</code> <em>can</em> be parsed as <code class="hljs">a ^ (b ^ c)</code>.  Note that
if we used <code class="hljs">notation</code> directly to introduce an infix notation like</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="Show hidden lines" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="boring"><span class="hljs-keyword">set_option</span> quotPrecheck <span class="hljs-literal">false</span>
</span><span class="hljs-keyword">notation</span>:<span class="hljs-number">65</span> <span class="hljs-built_in">lhs</span>:<span class="hljs-number">65</span> <span class="hljs-string">" ~ "</span> <span class="hljs-built_in">rhs</span>:<span class="hljs-number">65</span> =&gt; wobble <span class="hljs-built_in">lhs</span> <span class="hljs-built_in">rhs</span>
</code></pre>
<p>where the precedences do not sufficiently determine associativity,
Lean's parser will default to right associativity.  More precisely,
Lean's parser follows a local <em>longest parse</em> rule in the presence of
ambiguous grammars: when parsing the right-hand side of <code class="hljs">a ~</code> in
<code class="hljs">a ~ b ~ c</code>, it will continue parsing as long as possible (as the current
precedence allows), not stopping after <code class="hljs">b</code> but parsing <code class="hljs">~ c</code> as well.
Thus the term is equivalent to <code class="hljs">a ~ (b ~ c)</code>.</p>
<p>As mentioned above, the <code class="hljs">notation</code> command allows us to define
arbitrary <em>mixfix</em> syntax freely mixing tokens and placeholders.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="Show hidden lines" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="boring"><span class="hljs-keyword">set_option</span> quotPrecheck <span class="hljs-literal">false</span>
</span><span class="hljs-keyword">notation</span>:max <span class="hljs-string">"("</span> e <span class="hljs-string">")"</span> =&gt; e
<span class="hljs-keyword">notation</span>:<span class="hljs-number">10</span> Γ <span class="hljs-string">" ⊢ "</span> e <span class="hljs-string">" : "</span> τ =&gt; Typing Γ e τ
</code></pre>
<p>Placeholders without precedence default to <code class="hljs">0</code>, i.e. they accept notations of any precedence in their place.
If two notations overlap, we again apply the longest parse rule:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">notation</span>:<span class="hljs-number">65</span> a <span class="hljs-string">" + "</span> b:<span class="hljs-number">66</span> <span class="hljs-string">" + "</span> c:<span class="hljs-number">66</span> =&gt; a + b - c
<span class="hljs-keyword">#eval</span> <span class="hljs-number">1</span> + <span class="hljs-number">2</span> + <span class="hljs-number">3</span>  <span class="hljs-comment">-- 0</span>
</code></pre>
<p>The new notation is preferred to the binary notation since the latter,
before chaining, would stop parsing after <code class="hljs">1 + 2</code>.  If there are
multiple notations accepting the same longest parse, the choice will
be delayed until elaboration, which will fail unless exactly one
overload is type correct.</p>
<h2><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/interacting_with_lean.html#coercions" id="coercions">Coercions</a></h2>
<p>In Lean, the type of natural numbers, <code class="hljs">Nat</code>, is different from the
type of integers, <code class="hljs">Int</code>. But there is a function <code class="hljs">Int.ofNat</code> that
embeds the natural numbers in the integers, meaning that we can view
any natural number as an integer, when needed. Lean has mechanisms to
detect and insert <em>coercions</em> of this sort.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">variable</span> (m n : Nat)
<span class="hljs-keyword">variable</span> (i j : Int)

<span class="hljs-keyword">#check</span> i + m      <span class="hljs-comment">-- i + Int.ofNat m : Int</span>
<span class="hljs-keyword">#check</span> i + m + j  <span class="hljs-comment">-- i + Int.ofNat m + j : Int</span>
<span class="hljs-keyword">#check</span> i + m + n  <span class="hljs-comment">-- i + Int.ofNat m + Int.ofNat n : Int</span>
</code></pre>
<h2><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/interacting_with_lean.html#displaying-information" id="displaying-information">Displaying Information</a></h2>
<p>There are a number of ways in which you can query Lean for information
about its current state and the objects and theorems that are
available in the current context. You have already seen two of the
most common ones, <code class="hljs">#check</code> and <code class="hljs">#eval</code>. Remember that <code class="hljs">#check</code>
is often used in conjunction with the <code class="hljs">@</code> operator, which makes all
of the arguments to a theorem or definition explicit. In addition, you
can use the <code class="hljs">#print</code> command to get information about any
identifier. If the identifier denotes a definition or theorem, Lean
prints the type of the symbol, and its definition. If it is a constant
or an axiom, Lean indicates that fact, and shows the type.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-comment">-- examples with equality</span>
<span class="hljs-keyword">#check</span> Eq
<span class="hljs-keyword">#check</span> @Eq
<span class="hljs-keyword">#check</span> Eq.symm
<span class="hljs-keyword">#check</span> @Eq.symm

<span class="hljs-keyword">#print</span> Eq.symm

<span class="hljs-comment">-- examples with And</span>
<span class="hljs-keyword">#check</span> And
<span class="hljs-keyword">#check</span> And.<span class="hljs-built_in">intro</span>
<span class="hljs-keyword">#check</span> @And.<span class="hljs-built_in">intro</span>

<span class="hljs-comment">-- a user-defined function</span>
<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-title">o</span><span class="hljs-title">o</span> <span class="hljs-params">{α : <span class="hljs-built_in">Type</span> u}</span> <span class="hljs-params">(x : α)</span> <span class="hljs-symbol">:</span></span> α := x

<span class="hljs-keyword">#check</span> foo
<span class="hljs-keyword">#check</span> @foo
<span class="hljs-keyword">#print</span> foo
</code></pre>
<h2><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/interacting_with_lean.html#setting-options" id="setting-options">Setting Options</a></h2>
<p>Lean maintains a number of internal variables that can be set by users
to control its behavior. The syntax for doing so is as follows:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="hljs">set_option &lt;name&gt; &lt;value&gt;
</code></pre>
<p>One very useful family of options controls the way Lean's <em>pretty- printer</em> displays terms. The following options take an input of true or false:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="hljs">pp.explicit  : display implicit arguments
pp.universes : display hidden universe parameters
pp.notation  : display output using defined notations
</code></pre>
<p>As an example, the following settings yield much longer output:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">set_option</span> pp.explicit <span class="hljs-literal">true</span>
<span class="hljs-keyword">set_option</span> pp.universes <span class="hljs-literal">true</span>
<span class="hljs-keyword">set_option</span> pp.<span class="hljs-keyword">notation</span> <span class="hljs-literal">false</span>

<span class="hljs-keyword">#check</span> <span class="hljs-number">2</span> + <span class="hljs-number">2</span> = <span class="hljs-number">4</span>
<span class="hljs-keyword">#reduce</span> (<span class="hljs-keyword">fun</span> x =&gt; x + <span class="hljs-number">2</span>) = (<span class="hljs-keyword">fun</span> x =&gt; x + <span class="hljs-number">3</span>)
<span class="hljs-keyword">#check</span> (<span class="hljs-keyword">fun</span> x =&gt; x + <span class="hljs-number">1</span>) <span class="hljs-number">1</span>
</code></pre>
<p>The command <code class="hljs">set_option pp.all true</code> carries out these settings all
at once, whereas <code class="hljs">set_option pp.all false</code> reverts to the previous
values. Pretty printing additional information is often very useful
when you are debugging a proof, or trying to understand a cryptic
error message. Too much information can be overwhelming, though, and
Lean's defaults are generally sufficient for ordinary interactions.</p>
<!--
Elaboration Hints
-----------------

When you ask Lean to process an expression like ``λ x y z, f (x + y) z``, you are leaving information implicit. For example, the types of ``x``, ``y``, and ``z`` have to be inferred from the context, the notation ``+`` may be overloaded, and there may be implicit arguments to ``f`` that need to be filled in as well. Moreover, we will see in :numref:`Chapter %s <type_classes>` that some implicit arguments are synthesized by a process known as *type class resolution*. And we have also already seen in the last chapter that some parts of an expression can be constructed by the tactic framework.

Inferring some implicit arguments is straightforward. For example, suppose a function ``f`` has type ``Π {α : Type*}, α → α → α`` and Lean is trying to parse the expression ``f n``, where ``n`` can be inferred to have type ``nat``. Then it is clear that the implicit argument ``α`` has to be ``nat``. However, some inference problems are *higher order*. For example, the substitution operation for equality, ``eq.subst``, has the following type:

.. code-block:: text

    eq.subst : ∀ {α : Sort u} {p : α → Prop} {a b : α},
                 a = b → p a → p b

Now suppose we are given ``a b : ℕ`` and ``h₁ : a = b`` and ``h₂ : a * b > a``. Then, in the expression ``eq.subst h₁ h₂``, ``P`` could be any of the following:

-  ``λ x, x * b > x``
-  ``λ x, x * b > a``
-  ``λ x, a * b > x``
-  ``λ x, a * b > a``

In other words, our intent may be to replace either the first or second ``a`` in ``h₂``, or both, or neither. Similar ambiguities arise in inferring induction predicates, or inferring function arguments. Even second-order unification is known to be undecidable. Lean therefore relies on heuristics to fill in such arguments, and when it fails to guess the right ones, they need to be provided explicitly.

To make matters worse, sometimes definitions need to be unfolded, and sometimes expressions need to be reduced according to the computational rules of the underlying logical framework. Once again, Lean has to rely on heuristics to determine what to unfold or reduce, and when.

There are attributes, however, that can be used to provide hints to the elaborator. One class of attributes determines how eagerly definitions are unfolded: constants can be marked with the attribute ``[reducible]``, ``[semireducible]``, or ``[irreducible]``. Definitions are marked ``[semireducible]`` by default. A definition with the ``[reducible]`` attribute is unfolded eagerly; if you think of a definition as serving as an abbreviation, this attribute would be appropriate. The elaborator avoids unfolding definitions with the ``[irreducible]`` attribute. Theorems are marked ``[irreducible]`` by default, because typically proofs are not relevant to the elaboration process.

It is worth emphasizing that these attributes are only hints to the elaborator. When checking an elaborated term for correctness, Lean's kernel will unfold whatever definitions it needs to unfold. As with other attributes, the ones above can be assigned with the ``local`` modifier, so that they are in effect only in the current section or file.

Lean also has a family of attributes that control the elaboration strategy. A definition or theorem can be marked ``[elab_with_expected_type]``, ``[elab_simple]``. or ``[elab_as_eliminator]``. When applied to a definition ``f``, these bear on elaboration of an expression ``f a b c ...`` in which ``f`` is applied to arguments. With the default attribute, ``[elab_with_expected_type]``, the arguments ``a``, ``b``, ``c``, ... are elaborating using information about their expected type, inferred from ``f`` and the previous arguments. In contrast, with ``[elab_simple]``, the arguments are elaborated from left to right without propagating information about their types. The last attribute, ``[elab_as_eliminator]``, is commonly used for eliminators like recursors, induction principles, and ``eq.subst``. It uses a separate heuristic to infer higher-order parameters. We will consider such operations in more detail in the next chapter.

Once again, these attributes can be assigned and reassigned after an object is defined, and you can use the ``local`` modifier to limit their scope. Moreover, using the ``@`` symbol in front of an identifier in an expression instructs the elaborator to use the ``[elab_simple]`` strategy; the idea is that, when you provide the tricky parameters explicitly, you want the elaborator to weigh that information heavily. In fact, Lean offers an alternative annotation, ``@@``, which leaves parameters before the first higher-order parameter implicit. For example, ``@@eq.subst`` leaves the type of the equation implicit, but makes the context of the substitution explicit.

-->
<h2><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/interacting_with_lean.html#using-the-library" id="using-the-library">Using the Library</a></h2>
<p>To use Lean effectively you will inevitably need to make use of
definitions and theorems in the library. Recall that the <code class="hljs">import</code>
command at the beginning of a file imports previously compiled results
from other files, and that importing is transitive; if you import
<code class="hljs">Foo</code> and <code class="hljs">Foo</code> imports <code class="hljs">Bar</code>, then the definitions and theorems
from <code class="hljs">Bar</code> are available to you as well. But the act of opening a
namespace, which provides shorter names, does not carry over. In each
file, you need to open the namespaces you wish to use.</p>
<p>In general, it is important for you to be familiar with the library
and its contents, so you know what theorems, definitions, notations,
and resources are available to you. Below we will see that Lean's
editor modes can also help you find things you need, but studying the
contents of the library directly is often unavoidable. Lean's standard
library can be found online, on GitHub:</p>
<ul>
<li>
<p><a href="https://github.com/leanprover/lean4/tree/master/src/Init">https://github.com/leanprover/lean4/tree/master/src/Init</a></p>
</li>
<li>
<p><a href="https://github.com/leanprover/lean4/tree/master/src/Std">https://github.com/leanprover/lean4/tree/master/src/Std</a></p>
</li>
</ul>
<p>You can see the contents of these directories and files using GitHub's
browser interface. If you have installed Lean on your own computer,
you can find the library in the <code class="hljs">lean</code> folder, and explore it with
your file manager. Comment headers at the top of each file provide
additional information.</p>
<p>Lean's library developers follow general naming guidelines to make it
easier to guess the name of a theorem you need, or to find it using
tab completion in editors with a Lean mode that supports this, which
is discussed in the next section. Identifiers are generally
<code class="hljs">camelCase</code>, and types are <code class="hljs">CamelCase</code>. For theorem names,
we rely on descriptive names where the different components are separated
by <code class="hljs">_</code>s. Often the name of theorem simply describes the conclusion:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> Nat.succ_ne_zero
<span class="hljs-keyword">#check</span> Nat.zero_add
<span class="hljs-keyword">#check</span> Nat.mul_one
<span class="hljs-keyword">#check</span> Nat.le_of_succ_le_succ
</code></pre>
<p>Remember that identifiers in Lean can be organized into hierarchical
namespaces. For example, the theorem named <code class="hljs">le_of_succ_le_succ</code> in the
namespace <code class="hljs">Nat</code> has full name <code class="hljs">Nat.le_of_succ_le_succ</code>, but the shorter
name is made available by the command <code class="hljs">open Nat</code> (for names not marked as
<code class="hljs">protected</code>). We will see in <a href="https://leanprover.github.io/theorem_proving_in_lean4/inductive_types.html">Chapter Inductive Types</a>
and <a href="https://leanprover.github.io/theorem_proving_in_lean4/structures_and_records.html">Chapter Structures and Records</a>
that defining structures and inductive data types in Lean generates
associated operations, and these are stored in
a namespace with the same name as the type under definition. For
example, the product type comes with the following operations:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> @Prod.mk
<span class="hljs-keyword">#check</span> @Prod.fst
<span class="hljs-keyword">#check</span> @Prod.snd
<span class="hljs-keyword">#check</span> @Prod.<span class="hljs-keyword">rec</span>
</code></pre>
<p>The first is used to construct a pair, whereas the next two,
<code class="hljs">Prod.fst</code> and <code class="hljs">Prod.snd</code>, project the two elements. The last,
<code class="hljs">Prod.rec</code>, provides another mechanism for defining functions on a
product in terms of a function on the two components. Names like
<code class="hljs">Prod.rec</code> are <em>protected</em>, which means that one has to use the full
name even when the <code class="hljs">Prod</code> namespace is open.</p>
<p>With the propositions as types correspondence, logical connectives are
also instances of inductive types, and so we tend to use dot notation
for them as well:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> @And.<span class="hljs-built_in">intro</span>
<span class="hljs-keyword">#check</span> @And.casesOn
<span class="hljs-keyword">#check</span> @And.left
<span class="hljs-keyword">#check</span> @And.right
<span class="hljs-keyword">#check</span> @Or.inl
<span class="hljs-keyword">#check</span> @Or.inr
<span class="hljs-keyword">#check</span> @Or.elim
<span class="hljs-keyword">#check</span> @Exists.<span class="hljs-built_in">intro</span>
<span class="hljs-keyword">#check</span> @Exists.elim
<span class="hljs-keyword">#check</span> @Eq.<span class="hljs-built_in">refl</span>
<span class="hljs-keyword">#check</span> @Eq.<span class="hljs-built_in">subst</span>
</code></pre>
<h2><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/interacting_with_lean.html#auto-bound-implicit-arguments" id="auto-bound-implicit-arguments">Auto Bound Implicit Arguments</a></h2>
<p>In the previous section, we have shown how implicit arguments make functions more convenient to use.
However, functions such as <code class="hljs">compose</code> are still quite verbose to define. Note that the universe
polymorphic <code class="hljs">compose</code> is even more verbose than the one previously defined.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">universe</span> u v w
<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">c</span><span class="hljs-title">o</span><span class="hljs-title">m</span><span class="hljs-title">p</span><span class="hljs-title">o</span><span class="hljs-title">s</span><span class="hljs-title">e</span> <span class="hljs-params">{α : <span class="hljs-built_in">Type</span> u}</span> <span class="hljs-params">{β : <span class="hljs-built_in">Type</span> v}</span> <span class="hljs-params">{γ : <span class="hljs-built_in">Type</span> w}</span>
            <span class="hljs-params">(g : β → γ)</span> <span class="hljs-params">(f : α → β)</span> <span class="hljs-params">(x : α)</span> <span class="hljs-symbol">:</span></span> γ :=
  g (f x)
</code></pre>
<p>You can avoid the <code class="hljs">universe</code> command by providing the universe parameters when defining <code class="hljs">compose</code>.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">c</span><span class="hljs-title">o</span><span class="hljs-title">m</span><span class="hljs-title">p</span><span class="hljs-title">o</span><span class="hljs-title">s</span><span class="hljs-title">e</span>.<span class="hljs-params">{u, v, w}</span>
            <span class="hljs-params">{α : <span class="hljs-built_in">Type</span> u}</span> <span class="hljs-params">{β : <span class="hljs-built_in">Type</span> v}</span> <span class="hljs-params">{γ : <span class="hljs-built_in">Type</span> w}</span>
            <span class="hljs-params">(g : β → γ)</span> <span class="hljs-params">(f : α → β)</span> <span class="hljs-params">(x : α)</span> <span class="hljs-symbol">:</span></span> γ :=
  g (f x)
</code></pre>
<p>Lean 4 supports a new feature called <em>auto bound implicit arguments</em>. It makes functions such as
<code class="hljs">compose</code> much more convenient to write. When Lean processes the header of a declaration,
any unbound identifier is automatically added as an implicit argument <em>if</em> it is a single lower case or
greek letter. With this feature we can write <code class="hljs">compose</code> as</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">c</span><span class="hljs-title">o</span><span class="hljs-title">m</span><span class="hljs-title">p</span><span class="hljs-title">o</span><span class="hljs-title">s</span><span class="hljs-title">e</span> <span class="hljs-params">(g : β → γ)</span> <span class="hljs-params">(f : α → β)</span> <span class="hljs-params">(x : α)</span> <span class="hljs-symbol">:</span></span> γ :=
  g (f x)

<span class="hljs-keyword">#check</span> @compose
<span class="hljs-comment">-- {β : Sort u_1} → {γ : Sort u_2} → {α : Sort u_3} → (β → γ) → (α → β) → α → γ</span>
</code></pre>
<p>Note that Lean inferred a more general type using <code class="hljs">Sort</code> instead of <code class="hljs">Type</code>.</p>
<p>Although we love this feature and use it extensively when implementing Lean,
we realize some users may feel uncomfortable with it. Thus, you can disable it using
the command <code class="hljs">set_option autoBoundImplicitLocal false</code>.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">set_option</span> autoBoundImplicitLocal <span class="hljs-literal">false</span>
<span class="hljs-comment">/- The following definition produces `unknown identifier` errors -/</span>
<span class="hljs-comment">-- def compose (g : β → γ) (f : α → β) (x : α) : γ :=</span>
<span class="hljs-comment">--   g (f x)</span>
</code></pre>
<h2><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/interacting_with_lean.html#implicit-lambdas" id="implicit-lambdas">Implicit Lambdas</a></h2>
<p>In Lean 3 stdlib, we find many
<a href="https://github.com/leanprover/lean/blob/master/library/init/category/reader.lean#L39">instances</a> of the dreadful <code class="hljs">@</code>+<code class="hljs">_</code> idiom.
It is often used when we the expected type is a function type with implicit arguments,
and we have a constant (<code class="hljs">reader_t.pure</code> in the example) which also takes implicit arguments. In Lean 4, the elaborator automatically introduces lambdas
for consuming implicit arguments. We are still exploring this feature and analyzing its impact, but the experience so far has been very positive. Here is the example from the link above using Lean 4 implicit lambdas.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="Show hidden lines" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="boring"><span class="hljs-keyword">variable</span> (ρ : <span class="hljs-built_in">Type</span>) (m : <span class="hljs-built_in">Type</span> → <span class="hljs-built_in">Type</span>) [Monad m]
</span><span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> Monad (ReaderT ρ m) <span class="hljs-keyword">where</span>
  pure := ReaderT.pure
  bind := ReaderT.bind
</code></pre>
<p>Users can disable the implicit lambda feature by using <code class="hljs">@</code> or writing
a lambda expression with <code class="hljs">{}</code> or <code class="hljs">[]</code> binder annotations.  Here are
few examples</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="Show hidden lines" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="boring"><span class="hljs-keyword">namespace</span> ex2
</span><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">i</span><span class="hljs-title">d1</span> <span class="hljs-symbol">:</span></span> {α : <span class="hljs-built_in">Type</span>} → α → α :=
  <span class="hljs-keyword">fun</span> x =&gt; x

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">l</span><span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">t</span><span class="hljs-title">I</span><span class="hljs-title">d</span> <span class="hljs-symbol">:</span></span> List ({α : <span class="hljs-built_in">Type</span>} → α → α) :=
  (<span class="hljs-keyword">fun</span> x =&gt; x) :: []

<span class="hljs-comment">-- In this example, implicit lambda introduction has been disabled because</span>
<span class="hljs-comment">-- we use `@` before `fun`</span>
<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">i</span><span class="hljs-title">d2</span> <span class="hljs-symbol">:</span></span> {α : <span class="hljs-built_in">Type</span>} → α → α :=
  @<span class="hljs-keyword">fun</span> α (x : α) =&gt; id1 x

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">i</span><span class="hljs-title">d3</span> <span class="hljs-symbol">:</span></span> {α : <span class="hljs-built_in">Type</span>} → α → α :=
  @<span class="hljs-keyword">fun</span> α x =&gt; id1 x

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">i</span><span class="hljs-title">d4</span> <span class="hljs-symbol">:</span></span> {α : <span class="hljs-built_in">Type</span>} → α → α :=
  <span class="hljs-keyword">fun</span> x =&gt; id1 x

<span class="hljs-comment">-- In this example, implicit lambda introduction has been disabled</span>
<span class="hljs-comment">-- because we used the binder annotation `{...}`</span>
<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">i</span><span class="hljs-title">d5</span> <span class="hljs-symbol">:</span></span> {α : <span class="hljs-built_in">Type</span>} → α → α :=
  <span class="hljs-keyword">fun</span> {α} x =&gt; id1 x
<span class="boring"><span class="hljs-keyword">end</span> ex2
</span></code></pre>
<h2><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/interacting_with_lean.html#sugar-for-simple-functions" id="sugar-for-simple-functions">Sugar for Simple Functions</a></h2>
<p>In Lean 3, we can create simple functions from infix operators by
using parentheses. For example, <code class="hljs">(+1)</code> is sugar for <code class="hljs">fun x, x + 1</code>. In
Lean 4, we generalize this notation using <code class="hljs">·</code> As a placeholder. Here
are a few examples:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-eye" title="Show hidden lines" aria-label="Show hidden lines"></button></div><code class="language-lean hljs hide-boring"><span class="boring"><span class="hljs-keyword">namespace</span> ex3
</span><span class="hljs-keyword">#check</span> (· + <span class="hljs-number">1</span>)
<span class="hljs-comment">-- fun a =&gt; a + 1</span>
<span class="hljs-keyword">#check</span> (<span class="hljs-number">2</span> - ·)
<span class="hljs-comment">-- fun a =&gt; 2 - a</span>
<span class="hljs-keyword">#eval</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>].foldl (·*·) <span class="hljs-number">1</span>
<span class="hljs-comment">-- 120</span>

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span> <span class="hljs-params">(x y z : Nat)</span> <span class="hljs-symbol">:</span></span>=
  x + y + z

<span class="hljs-keyword">#check</span> (f · <span class="hljs-number">1</span> ·)
<span class="hljs-comment">-- fun a b =&gt; f a 1 b</span>

<span class="hljs-keyword">#eval</span> [(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">4</span>), (<span class="hljs-number">5</span>, <span class="hljs-number">6</span>)].map (·.<span class="hljs-number">1</span>)
<span class="hljs-comment">-- [1, 3, 5]</span>
<span class="boring"><span class="hljs-keyword">end</span> ex3
</span></code></pre>
<p>As in Lean 3, the notation is activated using parentheses, and the lambda abstraction is created by collecting the nested <code class="hljs">·</code>s.
The collection is interrupted by nested parentheses. In the following example, two different lambda expressions are created.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> (Prod.mk · (· + <span class="hljs-number">1</span>))
<span class="hljs-comment">-- fun a =&gt; (a, fun b =&gt; b + 1)</span>
</code></pre>
<h2><a class="header" href="https://leanprover.github.io/theorem_proving_in_lean4/interacting_with_lean.html#named-arguments" id="named-arguments">Named Arguments</a></h2>
<p>Named arguments enable you to specify an argument for a parameter by
matching the argument with its name rather than with its position in
the parameter list.  If you don't remember the order of the parameters
but know their names, you can send the arguments in any order. You may
also provide the value for an implicit parameter when Lean failed to
infer it. Named arguments also improve the readability of your code by
identifying what each argument represents.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">s</span><span class="hljs-title">u</span><span class="hljs-title">m</span> <span class="hljs-params">(xs : List Nat)</span> <span class="hljs-symbol">:</span></span>=
  xs.foldl (init := <span class="hljs-number">0</span>) (·+·)

<span class="hljs-keyword">#eval</span> sum [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]
<span class="hljs-comment">-- 10</span>

<span class="hljs-keyword">example</span> {a b : Nat} {p : Nat → Nat → Nat → <span class="hljs-built_in">Prop</span>} (h₁ : p a b b) (h₂ : b = a)
    : p a a b :=
  Eq.<span class="hljs-built_in">subst</span> (motive := <span class="hljs-keyword">fun</span> x =&gt; p a x b) h₂ h₁
</code></pre>
<p>In the following examples, we illustrate the interaction between named
and default arguments.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span> <span class="hljs-params">(x : Nat)</span> <span class="hljs-params">(y : Nat := 1)</span> <span class="hljs-params">(w : Nat := 2)</span> <span class="hljs-params">(z : Nat)</span> <span class="hljs-symbol">:</span></span>=
  x + y + w - z

<span class="hljs-keyword">example</span> (x z : Nat) : f (z := z) x = x + <span class="hljs-number">1</span> + <span class="hljs-number">2</span> - z := <span class="hljs-built_in">rfl</span>

<span class="hljs-keyword">example</span> (x z : Nat) : f x (z := z) = x + <span class="hljs-number">1</span> + <span class="hljs-number">2</span> - z := <span class="hljs-built_in">rfl</span>

<span class="hljs-keyword">example</span> (x y : Nat) : f x y = <span class="hljs-keyword">fun</span> z =&gt; x + y + <span class="hljs-number">2</span> - z := <span class="hljs-built_in">rfl</span>

<span class="hljs-keyword">example</span> : f = (<span class="hljs-keyword">fun</span> x z =&gt; x + <span class="hljs-number">1</span> + <span class="hljs-number">2</span> - z) := <span class="hljs-built_in">rfl</span>

<span class="hljs-keyword">example</span> (x : Nat) : f x = <span class="hljs-keyword">fun</span> z =&gt; x + <span class="hljs-number">1</span> + <span class="hljs-number">2</span> - z := <span class="hljs-built_in">rfl</span>

<span class="hljs-keyword">example</span> (y : Nat) : f (y := <span class="hljs-number">5</span>) = <span class="hljs-keyword">fun</span> x z =&gt; x + <span class="hljs-number">5</span> + <span class="hljs-number">2</span> - z := <span class="hljs-built_in">rfl</span>

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">g</span> <span class="hljs-params">{α}</span> <span class="hljs-params">[Add α]</span> <span class="hljs-params">(a : α)</span> <span class="hljs-params">(b? : Option α := none)</span> <span class="hljs-params">(c : α)</span> <span class="hljs-symbol">:</span></span> α :=
  <span class="hljs-keyword">match</span> b? <span class="hljs-keyword">with</span>
  | none   =&gt; a + c
  | some b =&gt; a + b + c

<span class="hljs-keyword">variable</span> {α} [Add α]

<span class="hljs-keyword">example</span> : g = <span class="hljs-keyword">fun</span> (a c : α) =&gt; a + c := <span class="hljs-built_in">rfl</span>

<span class="hljs-keyword">example</span> (x : α) : g (c := x) = <span class="hljs-keyword">fun</span> (a : α) =&gt; a + x := <span class="hljs-built_in">rfl</span>

<span class="hljs-keyword">example</span> (x : α) : g (b? := some x) = <span class="hljs-keyword">fun</span> (a c : α) =&gt; a + x + c := <span class="hljs-built_in">rfl</span>

<span class="hljs-keyword">example</span> (x : α) : g x = <span class="hljs-keyword">fun</span> (c : α) =&gt; x + c := <span class="hljs-built_in">rfl</span>

<span class="hljs-keyword">example</span> (x y : α) : g x y = <span class="hljs-keyword">fun</span> (c : α) =&gt; x + y + c := <span class="hljs-built_in">rfl</span>
</code></pre>
<p>You can use <code class="hljs">..</code> to provide missing explicit arguments as <code class="hljs">_</code>.
This feature combined with named arguments is useful for writing patterns. Here is an example:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">inductive</span> Term <span class="hljs-keyword">where</span>
  | var    (name : String)
  | num    (val : Nat)
  | add    (fn : Term) (<span class="hljs-built_in">arg</span> : Term)
  | lambda (name : String) (type : Term) (body : Term)

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">g</span><span class="hljs-title">e</span><span class="hljs-title">t</span><span class="hljs-title">B</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">d</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">N</span><span class="hljs-title">a</span><span class="hljs-title">m</span><span class="hljs-title">e</span> <span class="hljs-symbol">:</span></span> Term → Option String
  | Term.lambda (name := n) .. =&gt; some n
  | _ =&gt; none

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">g</span><span class="hljs-title">e</span><span class="hljs-title">t</span><span class="hljs-title">B</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">d</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">T</span><span class="hljs-title">y</span><span class="hljs-title">p</span><span class="hljs-title">e</span> <span class="hljs-symbol">:</span></span> Term → Option Term
  | Term.lambda (type := t) .. =&gt; some t
  | _ =&gt; none
</code></pre>
<p>Ellipses are also useful when explicit argument can be automatically
inferred by Lean, and we want to avoid a sequence of <code class="hljs">_</code>s.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> (f : Nat → Nat) (a b c : Nat) : f (a + b + c) = f (a + (b + c)) :=
  <span class="hljs-built_in">congrArg</span> f (Nat.add_assoc ..)
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="https://leanprover.github.io/theorem_proving_in_lean4/tactics.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="https://leanprover.github.io/theorem_proving_in_lean4/inductive_types.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="https://leanprover.github.io/theorem_proving_in_lean4/tactics.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="https://leanprover.github.io/theorem_proving_in_lean4/inductive_types.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="./Interacting with Lean - Theorem Proving in Lean 4_files/elasticlunr.min.js.다운로드" type="text/javascript" charset="utf-8"></script>
        <script src="./Interacting with Lean - Theorem Proving in Lean 4_files/mark.min.js.다운로드" type="text/javascript" charset="utf-8"></script>
        <script src="./Interacting with Lean - Theorem Proving in Lean 4_files/searcher.js.다운로드" type="text/javascript" charset="utf-8"></script>
        

        <script src="./Interacting with Lean - Theorem Proving in Lean 4_files/clipboard.min.js.다운로드" type="text/javascript" charset="utf-8"></script>
        <script src="./Interacting with Lean - Theorem Proving in Lean 4_files/highlight.js.다운로드" type="text/javascript" charset="utf-8"></script>
        <script src="./Interacting with Lean - Theorem Proving in Lean 4_files/book.js.다운로드" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    

</body></html>